<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RoboView ‚Äî First-Person Robot Control</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600;700&family=Chakra+Petch:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #070a0d;
  --panel: #0c1016;
  --panel2: #111820;
  --border: #1a2230;
  --accent: #00e87b;
  --accent-dim: #00e87b22;
  --warn: #ff3d3d;
  --info: #3db8ff;
  --gold: #ffba08;
  --text: #c8d0dc;
  --text-dim: #4a5568;
  --gripper: #00d4ff;
}

html, body {
  height: 100%;
  background: var(--bg);
  color: var(--text);
  font-family: 'IBM Plex Mono', monospace;
  overflow: hidden;
  user-select: none;
}

#app {
  display: grid;
  grid-template-columns: 1fr 320px;
  grid-template-rows: 42px 1fr 48px;
  height: 100vh;
  gap: 1px;
  background: var(--border);
}

/* HEADER */
header {
  grid-column: 1 / -1;
  background: var(--panel);
  display: flex;
  align-items: center;
  padding: 0 14px;
  gap: 20px;
}
header h1 {
  font-family: 'Chakra Petch', sans-serif;
  font-weight: 700;
  font-size: 16px;
  letter-spacing: 3px;
  color: var(--accent);
}
header .tag {
  font-size: 9px;
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-dim);
  letter-spacing: 1px;
}
header .tag.live { border-color: var(--accent); color: var(--accent); animation: blink 2s infinite; }
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:.4} }
.spacer { flex: 1; }
header .stat {
  font-size: 10px;
  color: var(--text-dim);
}
header .stat b { color: var(--text); font-weight: 500; }

/* VIEWPORT */
#viewport {
  position: relative;
  background: #000;
  overflow: hidden;
}
#viewport canvas { display: block; width: 100%; height: 100%; }

/* Camera swap banner */
#cam-mode {
  position: absolute;
  top: 8px;
  left: 8px;
  font-size: 9px;
  padding: 3px 8px;
  background: #000a;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-dim);
  pointer-events: none;
  letter-spacing: 1px;
}

/* Crosshair */
#crosshair {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}
#crosshair div {
  position: absolute;
  background: var(--accent);
  opacity: 0.6;
}
#crosshair .h { width: 20px; height: 1px; top: 0; left: -10px; }
#crosshair .v { width: 1px; height: 20px; top: -10px; left: 0; }
#crosshair .dot {
  width: 3px; height: 3px; border-radius: 50%;
  top: -1px; left: -1px;
  opacity: 1;
}

/* HUD overlays */
#hud-bottom-left {
  position: absolute;
  bottom: 10px;
  left: 10px;
  font-size: 10px;
  color: var(--text-dim);
  line-height: 1.7;
  pointer-events: none;
}
#hud-bottom-left b { color: var(--accent); font-weight: 500; }
#hud-top-right {
  position: absolute;
  top: 8px;
  right: 8px;
  font-size: 9px;
  color: var(--text-dim);
  text-align: right;
  line-height: 1.7;
  pointer-events: none;
}

/* Depth indicator bar */
#depth-bar {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 200px;
  background: var(--border);
  border-radius: 2px;
  pointer-events: none;
}
#depth-fill {
  position: absolute;
  bottom: 0;
  width: 100%;
  background: var(--accent);
  border-radius: 2px;
  transition: height 0.15s;
}

/* Gripper status visual */
#gripper-visual {
  position: absolute;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%);
  pointer-events: none;
  opacity: 0.5;
}

/* RIGHT PANEL */
#panel {
  background: var(--panel);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.section {
  border-bottom: 1px solid var(--border);
}
.section-head {
  font-family: 'Chakra Petch', sans-serif;
  font-weight: 600;
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 8px 12px;
  color: var(--text-dim);
  background: var(--panel2);
}
.section-body {
  padding: 10px 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* Movement pad */
#move-pad {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-template-rows: 1fr 1fr 1fr;
  gap: 4px;
  width: 140px;
  margin: 0 auto;
}
.pad-btn {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 13px;
  font-weight: 600;
  width: 44px;
  height: 38px;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.1s;
}
.pad-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-dim); }
.pad-btn:active { transform: scale(0.93); }
.pad-btn.blank { visibility: hidden; }

/* Look controls */
#look-pad {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 4px;
  width: 140px;
  margin: 0 auto;
}

/* Sliders */
.ctrl-row {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.ctrl-row label {
  font-size: 9px;
  color: var(--text-dim);
  display: flex;
  justify-content: space-between;
  letter-spacing: 0.5px;
}
.ctrl-row label b { color: var(--accent); font-weight: 500; }
input[type="range"] {
  -webkit-appearance: none;
  width: 100%;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px; height: 12px;
  background: var(--accent);
  border-radius: 50%;
  cursor: grab;
}

/* Action buttons */
.act-btn {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  font-weight: 500;
  padding: 8px 0;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--panel2);
  color: var(--text);
  cursor: pointer;
  transition: all 0.12s;
  text-align: center;
  letter-spacing: 0.5px;
}
.act-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-dim); }
.act-btn:active { transform: scale(0.97); }
.act-btn.primary { background: var(--accent); color: var(--bg); border-color: var(--accent); font-weight: 700; }
.act-btn.primary:hover { background: #00c468; }
.act-btn.warn:hover { border-color: var(--warn); color: var(--warn); background: #ff3d3d22; }
.btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }

/* Tasks */
#task-area {
  flex: 1;
  overflow-y: auto;
  padding: 10px 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.task {
  padding: 8px 10px;
  border: 1px solid var(--border);
  border-radius: 5px;
  font-size: 11px;
  transition: all 0.15s;
}
.task .t-title { font-weight: 600; margin-bottom: 3px; }
.task .t-desc { font-size: 9px; color: var(--text-dim); line-height: 1.4; }
.task .t-badge {
  display: inline-block;
  font-size: 8px;
  padding: 2px 6px;
  border-radius: 3px;
  margin-top: 4px;
  letter-spacing: 1px;
}
.task.pending .t-badge { background: #3db8ff22; color: var(--info); }
.task.active { border-color: var(--accent); box-shadow: 0 0 10px var(--accent-dim); }
.task.active .t-badge { background: var(--accent-dim); color: var(--accent); }
.task.done { opacity: 0.4; border-color: var(--accent); }
.task.done .t-badge { background: var(--accent-dim); color: var(--accent); }

/* BOTTOM BAR */
#bottom {
  grid-column: 1 / -1;
  background: var(--panel);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 8px;
  border-top: 1px solid var(--border);
}
#cmd {
  flex: 1;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  padding: 6px 10px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  outline: none;
}
#cmd:focus { border-color: var(--accent); }
#cmd::placeholder { color: var(--text-dim); }
#log-line {
  font-size: 10px;
  color: var(--text-dim);
  max-width: 50%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Scrollbar */
::-webkit-scrollbar { width: 3px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>ROBOVIEW</h1>
    <span class="tag live">‚óè LIVE</span>
    <span class="tag">SIM MODE</span>
    <span class="spacer"></span>
    <span class="stat">FPS <b id="d-fps">60</b></span>
    <span class="stat">POS <b id="d-pos">0, 0, 0</b></span>
    <span class="stat">YAW <b id="d-yaw">0¬∞</b></span>
  </header>

  <!-- 3D VIEWPORT (replace with <video>/<img> for real camera) -->
  <div id="viewport">
    <div id="cam-mode">SIM CAMERA ¬∑ Replace with real feed ‚Üí</div>
    <div id="crosshair">
      <div class="h"></div>
      <div class="v"></div>
      <div class="dot"></div>
    </div>
    <div id="hud-bottom-left">
      Gripper: <b id="h-grip">OPEN</b><br>
      Held: <b id="h-held">‚Äî</b><br>
      Nearest: <b id="h-near">‚Äî</b> (<b id="h-dist">‚Äî</b>)
    </div>
    <div id="hud-top-right">
      <span id="h-task">‚Äî</span>
    </div>
    <div id="depth-bar"><div id="depth-fill" style="height:0%"></div></div>
  </div>

  <!-- CONTROL PANEL -->
  <div id="panel">
    <!-- Movement -->
    <div class="section">
      <div class="section-head">Movement</div>
      <div class="section-body">
        <div id="move-pad">
          <div class="pad-btn blank"></div>
          <button class="pad-btn" id="mv-fwd" title="Move forward">W ‚Üë</button>
          <div class="pad-btn blank"></div>
          <button class="pad-btn" id="mv-left" title="Strafe left">A ‚Üê</button>
          <button class="pad-btn" id="mv-back" title="Move backward">S ‚Üì</button>
          <button class="pad-btn" id="mv-right" title="Strafe right">D ‚Üí</button>
        </div>
        <div style="display:flex; gap:6px; justify-content:center;">
          <button class="pad-btn" id="mv-up" title="Move up" style="width:66px;font-size:10px;">‚Üë UP</button>
          <button class="pad-btn" id="mv-down" title="Move down" style="width:66px;font-size:10px;">‚Üì DOWN</button>
        </div>
      </div>
    </div>

    <!-- Look -->
    <div class="section">
      <div class="section-head">Camera Look</div>
      <div class="section-body">
        <div id="look-pad">
          <div class="pad-btn blank"></div>
          <button class="pad-btn" id="lk-up" title="Look up">‚Üë</button>
          <div class="pad-btn blank"></div>
          <button class="pad-btn" id="lk-left" title="Look left">‚Üê</button>
          <button class="pad-btn" id="lk-down" title="Look down">‚Üì</button>
          <button class="pad-btn" id="lk-right" title="Look right">‚Üí</button>
        </div>
      </div>
    </div>

    <!-- Arm -->
    <div class="section">
      <div class="section-head">Arm & Gripper</div>
      <div class="section-body">
        <div class="ctrl-row">
          <label>Arm Pitch <b id="v-pitch">0¬∞</b></label>
          <input type="range" id="sl-pitch" min="-60" max="60" value="0" title="Arm vertical angle">
        </div>
        <div class="ctrl-row">
          <label>Arm Reach <b id="v-reach">50%</b></label>
          <input type="range" id="sl-reach" min="0" max="100" value="50" title="Arm extension">
        </div>
        <div class="ctrl-row">
          <label>Gripper <b id="v-grip">Open</b></label>
          <input type="range" id="sl-grip" min="0" max="100" value="0" title="Gripper aperture">
        </div>
        <div class="btn-grid">
          <button class="act-btn primary" id="btn-grab" title="Grab nearest object">‚úä GRAB</button>
          <button class="act-btn" id="btn-release" title="Release held object">‚úã DROP</button>
        </div>
      </div>
    </div>

    <!-- Actions -->
    <div class="section">
      <div class="section-head">Actions</div>
      <div class="section-body">
        <div class="btn-grid">
          <button class="act-btn" id="btn-approach" title="Auto-approach nearest object">‚ö° APPROACH</button>
          <button class="act-btn" id="btn-scan" title="Scan environment">‚óé SCAN</button>
        </div>
        <button class="act-btn warn" id="btn-reset" title="Reset simulation">‚Üª RESET SCENE</button>
      </div>
    </div>

    <!-- Tasks -->
    <div class="section-head">Missions</div>
    <div id="task-area"></div>
  </div>

  <!-- BOTTOM COMMAND BAR -->
  <div id="bottom">
    <span style="font-size:10px;color:var(--text-dim);">CMD:</span>
    <input type="text" id="cmd" placeholder="forward(n) | left(n) | grab() | drop() | approach() | goto(x,z) | look(yaw,pitch) | scan() | reset()">
    <button class="act-btn primary" id="btn-cmd" style="padding:4px 14px;font-size:10px;">RUN</button>
    <span id="log-line">Ready</span>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ROBOVIEW ‚Äî First-Person Robot Simulation
//  Architecture: viewport is swappable with real camera
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ‚îÄ THREE.JS SETUP ‚îÄ‚îÄ‚îÄ
const vp = document.getElementById('viewport');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
vp.insertBefore(renderer.domElement, vp.firstChild);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0e14);
scene.fog = new THREE.Fog(0x0a0e14, 15, 40);

const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 100);

function resizeRenderer() {
  const w = vp.clientWidth, h = vp.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
resizeRenderer();
window.addEventListener('resize', resizeRenderer);

// ‚îÄ‚îÄ‚îÄ LIGHTING ‚îÄ‚îÄ‚îÄ
const ambient = new THREE.AmbientLight(0x2a3040, 0.6);
scene.add(ambient);

const dirLight = new THREE.DirectionalLight(0xffeedd, 0.8);
dirLight.position.set(5, 12, 5);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(1024, 1024);
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 30;
dirLight.shadow.camera.left = -10;
dirLight.shadow.camera.right = 10;
dirLight.shadow.camera.top = 10;
dirLight.shadow.camera.bottom = -10;
scene.add(dirLight);

const fillLight = new THREE.PointLight(0x4488ff, 0.3, 20);
fillLight.position.set(-4, 5, -3);
scene.add(fillLight);

// ‚îÄ‚îÄ‚îÄ GROUND ‚îÄ‚îÄ‚îÄ
const groundGeo = new THREE.PlaneGeometry(40, 40);
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x1a1e28,
  roughness: 0.9,
  metalness: 0.1
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// Grid overlay
const gridHelper = new THREE.GridHelper(40, 40, 0x222838, 0x181c26);
scene.add(gridHelper);

// ‚îÄ‚îÄ‚îÄ WALLS / ENVIRONMENT ‚îÄ‚îÄ‚îÄ
function makeWall(w, h, d, x, y, z, color) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.85, metalness: 0.05 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);
  return mesh;
}

// Room walls
makeWall(20, 3, 0.2, 0, 1.5, -10, 0x1c2232);
makeWall(20, 3, 0.2, 0, 1.5, 10, 0x1c2232);
makeWall(0.2, 3, 20, -10, 1.5, 0, 0x1a2030);
makeWall(0.2, 3, 20, 10, 1.5, 0, 0x1a2030);

// Table
const tableTop = makeWall(3, 0.1, 1.5, 0, 0.8, -3, 0x3a3020);
const tableLeg1 = makeWall(0.08, 0.8, 0.08, -1.4, 0.4, -3.65, 0x2a2018);
const tableLeg2 = makeWall(0.08, 0.8, 0.08, 1.4, 0.4, -3.65, 0x2a2018);
const tableLeg3 = makeWall(0.08, 0.8, 0.08, -1.4, 0.4, -2.35, 0x2a2018);
const tableLeg4 = makeWall(0.08, 0.8, 0.08, 1.4, 0.4, -2.35, 0x2a2018);

// Shelf
makeWall(2.5, 0.08, 0.4, -3, 1.2, -9.7, 0x2a2a38);

// ‚îÄ‚îÄ‚îÄ SCENE OBJECTS (pickable) ‚îÄ‚îÄ‚îÄ
const objects = [];

function spawnObject(name, shape, color, x, y, z, size = 0.25) {
  let geo;
  if (shape === 'box') geo = new THREE.BoxGeometry(size, size, size);
  else if (shape === 'sphere') geo = new THREE.SphereGeometry(size / 2, 16, 16);
  else if (shape === 'cylinder') geo = new THREE.CylinderGeometry(size / 2, size / 2, size, 16);
  else if (shape === 'cone') geo = new THREE.ConeGeometry(size / 2, size, 16);

  const mat = new THREE.MeshStandardMaterial({
    color,
    roughness: 0.4,
    metalness: 0.3,
    emissive: color,
    emissiveIntensity: 0.05
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);

  const obj = { name, mesh, shape, color, origPos: new THREE.Vector3(x, y, z), size };
  objects.push(obj);
  return obj;
}

// Drop zones
function makeZone(name, x, z, color) {
  const geo = new THREE.RingGeometry(0.3, 0.5, 32);
  const mat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, transparent: true, opacity: 0.4 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.position.set(x, 0.02, z);
  scene.add(mesh);

  // Label post
  const postGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8);
  const postMat = new THREE.MeshBasicMaterial({ color });
  const post = new THREE.Mesh(postGeo, postMat);
  post.position.set(x + 0.55, 0.3, z);
  scene.add(post);

  return { name, x, z, color, mesh };
}

let zones = [];

function initSceneObjects() {
  // Clear existing
  objects.forEach(o => scene.remove(o.mesh));
  objects.length = 0;
  zones.forEach(z => { scene.remove(z.mesh); });
  zones = [];

  // Objects on table
  spawnObject('Red Cube', 'box', 0xff4444, -0.6, 0.98, -3, 0.25);
  spawnObject('Teal Sphere', 'sphere', 0x44ddbb, 0.3, 0.98, -3, 0.28);
  spawnObject('Gold Cylinder', 'cylinder', 0xffba08, 0.9, 0.98, -2.8, 0.22);

  // Objects on floor
  spawnObject('Blue Cone', 'cone', 0x4488ff, 3, 0.15, -1, 0.3);
  spawnObject('Pink Cube', 'box', 0xff66aa, -4, 0.15, 2, 0.3);

  // Drop zones
  zones.push(makeZone('Zone A', 4, -6, 0xff00ff));
  zones.push(makeZone('Zone B', -4, -6, 0x44aaff));
}

// ‚îÄ‚îÄ‚îÄ ROBOT STATE ‚îÄ‚îÄ‚îÄ
const robot = {
  x: 0, y: 0.9, z: 3,    // position (y = camera height)
  yaw: 0, pitch: 0,        // look direction (radians)
  armPitch: 0,              // arm vertical angle
  armReach: 0.5,            // 0-1
  gripperOpen: 0,           // 0-100
  heldObject: null,
  moveSpeed: 0.15,
  lookSpeed: 0.04,
};

function updateCamera() {
  camera.position.set(robot.x, robot.y, robot.z);
  camera.rotation.order = 'YXZ';
  camera.rotation.y = robot.yaw;
  camera.rotation.x = robot.pitch;
}

// ‚îÄ‚îÄ‚îÄ ROBOT ARM (visible from first person) ‚îÄ‚îÄ‚îÄ
const armGroup = new THREE.Group();
scene.add(armGroup);

// Upper arm
const armGeo = new THREE.BoxGeometry(0.04, 0.04, 0.5);
const armMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.3, metalness: 0.7 });
const armMesh = new THREE.Mesh(armGeo, armMat);

// Forearm
const forearmGeo = new THREE.BoxGeometry(0.03, 0.03, 0.4);
const forearmMat = new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.3, metalness: 0.7 });
const forearmMesh = new THREE.Mesh(forearmGeo, forearmMat);

// Gripper fingers
const fingerGeo = new THREE.BoxGeometry(0.015, 0.06, 0.015);
const fingerMat = new THREE.MeshStandardMaterial({ color: 0x00ddff, roughness: 0.2, metalness: 0.8, emissive: 0x00ddff, emissiveIntensity: 0.15 });
const fingerL = new THREE.Mesh(fingerGeo, fingerMat);
const fingerR = new THREE.Mesh(fingerGeo, fingerMat.clone());

// Gripper light
const gripLight = new THREE.PointLight(0x00ddff, 0.3, 3);

armGroup.add(armMesh);
armGroup.add(forearmMesh);
armGroup.add(fingerL);
armGroup.add(fingerR);
armGroup.add(gripLight);

function updateArm() {
  // Position arm relative to camera
  const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
  const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
  const up = new THREE.Vector3(0, 1, 0);

  const armBase = camera.position.clone()
    .add(right.clone().multiplyScalar(0.2))
    .add(up.clone().multiplyScalar(-0.25))
    .add(dir.clone().multiplyScalar(0.3));

  const reach = robot.armReach;
  const pitchRad = robot.armPitch * Math.PI / 180;
  const armDir = dir.clone().add(up.clone().multiplyScalar(Math.sin(pitchRad) * 0.5)).normalize();

  const armEnd = armBase.clone().add(armDir.clone().multiplyScalar(0.3 + reach * 0.4));
  const gripEnd = armEnd.clone().add(armDir.clone().multiplyScalar(0.25 + reach * 0.2));

  armMesh.position.copy(armBase.clone().add(armEnd).multiplyScalar(0.5));
  armMesh.lookAt(armEnd);

  forearmMesh.position.copy(armEnd.clone().add(gripEnd).multiplyScalar(0.5));
  forearmMesh.lookAt(gripEnd);

  const gripOpen = (1 - robot.gripperOpen / 100) * 0.06 + 0.01;
  const rVec = right.clone().multiplyScalar(gripOpen);
  fingerL.position.copy(gripEnd.clone().add(rVec));
  fingerR.position.copy(gripEnd.clone().sub(rVec));
  fingerL.lookAt(gripEnd.clone().add(rVec).add(dir));
  fingerR.lookAt(gripEnd.clone().sub(rVec).add(dir));

  gripLight.position.copy(gripEnd);

  // Update held object
  if (robot.heldObject) {
    robot.heldObject.mesh.position.copy(gripEnd);
  }

  return gripEnd;
}

// ‚îÄ‚îÄ‚îÄ NEAREST OBJECT DETECTION ‚îÄ‚îÄ‚îÄ
function getNearestObject() {
  const pos = new THREE.Vector3(robot.x, robot.y, robot.z);
  let nearest = null, minDist = Infinity;
  for (const obj of objects) {
    if (obj === robot.heldObject) continue;
    const d = pos.distanceTo(obj.mesh.position);
    if (d < minDist) { minDist = d; nearest = obj; }
  }
  return { obj: nearest, dist: minDist };
}

function getGripperPos() {
  const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
  const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
  const up = new THREE.Vector3(0, 1, 0);
  const pitchRad = robot.armPitch * Math.PI / 180;
  const armDir = dir.clone().add(up.clone().multiplyScalar(Math.sin(pitchRad) * 0.5)).normalize();
  const reach = robot.armReach;
  const base = camera.position.clone()
    .add(right.clone().multiplyScalar(0.2))
    .add(up.clone().multiplyScalar(-0.25))
    .add(dir.clone().multiplyScalar(0.3));
  return base.add(armDir.clone().multiplyScalar(0.55 + reach * 0.6));
}

// ‚îÄ‚îÄ‚îÄ ACTIONS ‚îÄ‚îÄ‚îÄ
function tryGrab() {
  if (robot.heldObject) { logMsg('Already holding ' + robot.heldObject.name, 'warn'); return; }
  const gripPos = getGripperPos();
  let best = null, bestD = Infinity;
  for (const obj of objects) {
    const d = gripPos.distanceTo(obj.mesh.position);
    if (d < 0.8 && d < bestD) { bestD = d; best = obj; }
  }
  if (best) {
    robot.heldObject = best;
    robot.gripperOpen = 100;
    document.getElementById('sl-grip').value = 100;
    document.getElementById('v-grip').textContent = 'Closed';
    logMsg('Grabbed: ' + best.name, 'ok');
  } else {
    logMsg('Nothing in gripper range', 'warn');
  }
}

function tryDrop() {
  if (!robot.heldObject) { logMsg('Not holding anything', 'warn'); return; }
  const gripPos = getGripperPos();
  robot.heldObject.mesh.position.copy(gripPos);
  // Check if on ground
  if (robot.heldObject.mesh.position.y < 0.2) robot.heldObject.mesh.position.y = robot.heldObject.size / 2 + 0.01;
  logMsg('Dropped: ' + robot.heldObject.name, 'ok');
  robot.heldObject = null;
  robot.gripperOpen = 0;
  document.getElementById('sl-grip').value = 0;
  document.getElementById('v-grip').textContent = 'Open';
}

function approach() {
  const { obj, dist } = getNearestObject();
  if (!obj) { logMsg('No objects in scene', 'warn'); return; }
  const dx = obj.mesh.position.x - robot.x;
  const dz = obj.mesh.position.z - robot.z;
  const targetYaw = Math.atan2(-dx, -dz);
  const targetDist = Math.max(dist - 1.0, 0.5);
  const ratio = targetDist / dist;

  robot.yaw = targetYaw;
  robot.x += dx * (1 - ratio);
  robot.z += dz * (1 - ratio);
  logMsg('Approached ' + obj.name + ' (dist: ' + dist.toFixed(1) + 'm)', 'ok');
}

function scan() {
  let report = 'SCAN RESULT:\\n';
  objects.forEach(o => {
    const d = new THREE.Vector3(robot.x, robot.y, robot.z).distanceTo(o.mesh.position);
    const held = o === robot.heldObject ? ' [HELD]' : '';
    report += `  ${o.name}: (${o.mesh.position.x.toFixed(1)}, ${o.mesh.position.z.toFixed(1)}) dist=${d.toFixed(1)}m${held}\\n`;
  });
  zones.forEach(z => {
    report += `  ${z.name}: (${z.x.toFixed(1)}, ${z.z.toFixed(1)})\\n`;
  });
  logMsg(report, 'info');
}

// ‚îÄ‚îÄ‚îÄ MOVEMENT ‚îÄ‚îÄ‚îÄ
function moveRobot(dir) {
  const fwd = new THREE.Vector3(-Math.sin(robot.yaw), 0, -Math.cos(robot.yaw));
  const right = new THREE.Vector3(fwd.z, 0, -fwd.x);
  const s = robot.moveSpeed;
  if (dir === 'fwd') { robot.x += fwd.x * s; robot.z += fwd.z * s; }
  if (dir === 'back') { robot.x -= fwd.x * s; robot.z -= fwd.z * s; }
  if (dir === 'left') { robot.x -= right.x * s; robot.z -= right.z * s; }
  if (dir === 'right') { robot.x += right.x * s; robot.z += right.z * s; }
  if (dir === 'up') robot.y += s * 0.5;
  if (dir === 'down') robot.y = Math.max(0.3, robot.y - s * 0.5);
  // Clamp to room
  robot.x = Math.max(-9.5, Math.min(9.5, robot.x));
  robot.z = Math.max(-9.5, Math.min(9.5, robot.z));
}

function lookRobot(dir) {
  const s = robot.lookSpeed;
  if (dir === 'left') robot.yaw += s;
  if (dir === 'right') robot.yaw -= s;
  if (dir === 'up') robot.pitch = Math.min(1.2, robot.pitch + s);
  if (dir === 'down') robot.pitch = Math.max(-1.2, robot.pitch - s);
}

// ‚îÄ‚îÄ‚îÄ TASKS ‚îÄ‚îÄ‚îÄ
let tasks = [
  {
    id: 0, title: 'Approach Table', desc: 'Navigate to the table with objects',
    status: 'pending',
    check: () => {
      const tableDist = Math.hypot(robot.x - 0, robot.z - (-3));
      return tableDist < 2.0;
    }
  },
  {
    id: 1, title: 'Grab Red Cube', desc: 'Pick up the red cube from the table',
    status: 'pending',
    check: () => robot.heldObject && robot.heldObject.name === 'Red Cube'
  },
  {
    id: 2, title: 'Deliver to Zone A', desc: 'Drop red cube in the magenta zone (4, -6)',
    status: 'pending',
    check: () => {
      const cube = objects.find(o => o.name === 'Red Cube');
      if (!cube || robot.heldObject === cube) return false;
      return Math.hypot(cube.mesh.position.x - 4, cube.mesh.position.z - (-6)) < 1.0;
    }
  },
  {
    id: 3, title: 'Grab Teal Sphere', desc: 'Pick up the teal sphere',
    status: 'pending',
    check: () => robot.heldObject && robot.heldObject.name === 'Teal Sphere'
  },
  {
    id: 4, title: 'Deliver to Zone B', desc: 'Drop teal sphere in the blue zone (-4, -6)',
    status: 'pending',
    check: () => {
      const sphere = objects.find(o => o.name === 'Teal Sphere');
      if (!sphere || robot.heldObject === sphere) return false;
      return Math.hypot(sphere.mesh.position.x - (-4), sphere.mesh.position.z - (-6)) < 1.0;
    }
  },
];

function renderTasks() {
  document.getElementById('task-area').innerHTML = tasks.map(t => `
    <div class="task ${t.status}" data-id="${t.id}">
      <div class="t-title">${t.status === 'done' ? '‚úì' : t.status === 'active' ? '‚ñ∏' : '‚óã'} ${t.title}</div>
      <div class="t-desc">${t.desc}</div>
      <span class="t-badge">${t.status.toUpperCase()}</span>
    </div>
  `).join('');

  const active = tasks.find(t => t.status === 'active');
  document.getElementById('h-task').textContent = active ? `‚ñ∏ ${active.title}` : tasks.every(t => t.status === 'done') ? '‚úì ALL COMPLETE' : '‚Äî';
}

function checkTasks() {
  let foundActive = false;
  for (const t of tasks) {
    if (t.status === 'done') continue;
    if (!foundActive) {
      t.status = 'active';
      foundActive = true;
      if (t.check()) {
        t.status = 'done';
        logMsg('‚úì Task complete: ' + t.title, 'ok');
        if (tasks.every(tt => tt.status === 'done')) logMsg('üèÜ ALL MISSIONS COMPLETE', 'ok');
      }
    } else {
      t.status = 'pending';
    }
  }
  renderTasks();
}

// ‚îÄ‚îÄ‚îÄ LOGGING ‚îÄ‚îÄ‚îÄ
function logMsg(msg, type = '') {
  const el = document.getElementById('log-line');
  el.textContent = msg.split('\\n')[0];
  if (type === 'ok') el.style.color = 'var(--accent)';
  else if (type === 'warn') el.style.color = 'var(--warn)';
  else if (type === 'info') el.style.color = 'var(--info)';
  else el.style.color = 'var(--text-dim)';
  console.log(`[ROBOVIEW] ${msg}`);
}

// ‚îÄ‚îÄ‚îÄ COMMAND EXECUTION ‚îÄ‚îÄ‚îÄ
function execCmd(raw) {
  const s = raw.trim().toLowerCase();
  logMsg('> ' + raw, 'info');

  const numArg = (match) => match ? parseFloat(match[1]) : 1;

  let m;
  if (s === 'grab()' || s === 'grab') { tryGrab(); return; }
  if (s === 'drop()' || s === 'drop' || s === 'release()' || s === 'release') { tryDrop(); return; }
  if (s === 'approach()' || s === 'approach') { approach(); return; }
  if (s === 'scan()' || s === 'scan') { scan(); return; }
  if (s === 'reset()' || s === 'reset') { resetScene(); return; }

  if ((m = s.match(/forward\((\d+\.?\d*)\)/)) || s === 'forward()') {
    const n = m ? parseFloat(m[1]) : 1;
    for (let i = 0; i < n; i++) moveRobot('fwd');
    logMsg(`Moved forward ${n} steps`);
    return;
  }
  if ((m = s.match(/back(?:ward)?\((\d+\.?\d*)\)/)) || s.match(/back/)) {
    const n = m ? parseFloat(m[1]) : 1;
    for (let i = 0; i < n; i++) moveRobot('back');
    logMsg(`Moved back ${n} steps`);
    return;
  }
  if ((m = s.match(/left\((\d+\.?\d*)\)/)) || s === 'left()') {
    const n = m ? parseFloat(m[1]) : 1;
    for (let i = 0; i < n; i++) moveRobot('left');
    return;
  }
  if ((m = s.match(/right\((\d+\.?\d*)\)/)) || s === 'right()') {
    const n = m ? parseFloat(m[1]) : 1;
    for (let i = 0; i < n; i++) moveRobot('right');
    return;
  }
  if ((m = s.match(/goto\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)/))) {
    robot.x = parseFloat(m[1]);
    robot.z = parseFloat(m[2]);
    logMsg(`Teleported to (${m[1]}, ${m[2]})`);
    return;
  }
  if ((m = s.match(/look\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)/))) {
    robot.yaw = parseFloat(m[1]) * Math.PI / 180;
    robot.pitch = parseFloat(m[2]) * Math.PI / 180;
    logMsg(`Look set to yaw=${m[1]}¬∞ pitch=${m[2]}¬∞`);
    return;
  }
  if (s === 'status()' || s === 'status') {
    scan();
    return;
  }
  if (s === 'help' || s === 'help()') {
    logMsg('Commands: forward(n) back(n) left(n) right(n) goto(x,z) look(yaw,pitch) grab() drop() approach() scan() reset()');
    return;
  }
  logMsg('Unknown: ' + raw, 'warn');
}

function resetScene() {
  robot.x = 0; robot.y = 0.9; robot.z = 3;
  robot.yaw = 0; robot.pitch = 0;
  robot.armPitch = 0; robot.armReach = 0.5; robot.gripperOpen = 0;
  robot.heldObject = null;
  tasks.forEach(t => t.status = 'pending');
  initSceneObjects();
  renderTasks();
  document.getElementById('sl-pitch').value = 0;
  document.getElementById('sl-reach').value = 50;
  document.getElementById('sl-grip').value = 0;
  logMsg('Scene reset', 'info');
}

// ‚îÄ‚îÄ‚îÄ EVENT BINDINGS ‚îÄ‚îÄ‚îÄ
// Movement buttons
document.getElementById('mv-fwd').addEventListener('click', () => moveRobot('fwd'));
document.getElementById('mv-back').addEventListener('click', () => moveRobot('back'));
document.getElementById('mv-left').addEventListener('click', () => moveRobot('left'));
document.getElementById('mv-right').addEventListener('click', () => moveRobot('right'));
document.getElementById('mv-up').addEventListener('click', () => moveRobot('up'));
document.getElementById('mv-down').addEventListener('click', () => moveRobot('down'));

// Look buttons
document.getElementById('lk-up').addEventListener('click', () => lookRobot('up'));
document.getElementById('lk-down').addEventListener('click', () => lookRobot('down'));
document.getElementById('lk-left').addEventListener('click', () => lookRobot('left'));
document.getElementById('lk-right').addEventListener('click', () => lookRobot('right'));

// Action buttons
document.getElementById('btn-grab').addEventListener('click', tryGrab);
document.getElementById('btn-release').addEventListener('click', tryDrop);
document.getElementById('btn-approach').addEventListener('click', approach);
document.getElementById('btn-scan').addEventListener('click', scan);
document.getElementById('btn-reset').addEventListener('click', resetScene);

// Sliders
document.getElementById('sl-pitch').addEventListener('input', function() {
  robot.armPitch = parseFloat(this.value);
  document.getElementById('v-pitch').textContent = this.value + '¬∞';
});
document.getElementById('sl-reach').addEventListener('input', function() {
  robot.armReach = parseFloat(this.value) / 100;
  document.getElementById('v-reach').textContent = this.value + '%';
});
document.getElementById('sl-grip').addEventListener('input', function() {
  robot.gripperOpen = parseFloat(this.value);
  document.getElementById('v-grip').textContent = this.value > 50 ? 'Closed' : 'Open';
});

// Command bar
document.getElementById('cmd').addEventListener('keydown', e => {
  if (e.key === 'Enter') { execCmd(e.target.value); e.target.value = ''; }
});
document.getElementById('btn-cmd').addEventListener('click', () => {
  const input = document.getElementById('cmd');
  execCmd(input.value);
  input.value = '';
});

// Keyboard controls (when not focused on input)
document.addEventListener('keydown', e => {
  if (document.activeElement === document.getElementById('cmd')) return;
  if (e.key === 'w' || e.key === 'W') moveRobot('fwd');
  if (e.key === 's' || e.key === 'S') moveRobot('back');
  if (e.key === 'a' || e.key === 'A') moveRobot('left');
  if (e.key === 'd' || e.key === 'D') moveRobot('right');
  if (e.key === 'ArrowLeft') lookRobot('left');
  if (e.key === 'ArrowRight') lookRobot('right');
  if (e.key === 'ArrowUp') lookRobot('up');
  if (e.key === 'ArrowDown') lookRobot('down');
  if (e.key === 'e' || e.key === 'E') tryGrab();
  if (e.key === 'q' || e.key === 'Q') tryDrop();
  if (e.key === ' ') { e.preventDefault(); approach(); }
});

// ‚îÄ‚îÄ‚îÄ ANIMATE ZONES ‚îÄ‚îÄ‚îÄ
function animateZones(t) {
  zones.forEach(z => {
    z.mesh.rotation.z = t * 0.5;
    z.mesh.material.opacity = 0.25 + Math.sin(t * 2) * 0.1;
  });
}

// ‚îÄ‚îÄ‚îÄ OBJECT GLOW PULSE ‚îÄ‚îÄ‚îÄ
function animateObjects(t) {
  objects.forEach(o => {
    if (o !== robot.heldObject) {
      o.mesh.material.emissiveIntensity = 0.03 + Math.sin(t * 3 + o.mesh.position.x) * 0.02;
    }
  });
}

// ‚îÄ‚îÄ‚îÄ MAIN LOOP ‚îÄ‚îÄ‚îÄ
let frameCount = 0, fpsTime = 0;

function loop(timestamp) {
  requestAnimationFrame(loop);

  const t = timestamp / 1000;

  // FPS
  frameCount++;
  if (timestamp - fpsTime > 500) {
    document.getElementById('d-fps').textContent = Math.round(frameCount / ((timestamp - fpsTime) / 1000));
    frameCount = 0; fpsTime = timestamp;
  }

  // Update
  updateCamera();
  const gripPos = updateArm();
  animateZones(t);
  animateObjects(t);
  checkTasks();

  // HUD
  document.getElementById('d-pos').textContent = `${robot.x.toFixed(1)}, ${robot.y.toFixed(1)}, ${robot.z.toFixed(1)}`;
  document.getElementById('d-yaw').textContent = Math.round(robot.yaw * 180 / Math.PI) + '¬∞';
  document.getElementById('h-grip').textContent = robot.gripperOpen > 50 ? 'CLOSED' : 'OPEN';
  document.getElementById('h-held').textContent = robot.heldObject ? robot.heldObject.name : '‚Äî';

  const { obj: nearObj, dist: nearDist } = getNearestObject();
  document.getElementById('h-near').textContent = nearObj ? nearObj.name : '‚Äî';
  document.getElementById('h-dist').textContent = nearObj ? nearDist.toFixed(1) + 'm' : '‚Äî';

  // Depth bar (distance to nearest)
  const depthPct = nearObj ? Math.max(0, Math.min(100, (1 - nearDist / 10) * 100)) : 0;
  document.getElementById('depth-fill').style.height = depthPct + '%';
  document.getElementById('depth-fill').style.background = depthPct > 70 ? 'var(--accent)' : depthPct > 40 ? 'var(--gold)' : 'var(--info)';

  // Render
  renderer.render(scene, camera);
}

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ
initSceneObjects();
renderTasks();
updateCamera();
logMsg('RoboView initialized ‚Äî first-person robot sim ready');
requestAnimationFrame(loop);
</script>
</body>
</html>
