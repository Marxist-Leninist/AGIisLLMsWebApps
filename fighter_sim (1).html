<!DOCTYPE html>
<html>
<head>
    <title>Transformer Dogfight</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #0a0a12; 
            display: flex; 
            flex-direction: column;
            align-items: center; 
            font-family: 'Courier New', monospace;
            color: #0f0;
            overflow: hidden;
        }
        #header {
            padding: 10px;
            text-align: center;
            width: 100%;
            background: linear-gradient(180deg, #111 0%, transparent 100%);
        }
        h1 { color: #0ff; font-size: 1.4em; text-shadow: 0 0 10px #0ff; }
        #hud {
            position: absolute;
            top: 60px;
            left: 10px;
            font-size: 12px;
            z-index: 100;
        }
        #controls-help {
            position: absolute;
            top: 60px;
            right: 10px;
            font-size: 11px;
            text-align: right;
            color: #888;
        }
        #neural-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 280px;
            background: rgba(0,20,0,0.8);
            border: 1px solid #0f0;
            padding: 8px;
            font-size: 10px;
        }
        #scoreboard {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,20,0,0.8);
            border: 1px solid #0f0;
            padding: 8px;
            font-size: 11px;
        }
        canvas { 
            border: 1px solid #0f0; 
            box-shadow: 0 0 20px rgba(0,255,0,0.3);
        }
        .ally { color: #0f0; }
        .enemy { color: #f00; }
        .player { color: #0ff; }
    </style>
</head>
<body>
    <div id="header">
        <h1>‚öîÔ∏è TRANSFORMER DOGFIGHT ‚öîÔ∏è</h1>
    </div>
    <div id="hud">
        <div class="player">PLAYER: <span id="player-hp">100</span> HP</div>
        <div>Altitude: <span id="altitude">1000</span>m</div>
        <div>Speed: <span id="speed">0</span></div>
        <div>Heading: <span id="heading">0</span>¬∞</div>
        <div style="margin-top:5px">Ammo: <span id="ammo">‚àû</span></div>
    </div>
    <div id="controls-help">
        W/S: Pitch<br>
        A/D: Roll<br>
        Q/E: Yaw<br>
        SPACE: Fire<br>
        SHIFT: Boost
    </div>
    <canvas id="canvas" width="1000" height="650"></canvas>
    <div id="neural-display">
        <div style="color:#0ff;margin-bottom:5px;">‚ïê‚ïê‚ïê TRANSFORMER AI STATUS ‚ïê‚ïê‚ïê</div>
        <div id="ai-thoughts"></div>
    </div>
    <div id="scoreboard">
        <div style="color:#0ff;margin-bottom:5px;">‚ïê‚ïê SCORE ‚ïê‚ïê</div>
        <div class="ally">Allies: <span id="ally-kills">0</span></div>
        <div class="enemy">Enemies: <span id="enemy-kills">0</span></div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const FOV = 80 * Math.PI / 180;
const NEAR = 5;
const FAR = 2500;
const FOG_START = 300;
const FOG_END = 1800;

// Transformer Neural Network
class TransformerBrain {
    constructor(inputSize, hiddenSize, numHeads) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.numHeads = numHeads;
        
        this.Wq = this.initWeight(inputSize, hiddenSize);
        this.Wk = this.initWeight(inputSize, hiddenSize);
        this.Wv = this.initWeight(inputSize, hiddenSize);
        this.Wo = this.initWeight(hiddenSize, hiddenSize);
        this.W1 = this.initWeight(hiddenSize, hiddenSize * 2);
        this.W2 = this.initWeight(hiddenSize * 2, 6);
        
        this.lastAttention = [];
        this.lastOutput = [];
        this.learningRate = 0.01;
    }
    
    initWeight(rows, cols) {
        const scale = Math.sqrt(2 / (rows + cols));
        return Array(rows).fill(0).map(() => 
            Array(cols).fill(0).map(() => (Math.random() - 0.5) * scale)
        );
    }
    
    matmul(A, B) {
        const rowsA = A.length, colsA = A[0].length, colsB = B[0].length;
        const result = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));
        for (let i = 0; i < rowsA; i++)
            for (let j = 0; j < colsB; j++)
                for (let k = 0; k < colsA; k++)
                    result[i][j] += A[i][k] * B[k][j];
        return result;
    }
    
    softmax(arr) {
        const max = Math.max(...arr);
        const exp = arr.map(x => Math.exp(x - max));
        const sum = exp.reduce((a, b) => a + b, 0);
        return exp.map(x => x / sum);
    }
    
    attention(Q, K, V) {
        const d_k = K[0].length;
        const scores = [];
        for (let i = 0; i < Q.length; i++) {
            const row = [];
            for (let j = 0; j < K.length; j++) {
                let dot = 0;
                for (let k = 0; k < d_k; k++) dot += Q[i][k] * K[j][k];
                row.push(dot / Math.sqrt(d_k));
            }
            scores.push(this.softmax(row));
        }
        this.lastAttention = scores;
        
        const output = [];
        for (let i = 0; i < scores.length; i++) {
            const row = Array(V[0].length).fill(0);
            for (let j = 0; j < V.length; j++)
                for (let k = 0; k < V[0].length; k++)
                    row[k] += scores[i][j] * V[j][k];
            output.push(row);
        }
        return output;
    }
    
    forward(inputs) {
        if (inputs.length === 0) return [0, 0, 0, 0.5, 0, 0];
        
        const padded = inputs.map(inp => {
            const p = [...inp];
            while (p.length < this.inputSize) p.push(0);
            return p.slice(0, this.inputSize);
        });
        
        const Q = this.matmul(padded, this.Wq);
        const K = this.matmul(padded, this.Wk);
        const V = this.matmul(padded, this.Wv);
        const attended = this.attention(Q, K, V);
        const projected = this.matmul(attended, this.Wo);
        
        const pooled = Array(this.hiddenSize).fill(0);
        for (let i = 0; i < projected.length; i++)
            for (let j = 0; j < this.hiddenSize; j++)
                pooled[j] += projected[i][j] / projected.length;
        
        const hidden = [];
        for (let i = 0; i < this.hiddenSize * 2; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenSize; j++)
                sum += pooled[j] * this.W1[j][i];
            hidden.push(Math.max(0, sum));
        }
        
        const outputs = [];
        for (let i = 0; i < 6; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenSize * 2; j++)
                sum += hidden[j] * this.W2[j][i];
            outputs.push(Math.tanh(sum));
        }
        
        this.lastOutput = outputs;
        return outputs;
    }
    
    learn(reward) {
        const scale = this.learningRate * reward;
        const perturb = W => {
            for (let i = 0; i < W.length; i++)
                for (let j = 0; j < W[i].length; j++)
                    W[i][j] += (Math.random() - 0.5) * scale;
        };
        if (Math.abs(reward) > 0.1) {
            perturb(this.Wq); perturb(this.Wk); perturb(this.Wv); perturb(this.W2);
        }
    }
}

// Vector math
class Vec3 {
    constructor(x=0, y=0, z=0) { this.x=x; this.y=y; this.z=z; }
    add(v) { return new Vec3(this.x+v.x, this.y+v.y, this.z+v.z); }
    sub(v) { return new Vec3(this.x-v.x, this.y-v.y, this.z-v.z); }
    mul(s) { return new Vec3(this.x*s, this.y*s, this.z*s); }
    dot(v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
    cross(v) { return new Vec3(this.y*v.z-this.z*v.y, this.z*v.x-this.x*v.z, this.x*v.y-this.y*v.x); }
    len() { return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z); }
    norm() { const l=this.len(); return l>0 ? this.mul(1/l) : new Vec3(); }
    clone() { return new Vec3(this.x, this.y, this.z); }
}

class Mat4 {
    constructor() { this.m = new Float32Array(16); this.identity(); }
    identity() { this.m.fill(0); this.m[0]=this.m[5]=this.m[10]=this.m[15]=1; return this; }
    mul(b) {
        const a=this.m, c=new Mat4();
        for(let i=0;i<4;i++) for(let j=0;j<4;j++) {
            c.m[i*4+j]=0;
            for(let k=0;k<4;k++) c.m[i*4+j]+=a[i*4+k]*b.m[k*4+j];
        }
        return c;
    }
    rotX(a) { const c=Math.cos(a),s=Math.sin(a),r=new Mat4(); r.m[5]=c;r.m[6]=s;r.m[9]=-s;r.m[10]=c; return this.mul(r); }
    rotY(a) { const c=Math.cos(a),s=Math.sin(a),r=new Mat4(); r.m[0]=c;r.m[2]=-s;r.m[8]=s;r.m[10]=c; return this.mul(r); }
    rotZ(a) { const c=Math.cos(a),s=Math.sin(a),r=new Mat4(); r.m[0]=c;r.m[1]=s;r.m[4]=-s;r.m[5]=c; return this.mul(r); }
    trans(x,y,z) { const t=new Mat4(); t.m[12]=x;t.m[13]=y;t.m[14]=z; return this.mul(t); }
    xform(v) {
        const m=this.m;
        return new Vec3(m[0]*v.x+m[4]*v.y+m[8]*v.z+m[12], m[1]*v.x+m[5]*v.y+m[9]*v.z+m[13], m[2]*v.x+m[6]*v.y+m[10]*v.z+m[14]);
    }
}

// 3D plane mesh
const planeMesh = {
    verts: [
        // Fuselage
        [0, 0, 25],      // 0 nose
        [-4, 2, 8],      // 1
        [4, 2, 8],       // 2
        [-5, 3, -12],    // 3
        [5, 3, -12],     // 4
        [-3, 1, -20],    // 5 tail
        [3, 1, -20],     // 6
        [0, -2, 8],      // 7 belly
        [-4, -1, -12],   // 8
        [4, -1, -12],    // 9
        // Wings
        [-30, 0, 0],     // 10 left wingtip
        [-5, 1, 5],      // 11
        [-5, 1, -8],     // 12
        [30, 0, 0],      // 13 right wingtip
        [5, 1, 5],       // 14
        [5, 1, -8],      // 15
        // Vertical tail
        [0, 14, -18],    // 16 top
        [0, 3, -14],     // 17
        [0, 3, -20],     // 18
        // Horizontal tail
        [-12, 2, -18],   // 19 left
        [12, 2, -18],    // 20 right
        [0, 2, -15],     // 21
    ].map(v => new Vec3(v[0], v[1], v[2])),
    
    faces: [
        // Fuselage top
        { verts: [0, 1, 2], shade: 0.9 },
        { verts: [1, 3, 2], shade: 0.85 },
        { verts: [2, 3, 4], shade: 0.8 },
        { verts: [3, 5, 4], shade: 0.7 },
        { verts: [4, 5, 6], shade: 0.75 },
        // Fuselage sides
        { verts: [0, 7, 1], shade: 0.5 },
        { verts: [0, 2, 7], shade: 0.55 },
        { verts: [1, 7, 8], shade: 0.45 },
        { verts: [1, 8, 3], shade: 0.5 },
        { verts: [2, 9, 7], shade: 0.5 },
        { verts: [2, 4, 9], shade: 0.55 },
        { verts: [3, 8, 5], shade: 0.4 },
        { verts: [4, 6, 9], shade: 0.45 },
        // Fuselage bottom
        { verts: [7, 9, 8], shade: 0.3 },
        { verts: [8, 9, 5], shade: 0.25 },
        { verts: [5, 9, 6], shade: 0.3 },
        // Left wing
        { verts: [10, 11, 12], shade: 0.85 },
        { verts: [10, 12, 11], shade: 0.4 },
        // Right wing  
        { verts: [13, 15, 14], shade: 0.85 },
        { verts: [13, 14, 15], shade: 0.4 },
        // Vertical tail
        { verts: [16, 17, 18], shade: 0.7 },
        { verts: [16, 18, 17], shade: 0.6 },
        // Horizontal tail
        { verts: [19, 21, 18], shade: 0.65 },
        { verts: [20, 18, 21], shade: 0.65 },
    ]
};

class Fighter {
    constructor(x, y, z, team, isPlayer = false) {
        this.pos = new Vec3(x, y, z);
        this.vel = new Vec3();
        this.pitch = 0;
        this.roll = 0;
        this.yaw = Math.random() * Math.PI * 2;
        this.speed = 6;
        this.hp = 100;
        this.maxHp = 100;
        this.team = team;
        this.isPlayer = isPlayer;
        this.brain = isPlayer ? null : new TransformerBrain(12, 32, 4);
        this.fireCooldown = 0;
        this.alive = true;
        this.respawnTimer = 0;
        this.kills = 0;
        this.id = Math.random().toString(36).substr(2, 9);
        this.trail = [];
    }
    
    getMatrix() {
        return new Mat4().trans(this.pos.x, this.pos.y, this.pos.z).rotY(this.yaw).rotX(this.pitch).rotZ(this.roll);
    }
    
    getForward() {
        return this.getMatrix().xform(new Vec3(0, 0, 1)).sub(this.pos).norm();
    }
    
    update(fighters, bullets) {
        if (!this.alive) {
            this.respawnTimer--;
            if (this.respawnTimer <= 0) this.respawn();
            return;
        }
        
        if (this.fireCooldown > 0) this.fireCooldown--;
        if (!this.isPlayer && this.brain) this.aiUpdate(fighters, bullets);
        
        const fwd = this.getForward();
        this.vel = fwd.mul(this.speed);
        this.pos = this.pos.add(this.vel);
        
        // Clamp
        this.pos.x = Math.max(-1500, Math.min(1500, this.pos.x));
        this.pos.z = Math.max(-1500, Math.min(1500, this.pos.z));
        this.pos.y = Math.max(25, Math.min(700, this.pos.y));
        
        this.pitch *= 0.96;
        this.roll *= 0.96;
        
        // Trail
        this.trail.unshift(this.pos.clone());
        if (this.trail.length > 25) this.trail.pop();
    }
    
    aiUpdate(fighters, bullets) {
        const perc = [[0,0,0, this.vel.x,this.vel.y,this.vel.z, this.hp/this.maxHp, 0, this.pitch, this.roll, this.yaw, this.speed]];
        
        for (const o of fighters) {
            if (o.id === this.id || !o.alive) continue;
            const d = o.pos.sub(this.pos);
            perc.push([d.x/100, d.y/100, d.z/100, o.vel.x, o.vel.y, o.vel.z,
                      o.hp/o.maxHp, o.team !== this.team ? 1 : -1, d.len()/200,
                      Math.atan2(d.x, d.z) - this.yaw, o.pitch, o.speed]);
        }
        
        for (const b of bullets) {
            if (b.team === this.team) continue;
            const d = b.pos.sub(this.pos);
            if (d.len() < 250) {
                perc.push([d.x/100, d.y/100, d.z/100, b.vel.x, b.vel.y, b.vel.z, 0, -1, d.len()/200, 0, 0, 18]);
            }
        }
        
        const out = this.brain.forward(perc);
        this.pitch += out[0] * 0.045;
        this.roll += out[1] * 0.055;
        this.yaw += out[2] * 0.035;
        this.speed = 4 + (out[3] + 1) * 4;
        
        this.pitch = Math.max(-0.55, Math.min(0.55, this.pitch));
        this.roll = Math.max(-0.9, Math.min(0.9, this.roll));
        
        if (out[4] > 0.25 && this.fireCooldown <= 0) this.fire(bullets);
    }
    
    fire(bullets) {
        if (this.fireCooldown > 0) return;
        this.fireCooldown = 10;
        const fwd = this.getForward();
        bullets.push({ pos: this.pos.clone(), vel: fwd.mul(22).add(this.vel), team: this.team, owner: this, life: 120 });
    }
    
    takeDamage(amt, attacker) {
        this.hp -= amt;
        if (this.hp <= 0 && this.alive) {
            this.alive = false;
            this.respawnTimer = 200;
            if (attacker) {
                attacker.kills++;
                if (attacker.brain) attacker.brain.learn(1.0);
            }
            if (this.brain) this.brain.learn(-0.5);
        }
    }
    
    respawn() {
        this.alive = true;
        this.hp = this.maxHp;
        this.pos = new Vec3((Math.random()-0.5)*1000, 180+Math.random()*250, (Math.random()-0.5)*1000);
        this.yaw = Math.random() * Math.PI * 2;
        this.pitch = 0;
        this.roll = 0;
        this.trail = [];
    }
}

class Camera {
    constructor() { this.pos = new Vec3(); this.pitch = 0; this.yaw = 0; }
    
    follow(target) {
        const back = target.getForward().mul(-90);
        const ideal = target.pos.add(back).add(new Vec3(0, 30, 0));
        this.pos = this.pos.add(ideal.sub(this.pos).mul(0.07));
        this.yaw += (target.yaw - this.yaw) * 0.08;
        this.pitch = target.pitch * 0.25;
    }
    
    getView() {
        return new Mat4().rotX(-this.pitch).rotY(-this.yaw).trans(-this.pos.x, -this.pos.y, -this.pos.z);
    }
    
    project(p) {
        const v = this.getView().xform(p);
        if (v.z < NEAR) return null;
        const asp = canvas.width / canvas.height;
        const f = 1 / Math.tan(FOV / 2);
        return { x: (v.x * f / v.z / asp + 1) * canvas.width / 2, y: (-v.y * f / v.z + 1) * canvas.height / 2, z: v.z };
    }
}

// Game
const game = {
    player: null, fighters: [], bullets: [], keys: {}, 
    allyKills: 0, enemyKills: 0, camera: new Camera(), explosions: [], clouds: []
};

for (let i = 0; i < 50; i++) {
    game.clouds.push({
        pos: new Vec3((Math.random()-0.5)*3000, 350+Math.random()*300, (Math.random()-0.5)*3000),
        size: 80 + Math.random() * 150
    });
}

function init() {
    game.player = new Fighter(0, 200, 0, 'ally', true);
    game.fighters.push(game.player);
    for (let i = 0; i < 3; i++)
        game.fighters.push(new Fighter((Math.random()-0.5)*600, 150+Math.random()*180, (Math.random()-0.5)*600, 'ally'));
    for (let i = 0; i < 5; i++)
        game.fighters.push(new Fighter((Math.random()-0.5)*900, 150+Math.random()*180, 500+Math.random()*500, 'enemy'));
}

document.addEventListener('keydown', e => { game.keys[e.key.toLowerCase()] = true; if(e.key===' ')e.preventDefault(); });
document.addEventListener('keyup', e => { game.keys[e.key.toLowerCase()] = false; });

function handleInput() {
    const p = game.player;
    if (!p.alive) return;
    
    if (game.keys['w']) p.pitch -= 0.028;
    if (game.keys['s']) p.pitch += 0.028;
    if (game.keys['a']) { p.roll -= 0.04; p.yaw -= 0.018; }
    if (game.keys['d']) { p.roll += 0.04; p.yaw += 0.018; }
    if (game.keys['q']) p.yaw -= 0.035;
    if (game.keys['e']) p.yaw += 0.035;
    
    if (game.keys['shift']) p.speed = Math.min(14, p.speed + 0.35);
    else p.speed = Math.max(6, p.speed - 0.12);
    
    if (game.keys[' ']) p.fire(game.bullets);
    
    p.pitch = Math.max(-0.65, Math.min(0.65, p.pitch));
    p.roll = Math.max(-1.3, Math.min(1.3, p.roll));
}

function updateBullets() {
    for (let i = game.bullets.length - 1; i >= 0; i--) {
        const b = game.bullets[i];
        b.pos = b.pos.add(b.vel);
        b.life--;
        
        if (b.life <= 0 || b.pos.y < 0 || b.pos.y > 800) { game.bullets.splice(i, 1); continue; }
        
        for (const f of game.fighters) {
            if (!f.alive || f.team === b.team) continue;
            if (f.pos.sub(b.pos).len() < 28) {
                f.takeDamage(20, b.owner);
                game.explosions.push({ pos: b.pos.clone(), life: 35, size: f.alive ? 18 : 70 });
                if (!f.alive) {
                    if (b.owner.team === 'ally') game.allyKills++;
                    else game.enemyKills++;
                }
                game.bullets.splice(i, 1);
                break;
            }
        }
    }
}

function fog(depth) { return Math.max(0, Math.min(1, (depth - FOG_START) / (FOG_END - FOG_START))); }

function fogColor(c, d) {
    const f = fog(d), fc = {r:25, g:35, b:55};
    return { r: Math.floor(c.r*(1-f)+fc.r*f), g: Math.floor(c.g*(1-f)+fc.g*f), b: Math.floor(c.b*(1-f)+fc.b*f) };
}

function drawSky() {
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, '#020510');
    g.addColorStop(0.35, '#081828');
    g.addColorStop(0.65, '#102838');
    g.addColorStop(1, '#183848');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    for (let i = 0; i < 60; i++) {
        const x = (Math.sin(i*127.1)*0.5+0.5)*canvas.width;
        const y = (Math.sin(i*311.7)*0.25+0.08)*canvas.height;
        ctx.beginPath();
        ctx.arc(x, y, 0.5+Math.random(), 0, Math.PI*2);
        ctx.fill();
    }
}

function drawClouds() {
    for (const c of game.clouds) {
        const p = game.camera.project(c.pos);
        if (!p || p.z > FAR) continue;
        const sz = c.size * 350 / p.z;
        const a = Math.max(0.02, 0.12 * (1 - fog(p.z) * 0.6));
        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, sz);
        g.addColorStop(0, `rgba(160,175,195,${a})`);
        g.addColorStop(1, 'rgba(160,175,195,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(p.x, p.y, sz, 0, Math.PI*2);
        ctx.fill();
    }
}

function drawGround() {
    const ext = 2000, gs = 200;
    
    // Ground fill
    const corners = [new Vec3(-ext,0,-ext), new Vec3(ext,0,-ext), new Vec3(ext,0,ext), new Vec3(-ext,0,ext)];
    const proj = corners.map(c => game.camera.project(c)).filter(p => p);
    if (proj.length >= 3) {
        ctx.fillStyle = '#0c1812';
        ctx.beginPath();
        ctx.moveTo(proj[0].x, proj[0].y);
        for (let i = 1; i < proj.length; i++) ctx.lineTo(proj[i].x, proj[i].y);
        ctx.closePath();
        ctx.fill();
    }
    
    // Grid
    for (let x = -ext; x <= ext; x += gs) {
        const p1 = game.camera.project(new Vec3(x, 0, -ext));
        const p2 = game.camera.project(new Vec3(x, 0, ext));
        if (p1 && p2) {
            const a = Math.max(0.04, 0.35 * (1 - fog((p1.z+p2.z)/2)));
            ctx.strokeStyle = `rgba(0,100,50,${a})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
    }
    for (let z = -ext; z <= ext; z += gs) {
        const p1 = game.camera.project(new Vec3(-ext, 0, z));
        const p2 = game.camera.project(new Vec3(ext, 0, z));
        if (p1 && p2) {
            const a = Math.max(0.04, 0.35 * (1 - fog((p1.z+p2.z)/2)));
            ctx.strokeStyle = `rgba(0,100,50,${a})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
    }
}

function drawPlane(fighter) {
    if (!fighter.alive) return;
    
    const mat = fighter.getMatrix();
    const cp = game.camera.project(fighter.pos);
    if (!cp || cp.z > FAR || cp.z < NEAR) return;
    
    const depth = cp.z;
    const f = fog(depth);
    
    let base, hi, lo;
    if (fighter.isPlayer) { base={r:0,g:210,b:255}; hi={r:120,g:255,b:255}; lo={r:0,g:90,b:140}; }
    else if (fighter.team === 'ally') { base={r:0,g:210,b:60}; hi={r:120,g:255,b:120}; lo={r:0,g:90,b:30}; }
    else { base={r:230,g:50,b:35}; hi={r:255,g:160,b:110}; lo={r:110,g:20,b:10}; }
    
    base = fogColor(base, depth);
    hi = fogColor(hi, depth);
    lo = fogColor(lo, depth);
    
    // Transform and project all verts
    const projVerts = planeMesh.verts.map(v => {
        const world = mat.xform(v);
        return game.camera.project(world);
    });
    
    // Sort faces by depth
    const faceDepths = planeMesh.faces.map((face, idx) => {
        const avgZ = face.verts.reduce((sum, vi) => {
            const p = projVerts[vi];
            return sum + (p ? p.z : 9999);
        }, 0) / face.verts.length;
        return { face, idx, avgZ };
    });
    faceDepths.sort((a, b) => b.avgZ - a.avgZ);
    
    // Draw faces
    for (const { face } of faceDepths) {
        const pts = face.verts.map(vi => projVerts[vi]);
        if (pts.some(p => !p)) continue;
        
        const shade = face.shade;
        const color = {
            r: Math.floor(lo.r + (hi.r - lo.r) * shade),
            g: Math.floor(lo.g + (hi.g - lo.g) * shade),
            b: Math.floor(lo.b + (hi.b - lo.b) * shade)
        };
        
        ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
        ctx.strokeStyle = `rgba(${hi.r},${hi.g},${hi.b},${0.4*(1-f)})`;
        ctx.lineWidth = 0.5;
        
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
    
    // Engine glow
    const eng = game.camera.project(mat.xform(new Vec3(0, 1, -22)));
    if (eng) {
        const sz = Math.max(4, 18 * 180 / depth) * (fighter.speed / 6);
        const g = ctx.createRadialGradient(eng.x, eng.y, 0, eng.x, eng.y, sz);
        g.addColorStop(0, `rgba(255,220,120,${0.85*(1-f)})`);
        g.addColorStop(0.4, `rgba(255,120,40,${0.5*(1-f)})`);
        g.addColorStop(1, 'rgba(255,40,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(eng.x, eng.y, sz, 0, Math.PI*2);
        ctx.fill();
    }
    
    // Shadow
    if (fighter.pos.y < 500) {
        const shad = game.camera.project(new Vec3(fighter.pos.x, 0.5, fighter.pos.z));
        if (shad && shad.z < FAR) {
            const sz = Math.max(8, 55 * 220 / shad.z) * (1 - fighter.pos.y / 600);
            const a = Math.max(0.04, 0.35 * (1 - f) * (1 - fighter.pos.y / 500));
            ctx.fillStyle = `rgba(0,0,0,${a})`;
            ctx.beginPath();
            ctx.ellipse(shad.x, shad.y, sz * 1.8, sz * 0.35, 0, 0, Math.PI*2);
            ctx.fill();
        }
    }
    
    // HP bar
    if (!fighter.isPlayer && depth < 600) {
        const bw = 45, bh = 5;
        const by = cp.y - 38 * 180 / depth;
        ctx.fillStyle = `rgba(40,0,0,${0.85*(1-f)})`;
        ctx.fillRect(cp.x - bw/2, by, bw, bh);
        const hpCol = fighter.team === 'ally' ? '0,255,0' : '255,0,0';
        ctx.fillStyle = `rgba(${hpCol},${0.95*(1-f)})`;
        ctx.fillRect(cp.x - bw/2, by, bw * (fighter.hp / fighter.maxHp), bh);
    }
}

function drawTrail(fighter) {
    if (!fighter.alive || fighter.trail.length < 2) return;
    const col = fighter.isPlayer ? '0,255,255' : fighter.team === 'ally' ? '0,255,0' : '255,60,0';
    
    for (let i = 0; i < fighter.trail.length - 1; i++) {
        const p1 = game.camera.project(fighter.trail[i]);
        const p2 = game.camera.project(fighter.trail[i + 1]);
        if (!p1 || !p2) continue;
        const a = (1 - i / fighter.trail.length) * 0.45 * (1 - fog(p1.z));
        ctx.strokeStyle = `rgba(${col},${a})`;
        ctx.lineWidth = Math.max(1, 4 * (1 - i / fighter.trail.length));
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    }
}

function drawBullets() {
    for (const b of game.bullets) {
        const p = game.camera.project(b.pos);
        if (!p || p.z > FAR) continue;
        const sz = Math.max(2, 7 * 120 / p.z);
        const f = fog(p.z);
        const col = b.team === 'ally' ? '255,255,0' : '255,160,0';
        
        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, sz*3.5);
        g.addColorStop(0, `rgba(${col},${0.85*(1-f)})`);
        g.addColorStop(1, `rgba(${col},0)`);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(p.x, p.y, sz*3.5, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255,255,255,${1-f})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, sz, 0, Math.PI*2);
        ctx.fill();
    }
}

function drawExplosions() {
    for (let i = game.explosions.length - 1; i >= 0; i--) {
        const e = game.explosions[i];
        e.life--;
        if (e.life <= 0) { game.explosions.splice(i, 1); continue; }
        
        const p = game.camera.project(e.pos);
        if (!p) continue;
        
        const prog = 1 - e.life / 35;
        const sz = e.size * (1 + prog * 2.5) * 180 / p.z;
        const a = (1 - prog) * (1 - fog(p.z));
        
        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, sz);
        g.addColorStop(0, `rgba(255,255,210,${a})`);
        g.addColorStop(0.25, `rgba(255,180,60,${a*0.85})`);
        g.addColorStop(0.6, `rgba(255,60,0,${a*0.55})`);
        g.addColorStop(1, 'rgba(80,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(p.x, p.y, sz, 0, Math.PI*2);
        ctx.fill();
    }
}

function drawRadar() {
    const rx = canvas.width - 95, ry = 95, rr = 75;
    
    ctx.fillStyle = 'rgba(0,25,12,0.88)';
    ctx.beginPath();
    ctx.arc(rx, ry, rr, 0, Math.PI*2);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(0,255,100,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(rx, ry, rr, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(rx, ry, rr*0.5, 0, Math.PI*2);
    ctx.stroke();
    
    ctx.strokeStyle = 'rgba(0,255,100,0.25)';
    ctx.beginPath();
    ctx.moveTo(rx, ry);
    ctx.lineTo(rx, ry - rr);
    ctx.stroke();
    
    for (const f of game.fighters) {
        if (!f.alive) continue;
        const dx = f.pos.x - game.player.pos.x;
        const dz = f.pos.z - game.player.pos.z;
        const cos = Math.cos(-game.player.yaw), sin = Math.sin(-game.player.yaw);
        const rx2 = (dx * cos - dz * sin) / 22;
        const ry2 = (dx * sin + dz * cos) / 22;
        
        if (Math.abs(rx2) < rr - 6 && Math.abs(ry2) < rr - 6) {
            ctx.fillStyle = f.isPlayer ? '#0ff' : f.team === 'ally' ? '#0f0' : '#f00';
            ctx.beginPath();
            ctx.arc(rx + rx2, ry - ry2, f.isPlayer ? 5 : 4, 0, Math.PI*2);
            ctx.fill();
        }
    }
}

function updateHUD() {
    document.getElementById('player-hp').textContent = Math.max(0, Math.floor(game.player.hp));
    document.getElementById('altitude').textContent = Math.floor(game.player.pos.y);
    document.getElementById('speed').textContent = game.player.speed.toFixed(1);
    document.getElementById('heading').textContent = Math.floor((game.player.yaw * 180 / Math.PI + 360) % 360);
    document.getElementById('ally-kills').textContent = game.allyKills;
    document.getElementById('enemy-kills').textContent = game.enemyKills;
    
    let aiInfo = '';
    const enemies = game.fighters.filter(f => f.team === 'enemy' && f.alive && f.brain);
    for (let i = 0; i < Math.min(2, enemies.length); i++) {
        const e = enemies[i];
        const out = e.brain.lastOutput;
        if (out.length) {
            aiInfo += `<div style="margin-bottom:5px;">
                <span style="color:#f00;">Enemy ${i+1}:</span><br>
                Pitch: ${(out[0]*100).toFixed(0)}% | Roll: ${(out[1]*100).toFixed(0)}%<br>
                Yaw: ${(out[2]*100).toFixed(0)}% | Fire: ${out[4] > 0.25 ? 'üî•' : '‚óã'}<br>
                Attn: [${e.brain.lastAttention.length} seq]
            </div>`;
        }
    }
    document.getElementById('ai-thoughts').innerHTML = aiInfo || 'Scanning...';
}

function render() {
    drawSky();
    drawClouds();
    drawGround();
    
    // Sort by depth
    const drawList = [];
    for (const f of game.fighters) {
        if (!f.alive) continue;
        const p = game.camera.project(f.pos);
        if (p) {
            drawList.push({ type: 'trail', obj: f, z: p.z });
            drawList.push({ type: 'plane', obj: f, z: p.z });
        }
    }
    drawList.sort((a, b) => b.z - a.z);
    
    for (const item of drawList) {
        if (item.type === 'trail') drawTrail(item.obj);
        else drawPlane(item.obj);
    }
    
    drawBullets();
    drawExplosions();
    drawRadar();
    
    if (!game.player.alive) {
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f00';
        ctx.font = 'bold 56px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('DESTROYED', canvas.width/2, canvas.height/2);
        ctx.font = '24px Courier New';
        ctx.fillStyle = '#fff';
        ctx.fillText(`Respawning in ${Math.ceil(game.player.respawnTimer/60)}...`, canvas.width/2, canvas.height/2 + 50);
    }
}

function gameLoop() {
    handleInput();
    for (const f of game.fighters) f.update(game.fighters, game.bullets);
    game.camera.follow(game.player);
    updateBullets();
    updateHUD();
    render();
    requestAnimationFrame(gameLoop);
}

init();
gameLoop();
</script>
</body>
</html>
