<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Arena - AGI Team Deathmatch</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #hud { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 14px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        #health { color: #f44; }
        #ammo { color: #4af; }
        #neuralInfo { position: absolute; top: 20px; left: 20px; color: #0ff; font-size: 10px; max-width: 260px; background: rgba(0,0,0,0.85); padding: 8px; border: 1px solid #0ff; }
        .tf-col { color: #ff0; }
        .mb-col { color: #0f0; }
        .rw-col { color: #f0f; }
        #teamScores { position: absolute; top: 20px; right: 180px; color: #fff; font-size: 11px; background: rgba(0,0,0,0.85); padding: 8px; border: 1px solid #fff; }
        #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 26px; text-align: center; text-shadow: 2px 2px 8px rgba(0,0,0,0.9); pointer-events: none; display: none; }
        #startScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; }
        #startScreen h1 { font-size: 36px; margin-bottom: 8px; background: linear-gradient(90deg, #ff0, #0ff, #f0f); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #startScreen p { font-size: 12px; margin: 4px 0; color: #aaa; }
        .controls { margin-top: 12px; text-align: left; background: rgba(255,255,255,0.05); padding: 10px 16px; border-radius: 4px; font-size: 11px; }
        .btn-group { display: flex; gap: 12px; margin-top: 16px; }
        .game-btn { padding: 10px 28px; font-size: 15px; background: linear-gradient(135deg, #0aa, #066); color: #fff; border: none; cursor: pointer; font-family: inherit; }
        .game-btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        .game-btn.secondary { background: linear-gradient(135deg, #555, #333); }
        #minimap { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.7); border: 2px solid #0f0; }
        .damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%); opacity: 0; transition: opacity 0.1s; }
        #saveNotice { position: absolute; bottom: 100px; left: 20px; color: #0f0; font-size: 14px; opacity: 0; transition: opacity 0.3s; }
        #pauseMenu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; justify-content: center; align-items: center; color: #fff; }
        #pauseMenu h2 { font-size: 30px; margin-bottom: 20px; }
        #pauseMenu button { margin: 6px; padding: 10px 30px; font-size: 15px; background: #444; color: #fff; border: none; cursor: pointer; font-family: inherit; }
        #pauseMenu button:hover { background: #666; }
        .legend { display: flex; gap: 12px; margin: 10px 0; font-size: 10px; flex-wrap: wrap; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; }
        #killFeed { position: absolute; top: 180px; right: 20px; font-size: 10px; text-align: right; width: 180px; }
        .kill-entry { padding: 2px 5px; margin: 2px 0; background: rgba(0,0,0,0.6); animation: fadeOut 5s forwards; }
        @keyframes fadeOut { 0%, 80% { opacity: 1; } 100% { opacity: 0; } }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div id="health">HEALTH: 100</div>
            <div id="ammo">AMMO: 50 / 250</div>
            <div id="kills">KILLS: 0</div>
            <div id="round">ROUND: 1</div>
            <div id="fireMode">MODE: AUTO [V]</div>
        </div>
        <div id="neuralInfo"><b>⚡ AGI NEURAL NETS</b><div id="nnStatus"></div></div>
        <div id="teamScores"><b>TEAM KILLS</b><div id="teamScoreList"></div></div>
        <canvas id="minimap"></canvas>
        <div id="killFeed"></div>
        <div id="message"></div>
        <div class="damage-overlay" id="damageOverlay"></div>
        <div id="saveNotice">SAVED</div>
        
        <div id="startScreen">
            <h1>NEURAL ARENA</h1>
            <p style="color:#888;font-size:11px;margin-bottom:10px;">AGI Team Deathmatch — Three architectures battle</p>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#dd0;"></div>Transformer</div>
                <div class="legend-item"><div class="legend-color" style="background:#0d0;"></div>Mamba</div>
                <div class="legend-item"><div class="legend-color" style="background:#d0d;"></div>RWKV</div>
                <div class="legend-item"><div class="legend-color" style="background:#0ff;"></div>Your Squad</div>
            </div>
            <div class="controls">
                <p><b>WASD</b> - Move | <b>SHIFT</b> - Sprint | <b>MOUSE</b> - Look</p>
                <p><b>CLICK</b> - Shoot | <b>V</b> - Fire mode | <b>R</b> - Reload</p>
                <p><b>ESC</b> - Pause | <b>F5</b> - Save | <b>F9</b> - Load</p>
            </div>
            <p style="margin-top:10px;color:#0ff;font-size:9px;max-width:420px;text-align:center;">
                <b>Transformer:</b> Self-attention O(n²) | <b>Mamba:</b> Selective SSM O(n) | <b>RWKV:</b> Linear attention RNN O(n)<br>
                Your 3 AGI squadmates think independently - flanking, patrolling, engaging.<br>
                Health regenerates slowly. Enemy teams fight each other AND your squad.
            </p>
            <div class="btn-group">
                <button class="game-btn" id="startBtn">NEW GAME</button>
                <button class="game-btn secondary" id="loadBtn">LOAD</button>
            </div>
        </div>
        
        <div id="pauseMenu">
            <h2>PAUSED</h2>
            <button id="resumeBtn">RESUME</button>
            <button id="saveBtn">SAVE</button>
            <button id="quitBtn">QUIT</button>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    minimapCanvas.width = 150;
    minimapCanvas.height = 150;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let gameStarted = false, gameOver = false, gamePaused = false;
let roundInProgress = false, roundTransition = false;

const FIRE_MODES = ['SEMI', 'AUTO', 'BURST'];
let currentFireMode = 1, burstCount = 0, mouseDown = false;

const player = {
    x: 24, y: 24, angle: 0, pitch: 0,
    health: 100, maxHealth: 100,
    ammo: 50, maxAmmo: 50, reserveAmmo: 250,
    kills: 0, speed: 0.055, sprintSpeed: 0.095,
    isReloading: false, reloadTime: 1000,
    shootCooldown: 0, shootDelay: 65,
    regenCooldown: 0 // Time since last damage for regen
};

// 48x48 MAP
const mapWidth = 48, mapHeight = 48;
const map = generateMap();

// Wall textures (procedural)
const wallTextures = generateWallTextures();

function generateWallTextures() {
    const textures = [];
    for (let i = 0; i < 4; i++) {
        const tex = [];
        for (let y = 0; y < 64; y++) {
            tex[y] = [];
            for (let x = 0; x < 64; x++) {
                // Brick-like pattern
                const brickH = 8, brickW = 16;
                const row = Math.floor(y / brickH);
                const offset = (row % 2) * (brickW / 2);
                const bx = (x + offset) % brickW;
                const by = y % brickH;
                
                let base = 0.4 + Math.random() * 0.1;
                // Mortar lines
                if (by === 0 || bx === 0) base *= 0.6;
                // Some variation
                base += Math.sin(x * 0.5) * 0.05 + Math.cos(y * 0.3) * 0.05;
                
                tex[y][x] = Math.max(0.2, Math.min(0.9, base));
            }
        }
        textures.push(tex);
    }
    return textures;
}

function generateMap() {
    const m = Array(mapHeight).fill(0).map(() => Array(mapWidth).fill(0));
    
    for (let i = 0; i < mapWidth; i++) { m[0][i] = 1; m[mapHeight-1][i] = 1; }
    for (let i = 0; i < mapHeight; i++) { m[i][0] = 1; m[i][mapWidth-1] = 1; }
    
    const addBox = (sx, sy, w, h, hollow = false) => {
        for (let y = sy; y < sy + h && y < mapHeight-1; y++)
            for (let x = sx; x < sx + w && x < mapWidth-1; x++)
                if (!hollow || x === sx || x === sx+w-1 || y === sy || y === sy+h-1)
                    if (x > 0 && y > 0) m[y][x] = 1;
    };
    
    addBox(21, 21, 6, 6, true);
    m[24][21] = 0; m[24][26] = 0; m[21][24] = 0; m[26][24] = 0;
    
    addBox(4, 4, 5, 5, true); m[6][4] = 0; m[4][6] = 0;
    addBox(39, 4, 5, 5, true); m[6][43] = 0; m[4][41] = 0;
    addBox(4, 39, 5, 5, true); m[41][4] = 0; m[43][6] = 0;
    addBox(39, 39, 5, 5, true); m[41][43] = 0; m[43][41] = 0;
    
    addBox(21, 4, 6, 3);
    addBox(21, 41, 6, 3);
    addBox(4, 21, 3, 6);
    addBox(41, 21, 3, 6);
    
    [[14,14],[33,14],[14,33],[33,33],[10,24],[37,24],[24,10],[24,37]].forEach(([px,py]) => {
        m[py][px] = 1; m[py+1][px] = 1; m[py][px+1] = 1; m[py+1][px+1] = 1;
    });
    
    for (let x = 8; x < 16; x++) { m[11][x] = 1; m[36][x] = 1; m[11][mapWidth-1-x] = 1; m[36][mapWidth-1-x] = 1; }
    
    return m;
}

let projectiles = [];
let teamScores = { transformer: 0, mamba: 0, rwkv: 0 };
let round = 1;

class Projectile {
    constructor(x, y, angle, owner, damage, speed, team) {
        this.x = x; this.y = y; this.angle = angle;
        this.owner = owner; this.damage = damage;
        this.speed = speed; this.team = team; this.life = 80;
    }
    
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        
        if (map[Math.floor(this.y)]?.[Math.floor(this.x)] === 1) return false;
        
        if (this.team !== 'player' && this.team !== 'ally') {
            const d = Math.hypot(this.x - player.x, this.y - player.y);
            if (d < 0.4) { 
                player.health -= this.damage; 
                player.regenCooldown = 0; // Reset regen on damage
                showDamage(); 
                return false; 
            }
        }
        
        if (this.team !== 'player' && this.team !== 'ally') {
            for (let i = allies.length - 1; i >= 0; i--) {
                const a = allies[i];
                if (Math.hypot(this.x - a.x, this.y - a.y) < a.size) {
                    if (a.takeDamage(this.damage)) {
                        addKillFeed(this.owner?.brainType?.toUpperCase() || '?', 'ALLY-' + a.brainType.substr(0,2).toUpperCase());
                        allies.splice(i, 1);
                    }
                    return false;
                }
            }
        }
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if (e === this.owner) continue;
            if (this.team !== 'player' && this.team !== 'ally' && e.brainType === this.team) continue;
            
            if (Math.hypot(this.x - e.x, this.y - e.y) < e.size) {
                if (e.takeDamage(this.damage)) {
                    const killer = this.team === 'player' ? 'PLAYER' : 
                                   this.team === 'ally' ? 'ALLY-' + this.owner?.brainType?.substr(0,2).toUpperCase() :
                                   this.owner?.brainType?.toUpperCase() || '?';
                    addKillFeed(killer, e.brainType.toUpperCase());
                    if (this.team === 'player') { player.kills++; player.reserveAmmo += 10; }
                    else if (this.team === 'ally') { player.kills++; player.reserveAmmo += 5; }
                    else if (this.owner) { this.owner.kills++; teamScores[this.owner.brainType]++; }
                    e.onDeath();
                    enemies.splice(i, 1);
                }
                return false;
            }
        }
        return this.life > 0;
    }
}

function addKillFeed(killer, victim) {
    const feed = document.getElementById('killFeed');
    const e = document.createElement('div');
    e.className = 'kill-entry';
    e.innerHTML = `<span style="color:${getCol(killer)}">${killer}</span> ⚔ <span style="color:${getCol(victim)}">${victim}</span>`;
    feed.appendChild(e);
    setTimeout(() => e.remove(), 5000);
}

function getCol(n) {
    if (n && n.startsWith && n.startsWith('ALLY')) return '#0ff';
    return { PLAYER: '#0af', TRANSFORMER: '#ff0', MAMBA: '#0f0', RWKV: '#f0f' }[n] || '#fff';
}

// === TRANSFORMER ===
class TransformerBrain {
    constructor() {
        this.type = 'transformer';
        this.dim = 16;
        this.seqLen = 12;
        this.Wq = this.init(this.dim, this.dim);
        this.Wk = this.init(this.dim, this.dim);
        this.Wv = this.init(this.dim, this.dim);
        this.W1 = this.init(this.dim, this.dim * 2);
        this.W2 = this.init(this.dim * 2, this.dim);
        this.Wout = this.init(this.dim, 5); // dx, dy, shoot, aggro, flank
        this.memory = [];
        this.totalUpdates = 0;
    }
    init(r, c) { const s = Math.sqrt(2/(r+c)); return Array(r).fill(0).map(() => Array(c).fill(0).map(() => (Math.random()*2-1)*s)); }
    mv(m, v) { return m.map(row => row.reduce((s, x, i) => s + x * (v[i]||0), 0)); }
    gelu(x) { return 0.5 * x * (1 + Math.tanh(Math.sqrt(2/Math.PI) * (x + 0.044715 * x*x*x))); }
    
    encode(obs) {
        const raw = [obs.dx, obs.dy, obs.vx, obs.vy, obs.dist, obs.hp, obs.los?1:0, obs.ally,
                     obs.enemyCount||0, obs.allyNear||0, obs.threat||0, obs.amIHurt?1:0,
                     Math.sin(obs.dx*2), Math.cos(obs.dy*2), obs.dist*obs.hp, Math.atan2(obs.dy,obs.dx)/Math.PI];
        return raw.slice(0, this.dim);
    }
    
    forward(obs) {
        const x = this.encode(obs);
        this.memory.push(x);
        if (this.memory.length > this.seqLen) this.memory.shift();
        
        const Q = this.mv(this.Wq, x);
        let attnOut = Array(this.dim).fill(0);
        let totalW = 0;
        
        for (let i = 0; i < this.memory.length; i++) {
            const mem = this.memory[i];
            const K = this.mv(this.Wk, mem);
            const V = this.mv(this.Wv, mem);
            // Causal attention with position decay
            const posWeight = 1 + (i / this.memory.length) * 0.5;
            let score = 0;
            for (let j = 0; j < this.dim; j++) score += Q[j] * K[j];
            const w = Math.exp(score / Math.sqrt(this.dim)) * posWeight;
            for (let j = 0; j < this.dim; j++) attnOut[j] += w * V[j];
            totalW += w;
        }
        for (let i = 0; i < this.dim; i++) attnOut[i] /= (totalW + 1e-8);
        
        // Residual
        for (let i = 0; i < this.dim; i++) attnOut[i] += x[i] * 0.5;
        
        // FFN with GELU
        let h = this.mv(this.W1, attnOut).map(v => this.gelu(v));
        let out = this.mv(this.W2, h);
        for (let i = 0; i < this.dim; i++) out[i] += attnOut[i] * 0.5;
        
        const a = this.mv(this.Wout, out);
        return { 
            dx: Math.tanh(a[0]), 
            dy: Math.tanh(a[1]), 
            shoot: a[2] > 0.2, 
            aggro: (Math.tanh(a[3])+1)/2,
            flank: Math.tanh(a[4])
        };
    }
    
    learn(r) {
        this.totalUpdates++;
        const perturb = (m, scale) => {
            for (let i = 0; i < m.length; i++)
                for (let j = 0; j < m[i].length; j++)
                    m[i][j] = Math.max(-2, Math.min(2, m[i][j] + (Math.random()*2-1) * scale * r));
        };
        perturb(this.Wq, 0.008); perturb(this.Wk, 0.008); perturb(this.Wv, 0.008);
        perturb(this.W1, 0.005); perturb(this.W2, 0.005); perturb(this.Wout, 0.012);
    }
    
    cloneFrom(o) {
        const cp = m => m.map(r => [...r]);
        this.Wq = cp(o.Wq); this.Wk = cp(o.Wk); this.Wv = cp(o.Wv);
        this.W1 = cp(o.W1); this.W2 = cp(o.W2); this.Wout = cp(o.Wout);
        this.memory = [];
    }
    
    serialize() { return { t:'tf', Wq:this.Wq, Wk:this.Wk, Wv:this.Wv, W1:this.W1, W2:this.W2, Wout:this.Wout, u:this.totalUpdates }; }
    deserialize(d) { this.Wq=d.Wq; this.Wk=d.Wk; this.Wv=d.Wv; this.W1=d.W1; this.W2=d.W2; this.Wout=d.Wout; this.totalUpdates=d.u; this.memory=[]; }
}

// === MAMBA ===
class MambaBrain {
    constructor() {
        this.type = 'mamba';
        this.dim = 16;
        this.A = Array(this.dim).fill(0).map(() => -0.3 - Math.random()*0.4);
        this.WB = this.init(12, this.dim);
        this.WC = this.init(12, this.dim);
        this.Wd = this.init(12, this.dim);
        this.Win = this.init(12, this.dim);
        this.Wgate = this.init(12, this.dim);
        this.Wout = this.init(this.dim, 5);
        this.h = Array(this.dim).fill(0);
        this.totalUpdates = 0;
    }
    init(r, c) { const s = Math.sqrt(2/(r+c)); return Array(r).fill(0).map(() => Array(c).fill(0).map(() => (Math.random()*2-1)*s)); }
    mv(m, v) { return m[0].map((_, j) => m.reduce((s, row, i) => s + row[j] * (v[i]||0), 0)); }
    sig(x) { return 1 / (1 + Math.exp(-Math.max(-10, Math.min(10, x)))); }
    silu(x) { return x * this.sig(x); }
    
    forward(obs) {
        const x = [obs.dx, obs.dy, obs.vx, obs.vy, obs.dist, obs.hp, obs.los?1:0, obs.ally,
                   obs.enemyCount||0, obs.allyNear||0, obs.threat||0, obs.amIHurt?1:0];
        
        // Selective scan - input dependent dynamics
        const B = this.mv(this.WB, x).map(v => Math.tanh(v));
        const C = this.mv(this.WC, x).map(v => Math.tanh(v));
        const delta = this.mv(this.Wd, x).map(v => Math.abs(this.sig(v)) * 0.15);
        const u = this.mv(this.Win, x).map(v => this.silu(v));
        const gate = this.mv(this.Wgate, x).map(v => this.sig(v));
        
        // SSM recurrence with selective gating
        for (let i = 0; i < this.dim; i++) {
            const dA = Math.exp(delta[i] * this.A[i]);
            this.h[i] = dA * this.h[i] + delta[i] * B[i] * u[i];
            this.h[i] = Math.max(-5, Math.min(5, this.h[i]));
        }
        
        const y = this.h.map((hv, i) => C[i] * hv * gate[i]);
        const a = this.mv(this.Wout, y);
        
        return { 
            dx: Math.tanh(a[0]), 
            dy: Math.tanh(a[1]), 
            shoot: a[2] > 0.2, 
            aggro: (Math.tanh(a[3])+1)/2,
            flank: Math.tanh(a[4])
        };
    }
    
    learn(r) {
        this.totalUpdates++;
        for (let i = 0; i < this.A.length; i++) 
            this.A[i] = Math.max(-2, Math.min(0, this.A[i] + (Math.random()*2-1) * 0.005 * r));
        const perturb = (m, scale) => {
            for (let i = 0; i < m.length; i++)
                for (let j = 0; j < m[i].length; j++)
                    m[i][j] = Math.max(-2, Math.min(2, m[i][j] + (Math.random()*2-1) * scale * r));
        };
        perturb(this.WB, 0.008); perturb(this.WC, 0.008); perturb(this.Wd, 0.008);
        perturb(this.Win, 0.006); perturb(this.Wgate, 0.006); perturb(this.Wout, 0.012);
    }
    
    cloneFrom(o) {
        this.A = [...o.A];
        const cp = m => m.map(r => [...r]);
        this.WB = cp(o.WB); this.WC = cp(o.WC); this.Wd = cp(o.Wd);
        this.Win = cp(o.Win); this.Wgate = cp(o.Wgate); this.Wout = cp(o.Wout);
        this.h = Array(this.dim).fill(0);
    }
    
    resetState() { this.h = Array(this.dim).fill(0); }
    
    serialize() { return { t:'mb', A:this.A, WB:this.WB, WC:this.WC, Wd:this.Wd, Win:this.Win, Wgate:this.Wgate, Wout:this.Wout, u:this.totalUpdates }; }
    deserialize(d) { this.A=d.A; this.WB=d.WB; this.WC=d.WC; this.Wd=d.Wd; this.Win=d.Win; this.Wgate=d.Wgate; this.Wout=d.Wout; this.totalUpdates=d.u; this.h=Array(this.dim).fill(0); }
}

// === RWKV ===
class RWKVBrain {
    constructor() {
        this.type = 'rwkv';
        this.dim = 16;
        this.decay = Array(this.dim).fill(0).map(() => -0.3 - Math.random()*0.5);
        this.bonus = Array(this.dim).fill(0).map(() => Math.random()*0.4);
        this.Wr = this.init(12, this.dim);
        this.Wk = this.init(12, this.dim);
        this.Wv = this.init(12, this.dim);
        this.mixR = Array(12).fill(0).map(() => 0.3 + Math.random()*0.4);
        this.mixK = Array(12).fill(0).map(() => 0.3 + Math.random()*0.4);
        this.mixV = Array(12).fill(0).map(() => 0.3 + Math.random()*0.4);
        // Channel mix
        this.Wr2 = this.init(this.dim, this.dim);
        this.Wv2 = this.init(this.dim, this.dim);
        this.Wout = this.init(this.dim, 5);
        this.prevX = Array(12).fill(0);
        this.aa = Array(this.dim).fill(0);
        this.bb = Array(this.dim).fill(1);
        this.pp = Array(this.dim).fill(-1e30);
        this.totalUpdates = 0;
    }
    init(r, c) { const s = Math.sqrt(2/(r+c)); return Array(r).fill(0).map(() => Array(c).fill(0).map(() => (Math.random()*2-1)*s)); }
    mv(m, v) { return m[0].map((_, j) => m.reduce((s, row, i) => s + row[j] * (v[i]||0), 0)); }
    sig(x) { return 1 / (1 + Math.exp(-Math.max(-10, Math.min(10, x)))); }
    
    forward(obs) {
        const x = [obs.dx, obs.dy, obs.vx, obs.vy, obs.dist, obs.hp, obs.los?1:0, obs.ally,
                   obs.enemyCount||0, obs.allyNear||0, obs.threat||0, obs.amIHurt?1:0];
        
        // Time-mixing interpolation
        const xr = x.map((v, i) => v * this.mixR[i] + (this.prevX[i]||0) * (1 - this.mixR[i]));
        const xk = x.map((v, i) => v * this.mixK[i] + (this.prevX[i]||0) * (1 - this.mixK[i]));
        const xv = x.map((v, i) => v * this.mixV[i] + (this.prevX[i]||0) * (1 - this.mixV[i]));
        
        const r = this.mv(this.Wr, xr).map(v => this.sig(v));
        const k = this.mv(this.Wk, xk);
        const v = this.mv(this.Wv, xv);
        
        // WKV computation
        const wkv = Array(this.dim).fill(0);
        for (let i = 0; i < this.dim; i++) {
            const ww = this.bonus[i] + k[i];
            const p = Math.max(this.pp[i], ww);
            const e1 = Math.exp(Math.min(80, this.pp[i] - p));
            const e2 = Math.exp(Math.min(80, ww - p));
            wkv[i] = (e1 * this.aa[i] + e2 * v[i]) / (e1 * this.bb[i] + e2 + 1e-8);
            
            const ww2 = this.pp[i] + this.decay[i];
            const p2 = Math.max(ww2, k[i]);
            this.aa[i] = Math.exp(Math.min(80, ww2 - p2)) * this.aa[i] + Math.exp(Math.min(80, k[i] - p2)) * v[i];
            this.bb[i] = Math.exp(Math.min(80, ww2 - p2)) * this.bb[i] + Math.exp(Math.min(80, k[i] - p2));
            this.pp[i] = p2;
        }
        
        let out = wkv.map((w, i) => r[i] * w);
        
        // Channel mix
        const r2 = this.mv(this.Wr2, out).map(v => this.sig(v));
        const v2 = this.mv(this.Wv2, out);
        out = out.map((o, i) => o + r2[i] * v2[i] * 0.5);
        
        this.prevX = [...x];
        
        const a = this.mv(this.Wout, out);
        return { 
            dx: Math.tanh(a[0]), 
            dy: Math.tanh(a[1]), 
            shoot: a[2] > 0.2, 
            aggro: (Math.tanh(a[3])+1)/2,
            flank: Math.tanh(a[4])
        };
    }
    
    learn(r) {
        this.totalUpdates++;
        for (let i = 0; i < this.dim; i++) {
            this.decay[i] = Math.max(-2, Math.min(0, this.decay[i] + (Math.random()*2-1) * 0.004 * r));
            this.bonus[i] = Math.max(-1, Math.min(1, this.bonus[i] + (Math.random()*2-1) * 0.004 * r));
        }
        for (let i = 0; i < 12; i++) {
            this.mixR[i] = Math.max(0, Math.min(1, this.mixR[i] + (Math.random()*2-1) * 0.008 * r));
            this.mixK[i] = Math.max(0, Math.min(1, this.mixK[i] + (Math.random()*2-1) * 0.008 * r));
            this.mixV[i] = Math.max(0, Math.min(1, this.mixV[i] + (Math.random()*2-1) * 0.008 * r));
        }
        const perturb = (m, scale) => {
            for (let i = 0; i < m.length; i++)
                for (let j = 0; j < m[i].length; j++)
                    m[i][j] = Math.max(-2, Math.min(2, m[i][j] + (Math.random()*2-1) * scale * r));
        };
        perturb(this.Wr, 0.008); perturb(this.Wk, 0.008); perturb(this.Wv, 0.008);
        perturb(this.Wr2, 0.006); perturb(this.Wv2, 0.006); perturb(this.Wout, 0.012);
    }
    
    cloneFrom(o) {
        this.decay = [...o.decay]; this.bonus = [...o.bonus];
        this.mixR = [...o.mixR]; this.mixK = [...o.mixK]; this.mixV = [...o.mixV];
        const cp = m => m.map(r => [...r]);
        this.Wr = cp(o.Wr); this.Wk = cp(o.Wk); this.Wv = cp(o.Wv);
        this.Wr2 = cp(o.Wr2); this.Wv2 = cp(o.Wv2); this.Wout = cp(o.Wout);
        this.reset();
    }
    
    reset() {
        this.prevX = Array(12).fill(0);
        this.aa = Array(this.dim).fill(0);
        this.bb = Array(this.dim).fill(1);
        this.pp = Array(this.dim).fill(-1e30);
    }
    
    serialize() { return { t:'rw', decay:this.decay, bonus:this.bonus, mixR:this.mixR, mixK:this.mixK, mixV:this.mixV, Wr:this.Wr, Wk:this.Wk, Wv:this.Wv, Wr2:this.Wr2, Wv2:this.Wv2, Wout:this.Wout, u:this.totalUpdates }; }
    deserialize(d) { this.decay=d.decay; this.bonus=d.bonus; this.mixR=d.mixR; this.mixK=d.mixK; this.mixV=d.mixV; this.Wr=d.Wr; this.Wk=d.Wk; this.Wv=d.Wv; this.Wr2=d.Wr2; this.Wv2=d.Wv2; this.Wout=d.Wout; this.totalUpdates=d.u; this.reset(); }
}

const sharedBrains = {
    transformer: new TransformerBrain(),
    mamba: new MambaBrain(),
    rwkv: new RWKVBrain()
};

let enemies = [];
let allies = [];

// === ALLY (YOUR TEAMMATES WITH FULL AGI) ===
class Ally {
    constructor(x, y, type) {
        this.x = x; this.y = y;
        this.health = 100 + round * 12;
        this.maxHealth = this.health;
        this.baseSpeed = 0.04;
        this.sprintSpeed = 0.07;
        this.size = 0.38;
        this.angle = Math.random() * Math.PI * 2;
        this.brainType = type;
        this.isAlly = true;
        
        // Full AGI brain
        if (type === 'transformer') this.brain = new TransformerBrain();
        else if (type === 'mamba') this.brain = new MambaBrain();
        else this.brain = new RWKVBrain();
        
        this.shootCooldown = Math.random() * 200;
        this.shootDelay = 350;
        this.damage = 18 + round * 2;
        this.kills = 0;
        this.lastTX = 0; this.lastTY = 0;
        
        // Independent behavior
        this.mode = 'hunt'; // hunt, flank, defend, patrol
        this.modeTimer = 0;
        this.targetPos = { x: x, y: y };
        this.patrolPoint = { x: 24 + (Math.random()-0.5)*20, y: 24 + (Math.random()-0.5)*20 };
        this.isSprinting = false;
    }
    
    findTarget() {
        let best = null, bestD = Infinity;
        for (const e of enemies) {
            const d = Math.hypot(this.x - e.x, this.y - e.y);
            if (d < bestD) { bestD = d; best = { x: e.x, y: e.y, d, e }; }
        }
        return best;
    }
    
    hasLOS(tx, ty) {
        const dx = tx - this.x, dy = ty - this.y;
        const d = Math.hypot(dx, dy), steps = Math.floor(d / 0.25);
        for (let i = 1; i < steps; i++) {
            const px = this.x + dx / steps * i, py = this.y + dy / steps * i;
            if (map[Math.floor(py)]?.[Math.floor(px)] === 1) return false;
        }
        return true;
    }
    
    countNearbyEnemies(range = 10) {
        return enemies.filter(e => Math.hypot(this.x - e.x, this.y - e.y) < range).length;
    }
    
    countNearbyAllies(range = 8) {
        let count = 0;
        for (const a of allies) if (a !== this && Math.hypot(this.x - a.x, this.y - a.y) < range) count++;
        if (Math.hypot(this.x - player.x, this.y - player.y) < range) count++;
        return count;
    }
    
    update(dt) {
        this.shootCooldown = Math.max(0, this.shootCooldown - dt);
        this.modeTimer += dt;
        
        // Decide behavior mode using brain
        const t = this.findTarget();
        const distToPlayer = Math.hypot(this.x - player.x, this.y - player.y);
        const nearbyEnemies = this.countNearbyEnemies();
        const nearbyAllies = this.countNearbyAllies();
        
        const obs = {
            dx: t ? (t.x - this.x) / 25 : 0,
            dy: t ? (t.y - this.y) / 25 : 0,
            vx: t ? (t.x - this.lastTX) * 5 : 0,
            vy: t ? (t.y - this.lastTY) * 5 : 0,
            dist: t ? t.d / 25 : 1,
            hp: this.health / this.maxHealth,
            los: t ? this.hasLOS(t.x, t.y) : false,
            ally: distToPlayer / 20,
            enemyCount: nearbyEnemies / 5,
            allyNear: nearbyAllies / 3,
            threat: nearbyEnemies > 2 ? 1 : 0,
            amIHurt: this.health < this.maxHealth * 0.5
        };
        
        if (t) { this.lastTX = t.x; this.lastTY = t.y; }
        
        const action = this.brain.forward(obs);
        
        // Mode switching based on situation and NN output
        if (this.modeTimer > 2000 || !t) {
            this.modeTimer = 0;
            
            if (!t || enemies.length === 0) {
                this.mode = 'patrol';
            } else if (action.flank > 0.3 && t.d > 8) {
                this.mode = 'flank';
            } else if (this.health < this.maxHealth * 0.3) {
                this.mode = 'defend';
            } else if (nearbyAllies > 2) {
                // Too crowded, spread out
                this.mode = 'flank';
            } else {
                this.mode = 'hunt';
            }
            
            // Set target position based on mode
            if (this.mode === 'patrol') {
                this.patrolPoint = { 
                    x: 5 + Math.random() * (mapWidth - 10), 
                    y: 5 + Math.random() * (mapHeight - 10) 
                };
            } else if (this.mode === 'flank' && t) {
                // Move to side of target
                const perpAngle = Math.atan2(t.y - this.y, t.x - this.x) + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
                this.targetPos = {
                    x: t.x + Math.cos(perpAngle) * 8,
                    y: t.y + Math.sin(perpAngle) * 8
                };
            }
        }
        
        // Determine goal position
        let goalX, goalY;
        if (this.mode === 'hunt' && t) {
            goalX = t.x; goalY = t.y;
        } else if (this.mode === 'flank') {
            goalX = this.targetPos.x; goalY = this.targetPos.y;
        } else if (this.mode === 'defend') {
            // Stay back, move toward cover
            goalX = player.x + (this.x - player.x) * 0.3;
            goalY = player.y + (this.y - player.y) * 0.3;
        } else {
            goalX = this.patrolPoint.x; goalY = this.patrolPoint.y;
        }
        
        // Movement with NN influence
        const gdx = goalX - this.x, gdy = goalY - this.y;
        const gd = Math.hypot(gdx, gdy);
        
        // Sprint when far from goal or in danger
        this.isSprinting = gd > 10 || (nearbyEnemies > 0 && this.health < this.maxHealth * 0.4);
        const speed = this.isSprinting ? this.sprintSpeed : this.baseSpeed;
        
        if (gd > 0.8) {
            // Mix direct path with NN suggestion
            let mx = (gdx / gd) * 0.7 + action.dx * 0.3;
            let my = (gdy / gd) * 0.7 + action.dy * 0.3;
            const md = Math.hypot(mx, my);
            if (md > 0) { mx = mx/md * speed; my = my/md * speed; }
            
            if (map[Math.floor(this.y)]?.[Math.floor(this.x + mx*2.5)] === 0) this.x += mx;
            if (map[Math.floor(this.y + my*2.5)]?.[Math.floor(this.x)] === 0) this.y += my;
        }
        
        // Face target
        if (t) this.angle = Math.atan2(t.y - this.y, t.x - this.x);
        
        // Shooting
        if (t && t.e && this.hasLOS(t.x, t.y) && t.d < 18 && this.shootCooldown <= 0) {
            const shootChance = action.shoot || t.d < 8 || action.aggro > 0.6;
            if (shootChance) {
                const ang = Math.atan2(t.y - this.y, t.x - this.x) + (Math.random() - 0.5) * 0.06;
                projectiles.push(new Projectile(
                    this.x + Math.cos(ang) * 0.4,
                    this.y + Math.sin(ang) * 0.4,
                    ang, this, this.damage, 0.5, 'ally'
                ));
                this.shootCooldown = this.shootDelay * (1.2 - action.aggro * 0.4);
            }
        }
        
        // Learning from combat
        if (Math.random() < 0.001) this.brain.learn(0.02);
    }
    
    takeDamage(amt) {
        this.health -= amt;
        this.brain.learn(-0.1);
        return this.health <= 0;
    }
}

// === ENEMY ===
class Enemy {
    constructor(x, y, type = null) {
        this.x = x; this.y = y;
        this.health = 45 + round * 7;
        this.maxHealth = this.health;
        this.baseSpeed = 0.03 + round * 0.002;
        this.sprintSpeed = 0.05 + round * 0.003;
        this.size = 0.35;
        this.angle = Math.random() * Math.PI * 2;
        this.isAlly = false;
        
        this.brainType = type || ['transformer', 'mamba', 'rwkv'][Math.floor(Math.random() * 3)];
        
        if (this.brainType === 'transformer') this.brain = new TransformerBrain();
        else if (this.brainType === 'mamba') this.brain = new MambaBrain();
        else this.brain = new RWKVBrain();
        
        if (sharedBrains[this.brainType].totalUpdates > 0) {
            this.brain.cloneFrom(sharedBrains[this.brainType]);
            this.brain.learn(Math.random() * 0.15 - 0.075);
        }
        
        this.shootCooldown = Math.random() * 400;
        this.shootDelay = 550 - round * 20;
        this.damage = 7 + round;
        this.kills = 0;
        this.dmgDealt = 0;
        this.life = 0;
        this.lastTX = 0; this.lastTY = 0;
        this.isSprinting = false;
    }
    
    findTarget() {
        let targets = [];
        
        for (const e of enemies) {
            if (e === this || e.brainType === this.brainType) continue;
            const d = Math.hypot(this.x - e.x, this.y - e.y);
            targets.push({ x: e.x, y: e.y, d, e, priority: 1 });
        }
        
        const playerDist = Math.hypot(this.x - player.x, this.y - player.y);
        targets.push({ x: player.x, y: player.y, d: playerDist, priority: 2 });
        
        for (const a of allies) {
            const d = Math.hypot(this.x - a.x, this.y - a.y);
            targets.push({ x: a.x, y: a.y, d, e: a, priority: 2 });
        }
        
        targets.sort((a, b) => a.priority !== b.priority ? a.priority - b.priority : a.d - b.d);
        
        for (const t of targets) if (t.d < 22) return t;
        return targets[0] || { x: player.x, y: player.y, d: playerDist };
    }
    
    hasLOS(tx, ty) {
        const dx = tx - this.x, dy = ty - this.y;
        const d = Math.hypot(dx, dy), steps = Math.floor(d / 0.25);
        for (let i = 1; i < steps; i++) {
            const px = this.x + dx / steps * i, py = this.y + dy / steps * i;
            if (map[Math.floor(py)]?.[Math.floor(px)] === 1) return false;
        }
        return true;
    }
    
    nearestAlly() {
        let min = 20;
        for (const e of enemies) {
            if (e !== this && e.brainType === this.brainType) {
                const d = Math.hypot(this.x - e.x, this.y - e.y);
                if (d < min) min = d;
            }
        }
        return min;
    }
    
    countNearbyEnemies(range = 12) {
        let count = 0;
        for (const e of enemies) if (e !== this && e.brainType !== this.brainType && Math.hypot(this.x - e.x, this.y - e.y) < range) count++;
        if (Math.hypot(this.x - player.x, this.y - player.y) < range) count++;
        for (const a of allies) if (Math.hypot(this.x - a.x, this.y - a.y) < range) count++;
        return count;
    }
    
    update(dt) {
        this.life += dt;
        this.shootCooldown = Math.max(0, this.shootCooldown - dt);
        
        const t = this.findTarget();
        const dx = t.x - this.x, dy = t.y - this.y;
        const vx = t.x - this.lastTX, vy = t.y - this.lastTY;
        this.lastTX = t.x; this.lastTY = t.y;
        
        const los = this.hasLOS(t.x, t.y);
        const targetingEnemyTeam = t.e && t.e.brainType && t.e.brainType !== this.brainType;
        const nearbyThreats = this.countNearbyEnemies();
        
        const obs = { 
            dx: dx/25, dy: dy/25, vx: vx*5, vy: vy*5, 
            dist: t.d/25, hp: this.health/this.maxHealth, 
            los, ally: this.nearestAlly()/15,
            enemyCount: nearbyThreats / 5,
            allyNear: 0,
            threat: nearbyThreats > 2 ? 1 : 0,
            amIHurt: this.health < this.maxHealth * 0.5
        };
        const act = this.brain.forward(obs);
        
        const aggro = targetingEnemyTeam ? Math.max(act.aggro, 0.65) : act.aggro;
        
        // Sprint when aggressive or hurt
        this.isSprinting = aggro > 0.7 || (this.health < this.maxHealth * 0.3 && t.d > 5);
        const speed = this.isSprinting ? this.sprintSpeed : this.baseSpeed;
        
        const inf = Math.min(0.55, this.brain.totalUpdates / 70);
        let mx = (dx/t.d) * (1-inf) + act.dx * inf;
        let my = (dy/t.d) * (1-inf) + act.dy * inf;
        
        // Flanking behavior
        if (act.flank > 0.4 && t.d > 5 && t.d < 15) {
            const perpAngle = Math.atan2(dy, dx) + (act.flank > 0 ? 1 : -1) * Math.PI / 3;
            mx = mx * 0.5 + Math.cos(perpAngle) * 0.5;
            my = my * 0.5 + Math.sin(perpAngle) * 0.5;
        }
        
        const md = Math.hypot(mx, my);
        if (md > 0) { mx = mx/md * speed * (0.6 + aggro * 0.6); my = my/md * speed * (0.6 + aggro * 0.6); }
        
        if (map[Math.floor(this.y)]?.[Math.floor(this.x + mx*2.5)] === 0) this.x += mx;
        if (map[Math.floor(this.y + my*2.5)]?.[Math.floor(this.x)] === 0) this.y += my;
        
        this.angle = Math.atan2(dy, dx);
        
        const shootRange = targetingEnemyTeam ? 20 : 16;
        const closeRange = targetingEnemyTeam ? 10 : 6;
        
        if (los && t.d < shootRange && this.shootCooldown <= 0 && (act.shoot || t.d < closeRange)) {
            this.shoot(t);
            this.shootCooldown = this.shootDelay * (1.1 - aggro * 0.35);
        }
        
        if (this.life % 1200 < dt) this.brain.learn(0.025);
    }
    
    shoot(t) {
        const ang = Math.atan2(t.y - this.y, t.x - this.x) + (Math.random() - 0.5) * 0.1;
        projectiles.push(new Projectile(
            this.x + Math.cos(ang) * 0.4,
            this.y + Math.sin(ang) * 0.4,
            ang, this, this.damage, 0.38, this.brainType
        ));
    }
    
    takeDamage(amt) {
        this.health -= amt;
        this.brain.learn(-0.12);
        return this.health <= 0;
    }
    
    onDeath() {
        const fit = this.kills * 35 + this.dmgDealt - (this.maxHealth - this.health) * 0.25 + this.life / 500;
        if (fit > 0) {
            sharedBrains[this.brainType].learn(fit * 0.004);
            const blend = Math.min(0.18, fit / 140);
            const bm = (s, l) => { for (let i = 0; i < s.length; i++) for (let j = 0; j < s[i].length; j++) s[i][j] = s[i][j]*(1-blend) + l[i][j]*blend; };
            bm(sharedBrains[this.brainType].Wout, this.brain.Wout);
        }
    }
}

function spawnEnemies() {
    enemies = [];
    allies = [];
    
    // Spawn 3 AGI allies spread out
    const allySpawns = [
        { x: player.x + 3, y: player.y, type: 'transformer' },
        { x: player.x - 2, y: player.y + 2.5, type: 'mamba' },
        { x: player.x - 2, y: player.y - 2.5, type: 'rwkv' }
    ];
    for (const s of allySpawns) {
        allies.push(new Ally(s.x, s.y, s.type));
    }
    
    const perTeam = 3 + round;
    const types = ['transformer', 'mamba', 'rwkv'];
    const spawns = [[6,6],[42,6],[6,42],[42,42],[24,6],[24,42],[6,24],[42,24],[15,15],[33,15],[15,33],[33,33]];
    let si = 0;
    
    for (const type of types) {
        for (let i = 0; i < perTeam; i++) {
            let x, y, att = 0;
            do {
                if (si < spawns.length) { [x, y] = spawns[si++]; x += Math.random()*3-1.5; y += Math.random()*3-1.5; }
                else { x = 4 + Math.random()*(mapWidth-8); y = 4 + Math.random()*(mapHeight-8); }
                att++;
            } while ((map[Math.floor(y)]?.[Math.floor(x)] === 1 || Math.hypot(x-player.x, y-player.y) < 10) && att < 60);
            enemies.push(new Enemy(x, y, type));
        }
    }
    roundInProgress = true;
}

// Input
const keys = {};
let mouseMovement = { x: 0, y: 0 };

document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && gameStarted && !gameOver) { togglePause(); return; }
    if (e.key === 'F5') { e.preventDefault(); saveGame(); return; }
    if (e.key === 'F9') { e.preventDefault(); loadGame(); return; }
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'r' && !player.isReloading && player.ammo < player.maxAmmo && player.reserveAmmo > 0) reload();
    if (e.key.toLowerCase() === 'v') currentFireMode = (currentFireMode + 1) % 3;
});
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
document.addEventListener('mousemove', e => { if (document.pointerLockElement === canvas) { mouseMovement.x += e.movementX; mouseMovement.y += e.movementY; } });
document.addEventListener('mousedown', e => { if (e.button === 0 && gameStarted && !gameOver && !gamePaused) { mouseDown = true; if (FIRE_MODES[currentFireMode] === 'BURST') burstCount = 3; } });
document.addEventListener('mouseup', e => { if (e.button === 0) { mouseDown = false; burstCount = 0; } });
canvas.addEventListener('click', () => { if (gameStarted && !gamePaused) canvas.requestPointerLock(); });

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('loadBtn').addEventListener('click', () => { if (loadGame()) { document.getElementById('startScreen').style.display = 'none'; gameStarted = true; canvas.requestPointerLock(); } });
document.getElementById('resumeBtn').addEventListener('click', togglePause);
document.getElementById('saveBtn').addEventListener('click', saveGame);
document.getElementById('quitBtn').addEventListener('click', () => location.reload());

function startGame() {
    document.getElementById('startScreen').style.display = 'none';
    gameStarted = true; gameOver = false;
    round = 1; player.health = 100; player.ammo = 50; player.reserveAmmo = 250; player.kills = 0;
    player.x = 24; player.y = 24; player.angle = 0; player.pitch = 0; player.regenCooldown = 0;
    teamScores = { transformer: 0, mamba: 0, rwkv: 0 };
    projectiles = [];
    canvas.requestPointerLock();
    spawnEnemies();
}

function togglePause() {
    gamePaused = !gamePaused;
    document.getElementById('pauseMenu').style.display = gamePaused ? 'flex' : 'none';
    if (!gamePaused) canvas.requestPointerLock();
    else document.exitPointerLock();
}

function saveGame() {
    const data = {
        player: { x: player.x, y: player.y, angle: player.angle, health: player.health, ammo: player.ammo, reserveAmmo: player.reserveAmmo, kills: player.kills },
        round, teamScores,
        brains: { transformer: sharedBrains.transformer.serialize(), mamba: sharedBrains.mamba.serialize(), rwkv: sharedBrains.rwkv.serialize() }
    };
    localStorage.setItem('neuralArenaSave', JSON.stringify(data));
    const n = document.getElementById('saveNotice'); n.style.opacity = '1'; setTimeout(() => n.style.opacity = '0', 1500);
}

function loadGame() {
    const s = localStorage.getItem('neuralArenaSave');
    if (!s) { alert('No save!'); return false; }
    try {
        const d = JSON.parse(s);
        Object.assign(player, d.player);
        round = d.round; teamScores = d.teamScores;
        sharedBrains.transformer.deserialize(d.brains.transformer);
        sharedBrains.mamba.deserialize(d.brains.mamba);
        sharedBrains.rwkv.deserialize(d.brains.rwkv);
        gameOver = false; projectiles = [];
        spawnEnemies();
        return true;
    } catch (e) { alert('Load failed!'); return false; }
}

function reload() {
    player.isReloading = true;
    showMessage('RELOADING...');
    setTimeout(() => {
        const need = player.maxAmmo - player.ammo;
        const got = Math.min(need, player.reserveAmmo);
        player.ammo += got; player.reserveAmmo -= got;
        player.isReloading = false;
        hideMessage();
    }, player.reloadTime);
}

let semiAutoFired = false;
function shoot() {
    if (player.shootCooldown > 0 || player.isReloading || player.ammo <= 0) return false;
    player.ammo--;
    player.shootCooldown = player.shootDelay;
    
    const ang = player.angle + (Math.random() - 0.5) * 0.025;
    projectiles.push(new Projectile(player.x + Math.cos(ang)*0.3, player.y + Math.sin(ang)*0.3, ang, null, 22, 0.55, 'player'));
    
    if (player.ammo === 0 && player.reserveAmmo > 0) reload();
    return true;
}

function showDamage() { const o = document.getElementById('damageOverlay'); o.style.opacity = '1'; setTimeout(() => o.style.opacity = '0', 100); }
function showMessage(t) { const m = document.getElementById('message'); m.textContent = t; m.style.display = 'block'; }
function hideMessage() { document.getElementById('message').style.display = 'none'; }

// === IMPROVED 3D RENDERING ===
function castRays() {
    const fov = Math.PI / 3, numRays = Math.min(canvas.width, 800);
    const rayWidth = canvas.width / numRays;
    const horizon = canvas.height / 2 + player.pitch * canvas.height;
    
    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, horizon);
    skyGrad.addColorStop(0, '#0a0a18');
    skyGrad.addColorStop(0.5, '#1a1a2e');
    skyGrad.addColorStop(1, '#2d2d44');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, canvas.width, Math.max(0, horizon));
    
    // Floor with perspective gradient
    const floorGrad = ctx.createLinearGradient(0, horizon, 0, canvas.height);
    floorGrad.addColorStop(0, '#1a1a1a');
    floorGrad.addColorStop(0.3, '#252525');
    floorGrad.addColorStop(1, '#333');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, Math.max(0, horizon), canvas.width, canvas.height - horizon);
    
    // Floor grid lines for depth
    ctx.strokeStyle = 'rgba(60,60,60,0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 20; i++) {
        const y = horizon + (i * i * 3);
        if (y < canvas.height) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
    }
    
    const zBuf = [];
    
    for (let i = 0; i < numRays; i++) {
        const ang = player.angle - fov/2 + (i/numRays) * fov;
        let rx = player.x, ry = player.y;
        let dist = 0;
        let hitX = 0, hitY = 0;
        let side = 0;
        
        const stepX = Math.cos(ang) * 0.015;
        const stepY = Math.sin(ang) * 0.015;
        
        while (dist < 28) {
            rx += stepX; ry += stepY; dist += 0.015;
            const mx = Math.floor(rx), my = Math.floor(ry);
            if (map[my]?.[mx] === 1) {
                hitX = rx - mx; hitY = ry - my;
                // Determine which side was hit
                if (hitX < 0.02) side = 0;
                else if (hitX > 0.98) side = 1;
                else if (hitY < 0.02) side = 2;
                else side = 3;
                break;
            }
        }
        
        const corrDist = dist * Math.cos(ang - player.angle);
        zBuf[i] = corrDist;
        
        const wallH = Math.min(canvas.height * 2, (canvas.height / corrDist) * 0.85);
        const wallTop = horizon - wallH / 2;
        
        // Textured wall with lighting
        const texX = (side === 0 || side === 1) ? hitY : hitX;
        const texCol = Math.floor(texX * 64) % 64;
        
        // Base colors with side shading
        const baseColors = [
            [80, 70, 90],   // West - purple tint
            [90, 80, 100],  // East - lighter purple
            [100, 85, 75],  // North - warm
            [75, 65, 70]    // South - darker
        ];
        const [br, bg, bb] = baseColors[side];
        
        // Distance fog
        const fogFactor = Math.max(0.15, 1 - corrDist / 22);
        
        // Draw wall column with vertical shading
        const sliceHeight = Math.ceil(wallH / 32);
        for (let j = 0; j < 32; j++) {
            const texY = j * 2;
            const texVal = wallTextures[side][texY]?.[texCol] || 0.5;
            
            // Vertical gradient (darker at bottom)
            const vertShade = 0.85 + (1 - j/32) * 0.15;
            
            const r = Math.floor(br * texVal * fogFactor * vertShade);
            const g = Math.floor(bg * texVal * fogFactor * vertShade);
            const b = Math.floor(bb * texVal * fogFactor * vertShade);
            
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(
                i * rayWidth, 
                wallTop + j * sliceHeight, 
                Math.ceil(rayWidth) + 1, 
                sliceHeight + 1
            );
        }
        
        // Add subtle edge highlight
        if (i > 0 && Math.abs(zBuf[i] - zBuf[i-1]) > 0.5) {
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(i * rayWidth, wallTop, 1, wallH);
        }
    }
    
    // Interpolate zBuffer for full width
    const fullZBuf = [];
    for (let i = 0; i < canvas.width; i++) {
        const idx = Math.floor(i / rayWidth);
        fullZBuf[i] = zBuf[Math.min(idx, zBuf.length - 1)];
    }
    
    return fullZBuf;
}

function renderEnemies(zBuf) {
    const horizon = canvas.height / 2 + player.pitch * canvas.height;
    
    const allUnits = [
        ...enemies.map(e => ({ unit: e, d: Math.hypot(e.x - player.x, e.y - player.y), isAlly: false })),
        ...allies.map(a => ({ unit: a, d: Math.hypot(a.x - player.x, a.y - player.y), isAlly: true }))
    ].sort((a, b) => b.d - a.d);
    
    for (const { unit: e, d, isAlly } of allUnits) {
        if (d < 0.5) continue;
        
        let ang = Math.atan2(e.y - player.y, e.x - player.x) - player.angle;
        while (ang > Math.PI) ang -= Math.PI * 2;
        while (ang < -Math.PI) ang += Math.PI * 2;
        
        if (Math.abs(ang) < Math.PI / 2.8) {
            const sx = canvas.width / 2 + (ang / (Math.PI/3)) * canvas.width;
            const size = (canvas.height / d) * 0.45;
            const fogFactor = Math.max(0.3, 1 - d / 20);
            
            if (sx >= -size && sx < canvas.width + size && d < (zBuf[Math.floor(sx)] || 999)) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(sx, horizon + size * 0.4, size * 0.4, size * 0.15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Body colors
                const cols = {
                    transformer: isAlly ? [100, 200, 220] : [220, 200, 50],
                    mamba: isAlly ? [80, 220, 200] : [50, 200, 50],
                    rwkv: isAlly ? [150, 200, 220] : [200, 80, 200]
                };
                const [cr, cg, cb] = cols[e.brainType];
                
                // 3D body with shading
                const bodyGrad = ctx.createRadialGradient(
                    sx - size * 0.2, horizon - size * 0.2, 0,
                    sx, horizon, size * 0.6
                );
                bodyGrad.addColorStop(0, `rgba(${Math.min(255,cr+60)},${Math.min(255,cg+60)},${Math.min(255,cb+60)},${fogFactor})`);
                bodyGrad.addColorStop(0.5, `rgba(${cr},${cg},${cb},${fogFactor})`);
                bodyGrad.addColorStop(1, `rgba(${Math.floor(cr*0.5)},${Math.floor(cg*0.5)},${Math.floor(cb*0.5)},${fogFactor})`);
                
                ctx.fillStyle = bodyGrad;
                
                if (e.brainType === 'mamba') {
                    ctx.beginPath(); 
                    ctx.ellipse(sx, horizon, size/2, size/2*1.15, 0, 0, Math.PI*2); 
                    ctx.fill();
                } else if (e.brainType === 'rwkv') {
                    ctx.beginPath(); 
                    ctx.moveTo(sx, horizon-size/2); 
                    ctx.lineTo(sx+size/2, horizon+size/2); 
                    ctx.lineTo(sx-size/2, horizon+size/2); 
                    ctx.closePath(); 
                    ctx.fill();
                } else {
                    ctx.fillRect(sx-size/2, horizon-size/2, size, size);
                }
                
                // Ally outline
                if (isAlly) {
                    ctx.strokeStyle = `rgba(0,255,255,${fogFactor * 0.8})`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(sx - size/2 - 4, horizon - size/2 - 4, size + 8, size + 8);
                }
                
                // Eyes with glow
                const eyeCol = isAlly ? '#0ff' : '#f44';
                ctx.shadowColor = eyeCol;
                ctx.shadowBlur = 8;
                ctx.fillStyle = eyeCol;
                ctx.fillRect(sx-size/4, horizon-size/5, size/7, size/7);
                ctx.fillRect(sx+size/10, horizon-size/5, size/7, size/7);
                ctx.shadowBlur = 0;
                
                // Gun
                ctx.fillStyle = `rgba(40,40,40,${fogFactor})`;
                const gunAngle = Math.atan2(
                    (isAlly ? player.y : e.lastTY || e.y) - e.y,
                    (isAlly ? player.x : e.lastTX || e.x) - e.x
                ) - player.angle;
                ctx.save();
                ctx.translate(sx, horizon);
                ctx.rotate(gunAngle * 0.3);
                ctx.fillRect(size * 0.2, -size * 0.08, size * 0.5, size * 0.16);
                ctx.restore();
                
                // Health bar with border
                const hbW = size, hbH = 5;
                const hbY = horizon - size/2 - 12;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(sx - hbW/2 - 1, hbY - 1, hbW + 2, hbH + 2);
                ctx.fillStyle = '#400';
                ctx.fillRect(sx - hbW/2, hbY, hbW, hbH);
                ctx.fillStyle = isAlly ? '#0ff' : `rgb(${cr},${cg},${cb})`;
                ctx.fillRect(sx - hbW/2, hbY, hbW * (e.health/e.maxHealth), hbH);
                
                // Label
                ctx.fillStyle = isAlly ? '#0ff' : '#fff';
                ctx.font = `bold ${Math.max(9, 12 - d/3)}px monospace`;
                ctx.textAlign = 'center';
                const label = (isAlly ? '♦' : '') + e.brainType.substr(0,2).toUpperCase();
                ctx.fillText(label, sx, hbY - 4);
                
                // Mode indicator for allies
                if (isAlly && e.mode) {
                    ctx.font = '8px monospace';
                    ctx.fillStyle = 'rgba(0,255,255,0.7)';
                    ctx.fillText(e.mode.toUpperCase(), sx, horizon + size/2 + 12);
                }
            }
        }
    }
}

function renderProjectiles(zBuf) {
    const horizon = canvas.height / 2 + player.pitch * canvas.height;
    for (const p of projectiles) {
        const d = Math.hypot(p.x - player.x, p.y - player.y);
        if (d < 0.3) continue;
        
        let ang = Math.atan2(p.y - player.y, p.x - player.x) - player.angle;
        while (ang > Math.PI) ang -= Math.PI * 2;
        while (ang < -Math.PI) ang += Math.PI * 2;
        
        if (Math.abs(ang) < Math.PI / 2.5) {
            const sx = canvas.width / 2 + (ang / (Math.PI/3)) * canvas.width;
            if (sx >= 0 && sx < canvas.width && d < (zBuf[Math.floor(sx)] || 999)) {
                const size = Math.max(3, 12 / d);
                const col = p.team === 'player' ? '#ff0' : p.team === 'ally' ? '#0ff' : getCol(p.team.toUpperCase());
                
                // Bullet glow
                ctx.shadowColor = col;
                ctx.shadowBlur = 10;
                ctx.fillStyle = col;
                ctx.beginPath(); 
                ctx.arc(sx, horizon, size, 0, Math.PI*2); 
                ctx.fill();
                
                // Bright core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(sx, horizon, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
        }
    }
}

function renderWeapon() {
    const moving = keys['w']||keys['s']||keys['a']||keys['d'];
    const bob = moving ? Math.sin(performance.now()/120)*5 : 0;
    const bobY = moving ? Math.abs(Math.cos(performance.now()/60))*6 : 0;
    const recoil = player.shootCooldown > 0 ? (player.shootCooldown/player.shootDelay)*15 : 0;
    const wx = canvas.width/2 + 70 + bob;
    const wy = canvas.height - 170 + player.pitch*80 + recoil + bobY;
    
    ctx.save();
    ctx.translate(wx+70, wy+55); 
    ctx.rotate(-0.1 + recoil * 0.01); 
    ctx.translate(-wx-70, -wy-55);
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.ellipse(wx + 60, wy + 95, 60, 15, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Gun with 3D shading
    const gunGrad = ctx.createLinearGradient(wx, wy, wx, wy + 50);
    gunGrad.addColorStop(0, '#2a2a2a');
    gunGrad.addColorStop(0.5, '#1a1a1a');
    gunGrad.addColorStop(1, '#0d0d0d');
    
    ctx.fillStyle = gunGrad;
    ctx.fillRect(wx, wy+8, 130, 45);
    
    // Top highlight
    ctx.fillStyle = '#333';
    ctx.fillRect(wx, wy+8, 130, 4);
    
    // Barrel
    const barrelGrad = ctx.createLinearGradient(wx+110, wy+15, wx+110, wy+40);
    barrelGrad.addColorStop(0, '#222');
    barrelGrad.addColorStop(1, '#0a0a0a');
    ctx.fillStyle = barrelGrad;
    ctx.fillRect(wx+110, wy+18, 55, 26);
    
    // Barrel hole
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(wx + 165, wy + 31, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Magazine
    ctx.fillStyle = '#151515';
    ctx.fillRect(wx+30, wy+48, 28, 45);
    ctx.fillStyle = '#222';
    ctx.fillRect(wx+30, wy+48, 28, 3);
    
    // Grip
    ctx.fillStyle = '#181818';
    ctx.fillRect(wx+65, wy+48, 32, 55);
    ctx.fillStyle = '#222';
    for (let i = 0; i < 5; i++) ctx.fillRect(wx+67, wy+55 + i*10, 28, 3);
    
    // Hand
    const skinGrad = ctx.createRadialGradient(wx+80, wy+70, 0, wx+80, wy+70, 40);
    skinGrad.addColorStop(0, '#d4a574');
    skinGrad.addColorStop(1, '#a67c52');
    ctx.fillStyle = skinGrad;
    ctx.fillRect(wx+60, wy+58, 40, 40);
    
    // Fingers
    ctx.fillStyle = '#c49664';
    for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.ellipse(wx + 65 + i*9, wy + 98, 5, 12, 0, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Forward hand
    ctx.fillStyle = skinGrad;
    ctx.fillRect(wx+105, wy+40, 35, 28);
    
    // Sights
    ctx.fillStyle = '#0f0';
    ctx.shadowColor = '#0f0';
    ctx.shadowBlur = 5;
    ctx.fillRect(wx+22, wy+3, 5, 5);
    ctx.fillRect(wx+100, wy+6, 5, 5);
    ctx.shadowBlur = 0;
    
    ctx.restore();
    
    // Muzzle flash
    if (player.shootCooldown > player.shootDelay - 35) {
        ctx.save();
        ctx.globalAlpha = 0.9;
        
        const flashGrad = ctx.createRadialGradient(wx+170, wy+31, 0, wx+170, wy+31, 40);
        flashGrad.addColorStop(0, '#fff');
        flashGrad.addColorStop(0.3, '#ff0');
        flashGrad.addColorStop(0.7, '#f80');
        flashGrad.addColorStop(1, 'transparent');
        
        ctx.fillStyle = flashGrad;
        ctx.beginPath();
        ctx.arc(wx+170, wy+31, 40, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
}

function renderCrosshair() {
    const cx = canvas.width/2, cy = canvas.height/2;
    const spread = (keys['w']||keys['s']||keys['a']||keys['d']) ? 14 : 9;
    
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx-spread, cy); ctx.lineTo(cx-4, cy);
    ctx.moveTo(cx+4, cy); ctx.lineTo(cx+spread, cy);
    ctx.moveTo(cx, cy-spread); ctx.lineTo(cx, cy-4);
    ctx.moveTo(cx, cy+4); ctx.lineTo(cx, cy+spread);
    ctx.stroke();
    
    ctx.fillStyle = '#f44';
    ctx.shadowColor = '#f44';
    ctx.shadowBlur = 5;
    ctx.beginPath(); 
    ctx.arc(cx, cy, 2, 0, Math.PI*2); 
    ctx.fill();
    ctx.shadowBlur = 0;
}

function renderMinimap() {
    minimapCtx.fillStyle = '#000'; 
    minimapCtx.fillRect(0, 0, 150, 150);
    const s = 150 / mapWidth;
    
    minimapCtx.fillStyle = '#333';
    for (let y = 0; y < mapHeight; y++) 
        for (let x = 0; x < mapWidth; x++) 
            if (map[y][x] === 1) minimapCtx.fillRect(x*s, y*s, s, s);
    
    for (const e of enemies) {
        minimapCtx.fillStyle = { transformer: '#cc0', mamba: '#0c0', rwkv: '#c0c' }[e.brainType];
        minimapCtx.beginPath(); 
        minimapCtx.arc(e.x*s, e.y*s, 2, 0, Math.PI*2); 
        minimapCtx.fill();
    }
    
    for (const a of allies) {
        minimapCtx.fillStyle = '#0ff';
        minimapCtx.beginPath();
        minimapCtx.moveTo(a.x*s, a.y*s - 3);
        minimapCtx.lineTo(a.x*s + 3, a.y*s);
        minimapCtx.lineTo(a.x*s, a.y*s + 3);
        minimapCtx.lineTo(a.x*s - 3, a.y*s);
        minimapCtx.closePath();
        minimapCtx.fill();
    }
    
    minimapCtx.fillStyle = '#0af';
    minimapCtx.beginPath(); 
    minimapCtx.arc(player.x*s, player.y*s, 3, 0, Math.PI*2); 
    minimapCtx.fill();
    minimapCtx.strokeStyle = '#0af'; 
    minimapCtx.beginPath();
    minimapCtx.moveTo(player.x*s, player.y*s);
    minimapCtx.lineTo(player.x*s + Math.cos(player.angle)*12, player.y*s + Math.sin(player.angle)*12);
    minimapCtx.stroke();
}

function updateHUD() {
    const healthPct = Math.max(0, player.health);
    const regenIndicator = player.regenCooldown > 3000 ? ' [REGEN]' : '';
    document.getElementById('health').textContent = `HEALTH: ${healthPct}${regenIndicator}`;
    document.getElementById('ammo').textContent = `AMMO: ${player.ammo} / ${player.reserveAmmo}`;
    document.getElementById('kills').textContent = `KILLS: ${player.kills} | SQUAD: ${allies.length}/3`;
    document.getElementById('round').textContent = `ROUND: ${round}`;
    document.getElementById('fireMode').textContent = `MODE: ${FIRE_MODES[currentFireMode]} [V]`;
    
    const tfE = enemies.filter(e => e.brainType === 'transformer');
    const mbE = enemies.filter(e => e.brainType === 'mamba');
    const rwE = enemies.filter(e => e.brainType === 'rwkv');
    
    document.getElementById('nnStatus').innerHTML = `
        <span class="tf-col">TF(${tfE.length})</span> u:${sharedBrains.transformer.totalUpdates}<br>
        <span class="mb-col">MB(${mbE.length})</span> u:${sharedBrains.mamba.totalUpdates}<br>
        <span class="rw-col">RW(${rwE.length})</span> u:${sharedBrains.rwkv.totalUpdates}
    `;
    
    document.getElementById('teamScoreList').innerHTML = `
        <span class="tf-col">TF: ${teamScores.transformer}</span><br>
        <span class="mb-col">MB: ${teamScores.mamba}</span><br>
        <span class="rw-col">RW: ${teamScores.rwkv}</span>
    `;
}

let lastTime = performance.now();

function gameLoop() {
    const now = performance.now();
    const dt = now - lastTime;
    lastTime = now;
    
    if (!gameStarted || gameOver || gamePaused) { requestAnimationFrame(gameLoop); return; }
    
    player.shootCooldown = Math.max(0, player.shootCooldown - dt);
    
    // Health regeneration (after 3 seconds of no damage)
    player.regenCooldown += dt;
    if (player.regenCooldown > 3000 && player.health < player.maxHealth) {
        player.health = Math.min(player.maxHealth, player.health + dt * 0.008); // ~8 HP per second
    }
    
    if (mouseDown) {
        const mode = FIRE_MODES[currentFireMode];
        if (mode === 'SEMI') { if (!semiAutoFired) { shoot(); semiAutoFired = true; } }
        else if (mode === 'AUTO') shoot();
        else if (mode === 'BURST' && burstCount > 0) { if (shoot()) burstCount--; }
    } else semiAutoFired = false;
    
    player.angle += mouseMovement.x * 0.0018;
    player.pitch = Math.max(-0.35, Math.min(0.35, player.pitch - mouseMovement.y * 0.0018));
    mouseMovement.x = 0; mouseMovement.y = 0;
    
    const spd = keys['shift'] ? player.sprintSpeed : player.speed;
    let mx = 0, my = 0;
    if (keys['w']) { mx += Math.cos(player.angle)*spd; my += Math.sin(player.angle)*spd; }
    if (keys['s']) { mx -= Math.cos(player.angle)*spd; my -= Math.sin(player.angle)*spd; }
    if (keys['a']) { mx += Math.cos(player.angle-Math.PI/2)*spd; my += Math.sin(player.angle-Math.PI/2)*spd; }
    if (keys['d']) { mx += Math.cos(player.angle+Math.PI/2)*spd; my += Math.sin(player.angle+Math.PI/2)*spd; }
    
    if (map[Math.floor(player.y)]?.[Math.floor(player.x + mx + Math.sign(mx)*0.2)] === 0) player.x += mx;
    if (map[Math.floor(player.y + my + Math.sign(my)*0.2)]?.[Math.floor(player.x)] === 0) player.y += my;
    
    for (const e of enemies) e.update(dt);
    for (const a of allies) a.update(dt);
    
    projectiles = projectiles.filter(p => p.update());
    
    if (enemies.length === 0 && roundInProgress && !roundTransition) {
        roundTransition = true; roundInProgress = false;
        round++;
        showMessage(`ROUND ${round}\nAIs evolving...`);
        setTimeout(() => { hideMessage(); spawnEnemies(); player.reserveAmmo += 70; roundTransition = false; }, 2500);
    }
    
    if (player.health <= 0) {
        gameOver = true;
        const winner = Object.entries(teamScores).sort((a,b) => b[1]-a[1])[0];
        showMessage(`GAME OVER\nYour Kills: ${player.kills} | Round: ${round}\n\nWinning AI: ${winner[0].toUpperCase()} (${winner[1]} kills)\n\nRefresh to restart`);
    }
    
    const zBuf = castRays();
    renderEnemies(zBuf);
    renderProjectiles(zBuf);
    renderWeapon();
    renderCrosshair();
    renderMinimap();
    updateHUD();
    
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
