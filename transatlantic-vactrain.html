<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>TRANSATLANTIC VACTRAIN | Tamworth ‚Üí New York | 2065</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: 'Segoe UI', Arial, sans-serif; }
    #c { width: 100vw; height: 100vh; display: block; }
    
    .hud { position: absolute; pointer-events: none; }
    
    #speed-panel {
      top: 20px; left: 20px;
      background: rgba(0,10,20,0.9);
      border: 1px solid rgba(0,150,255,0.4);
      border-radius: 8px;
      padding: 15px 20px;
    }
    #speed-panel .label { font-size: 8px; letter-spacing: 3px; color: rgba(0,180,255,0.6); }
    #speed-value { font-size: 56px; font-weight: 200; color: #fff; line-height: 1; }
    #speed-value.fast { color: #00d4ff; text-shadow: 0 0 30px rgba(0,200,255,0.5); }
    #speed-value.vfast { color: #ff9900; text-shadow: 0 0 30px rgba(255,150,0,0.5); }
    #speed-value.hyper { color: #ff00aa; text-shadow: 0 0 40px rgba(255,0,170,0.6); animation: pulse 0.5s infinite; }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.8; } }
    #speed-panel .unit { font-size: 10px; color: rgba(0,180,255,0.4); }
    #mach { font-size: 14px; color: #0af; margin-top: 5px; }
    
    #route-panel {
      top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0,10,20,0.9);
      border: 1px solid rgba(0,150,255,0.3);
      border-radius: 8px;
      padding: 12px 25px;
      text-align: center;
    }
    #route-panel h1 { font-size: 10px; letter-spacing: 4px; color: rgba(0,180,255,0.7); font-weight: 400; }
    #route-panel .location { font-size: 18px; color: #fff; margin-top: 4px; font-weight: 500; }
    #route-panel .subtitle { font-size: 9px; color: rgba(0,180,255,0.5); margin-top: 2px; }
    #route-panel .progress { font-size: 11px; color: rgba(0,180,255,0.6); margin-top: 6px; }
    #eta { color: #0f8; }
    
    #tech-panel {
      top: 20px; right: 20px;
      background: rgba(0,10,20,0.9);
      border: 1px solid rgba(0,255,150,0.3);
      border-radius: 8px;
      padding: 12px 15px;
      min-width: 180px;
    }
    #tech-panel .title { font-size: 7px; letter-spacing: 2px; color: rgba(0,255,150,0.6); margin-bottom: 6px; }
    .tech-row { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px; }
    .tech-row .lbl { color: rgba(0,200,150,0.5); }
    .tech-row .val { color: #0fa; font-family: monospace; }
    .tech-row .val.warn { color: #fa0; }
    .tech-row .val.danger { color: #f55; }
    
    #depth-panel {
      top: 180px; right: 20px;
      background: rgba(0,10,20,0.9);
      border: 1px solid rgba(100,100,255,0.3);
      border-radius: 8px;
      padding: 12px 15px;
      min-width: 160px;
    }
    #depth-panel .title { font-size: 7px; letter-spacing: 2px; color: rgba(100,150,255,0.6); margin-bottom: 6px; }
    #depth-bar { height: 100px; width: 20px; background: linear-gradient(to bottom, #4af, #048, #002); border-radius: 3px; position: relative; margin: 0 auto; }
    #depth-marker { position: absolute; left: -5px; width: 30px; height: 3px; background: #fff; border-radius: 2px; transition: top 0.3s; }
    #depth-label { text-align: center; font-size: 11px; color: #4af; margin-top: 8px; }
    
    #nn-panel {
      bottom: 20px; left: 20px;
      background: rgba(0,15,10,0.9);
      border: 1px solid rgba(0,255,100,0.4);
      border-radius: 8px;
      padding: 12px 15px;
      min-width: 320px;
    }
    #nn-panel .header { font-size: 9px; letter-spacing: 2px; color: rgba(0,255,150,0.8); margin-bottom: 8px; }
    #nn-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .nn-section { background: rgba(0,40,30,0.4); border-radius: 4px; padding: 6px; }
    .nn-section .stitle { font-size: 6px; letter-spacing: 1px; color: rgba(0,200,150,0.5); margin-bottom: 4px; }
    .nn-row { display: flex; justify-content: space-between; font-size: 9px; }
    .nn-row .lbl { color: rgba(0,180,120,0.4); }
    .nn-row .val { color: #0c8; font-family: monospace; }
    
    #controls-panel {
      bottom: 20px; right: 20px;
      background: rgba(0,10,20,0.85);
      border: 1px solid rgba(0,150,255,0.3);
      border-radius: 6px;
      padding: 10px 15px;
      font-size: 10px;
      color: rgba(0,180,255,0.6);
    }
    .key { color: #0af; }
    
    #vacuum-warning {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 2px solid #f00;
      border-radius: 10px;
      padding: 30px 50px;
      text-align: center;
      display: none;
      z-index: 100;
    }
    #vacuum-warning h2 { color: #f44; font-size: 24px; margin-bottom: 10px; }
    #vacuum-warning p { color: #faa; font-size: 14px; }
    
    #tunnel-effect {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 30%, rgba(0,20,40,0.4) 70%, rgba(0,0,0,0.8) 100%);
      opacity: 0;
    }
    
    #speed-lines {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      background: repeating-linear-gradient(90deg, transparent, transparent 49%, rgba(0,150,255,0.03) 49%, rgba(0,150,255,0.03) 51%, transparent 51%);
      opacity: 0;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="tunnel-effect"></div>
  <div id="speed-lines"></div>
  
  <div id="vacuum-warning">
    <h2>‚ö†Ô∏è VACUUM BREACH</h2>
    <p>Emergency systems engaged</p>
  </div>
  
  <div id="speed-panel" class="hud">
    <div class="label">VELOCITY</div>
    <div id="speed-value">0</div>
    <div class="unit">km/h</div>
    <div id="mach">MACH 0.00</div>
  </div>
  
  <div id="route-panel" class="hud">
    <h1>üåç TRANSATLANTIC VACTRAIN 2065 üóΩ</h1>
    <div class="location" id="location">Tamworth, UK</div>
    <div class="subtitle" id="subtitle">Departure Terminal ‚Ä¢ B77 2EZ</div>
    <div class="progress">
      <span id="dist">0</span> / 5,847 km ‚Ä¢ ETA: <span id="eta">--:--</span>
    </div>
  </div>
  
  <div id="tech-panel" class="hud">
    <div class="title">TUBE SYSTEMS</div>
    <div class="tech-row"><span class="lbl">Vacuum</span><span class="val" id="vacuum">99.97%</span></div>
    <div class="tech-row"><span class="lbl">Pressure</span><span class="val" id="pressure">0.03 kPa</span></div>
    <div class="tech-row"><span class="lbl">Tube Temp</span><span class="val" id="tube-temp">4¬∞C</span></div>
    <div class="tech-row"><span class="lbl">Mag Field</span><span class="val" id="mag-field">2.4 T</span></div>
    <div class="tech-row"><span class="lbl">Levitation</span><span class="val" id="levitation">150 mm</span></div>
    <div class="tech-row"><span class="lbl">G-Force</span><span class="val" id="gforce">0.0 g</span></div>
    <div class="tech-row"><span class="lbl">Power</span><span class="val" id="power-draw">0 MW</span></div>
  </div>
  
  <div id="depth-panel" class="hud">
    <div class="title">DEPTH / ALTITUDE</div>
    <div id="depth-bar"><div id="depth-marker"></div></div>
    <div id="depth-label">+85m (Surface)</div>
  </div>
  
  <div id="nn-panel" class="hud">
    <div class="header">üß† HARP-3 QUANTUM-HYBRID CONTROLLER</div>
    <div id="nn-grid">
      <div class="nn-section">
        <div class="stitle">RENDERING</div>
        <div class="nn-row"><span class="lbl">LOD</span><span class="val" id="nn-lod">3</span></div>
        <div class="nn-row"><span class="lbl">Range</span><span class="val" id="nn-range">800m</span></div>
        <div class="nn-row"><span class="lbl">Density</span><span class="val" id="nn-density">100%</span></div>
      </div>
      <div class="nn-section">
        <div class="stitle">SELF-OPTIM</div>
        <div class="nn-row"><span class="lbl">Mods</span><span class="val" id="nn-mods">0</span></div>
        <div class="nn-row"><span class="lbl">Hidden</span><span class="val" id="nn-hidden">24</span></div>
        <div class="nn-row"><span class="lbl">Score</span><span class="val" id="nn-score">0.00</span></div>
      </div>
      <div class="nn-section">
        <div class="stitle">TERRAIN</div>
        <div class="nn-row"><span class="lbl">Zone</span><span class="val" id="nn-zone">land</span></div>
        <div class="nn-row"><span class="lbl">Expert</span><span class="val" id="nn-expert">urban</span></div>
        <div class="nn-row"><span class="lbl">NAS</span><span class="val" id="nn-nas">explore</span></div>
      </div>
    </div>
  </div>
  
  <div id="controls-panel" class="hud">
    <span class="key">[W]</span> Thrust <span class="key">[S]</span> Brake <span class="key">[C]</span> Camera <span class="key">[V]</span> View Mode
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
// ==================== HARD SCIENCE PARAMETERS ====================
// Based on real physics and engineering extrapolation

const SCIENCE = {
  // Tube specifications
  tubeDiameter: 4.5,          // meters (fits train + clearance)
  tubeWallThickness: 0.3,     // meters (reinforced carbon composite)
  vacuumLevel: 0.0003,        // atmospheres (99.97% vacuum)
  pressurePascals: 30,        // ~0.03 kPa (near-vacuum)
  
  // Maglev specifications  
  magneticFieldStrength: 2.4, // Tesla (superconducting)
  levitationGap: 0.15,        // meters (150mm)
  superconductorTemp: 77,     // Kelvin (liquid nitrogen cooled)
  
  // Performance limits
  maxSpeed: 8000,             // km/h theoretical (no air resistance)
  cruiseSpeed: 6500,          // km/h nominal cruise
  maxAcceleration: 0.5,       // g (comfortable for passengers)
  maxDeceleration: 1.0,       // g (emergency)
  
  // Route
  totalDistance: 5847,        // km (Tamworth to NYC)
  maxDepth: -450,             // meters (mid-Atlantic)
  
  // Power
  powerPerKmh: 0.015,         // MW per km/h at cruise
  regenerativeBraking: 0.7,   // 70% energy recovery
};

// ==================== ROUTE WAYPOINTS ====================
// Real coordinates: Tamworth UK to New York USA
const WAYPOINTS = [
  { km: 0,    name: "Tamworth",           lat: 52.633, lon: -1.695,  depth: 0,    terrain: "urban",   region: "West Midlands, UK" },
  { km: 25,   name: "Birmingham",         lat: 52.486, lon: -1.890,  depth: -50,  terrain: "urban",   region: "West Midlands, UK" },
  { km: 120,  name: "Bristol",            lat: 51.454, lon: -2.587,  depth: -80,  terrain: "urban",   region: "South West England" },
  { km: 200,  name: "Atlantic Entry",     lat: 51.200, lon: -4.500,  depth: -120, terrain: "coastal", region: "Celtic Sea" },
  { km: 400,  name: "Celtic Shelf",       lat: 50.500, lon: -8.000,  depth: -200, terrain: "ocean",   region: "Atlantic Ocean" },
  { km: 1000, name: "Porcupine Bank",     lat: 52.000, lon: -14.00,  depth: -350, terrain: "ocean",   region: "Atlantic Ocean" },
  { km: 2000, name: "Mid-Atlantic Ridge", lat: 49.000, lon: -28.00,  depth: -450, terrain: "ocean",   region: "Atlantic Ocean" },
  { km: 3000, name: "Abyssal Plain",      lat: 44.000, lon: -42.00,  depth: -420, terrain: "ocean",   region: "Atlantic Ocean" },
  { km: 4000, name: "Sohm Plain",         lat: 40.500, lon: -55.00,  depth: -380, terrain: "ocean",   region: "Atlantic Ocean" },
  { km: 4800, name: "Continental Rise",   lat: 40.200, lon: -65.00,  depth: -250, terrain: "ocean",   region: "Atlantic Ocean" },
  { km: 5200, name: "Atlantic Exit",      lat: 40.400, lon: -70.00,  depth: -100, terrain: "coastal", region: "US Atlantic Coast" },
  { km: 5500, name: "Long Island",        lat: 40.650, lon: -73.20,  depth: -40,  terrain: "suburban",region: "New York State" },
  { km: 5750, name: "Queens",             lat: 40.728, lon: -73.79,  depth: -30,  terrain: "urban",   region: "New York City" },
  { km: 5847, name: "Penn Station NYC",   lat: 40.750, lon: -73.99,  depth: 0,    terrain: "urban",   region: "Manhattan, NY" },
];

function getWaypoint(km) {
  km = Math.max(0, Math.min(SCIENCE.totalDistance, km));
  for (let i = 0; i < WAYPOINTS.length - 1; i++) {
    if (km <= WAYPOINTS[i + 1].km) {
      const a = WAYPOINTS[i], b = WAYPOINTS[i + 1];
      const t = (km - a.km) / (b.km - a.km);
      return {
        name: t < 0.3 ? a.name : (t > 0.7 ? b.name : ""),
        lat: a.lat + (b.lat - a.lat) * t,
        lon: a.lon + (b.lon - a.lon) * t,
        depth: a.depth + (b.depth - a.depth) * t,
        terrain: t < 0.5 ? a.terrain : b.terrain,
        region: t < 0.5 ? a.region : b.region
      };
    }
  }
  return WAYPOINTS[WAYPOINTS.length - 1];
}

// ==================== SELF-OPTIMIZING NEURAL NETWORK ====================
class HARP3QuantumHybrid {
  constructor() {
    this.experts = ['urban', 'coastal', 'ocean', 'deep'];
    this.activeExpert = 0;
    this.hiddenSize = 24;
    this.selfMods = 0;
    this.bestScore = 0;
    this.nasPhase = 'explore';
    this.history = [];
    
    // Quantum-inspired superposition weights
    this.superposition = Array(24).fill(0).map(() => Math.random());
    
    // Expert specialization matrices
    this.expertWeights = this.experts.map(() => 
      Array(24).fill(0).map(() => (Math.random() - 0.5) * 0.5)
    );
  }
  
  // Quantum-inspired interference pattern
  quantumInterference(inputs) {
    let interference = 0;
    for (let i = 0; i < Math.min(inputs.length, this.superposition.length); i++) {
      interference += Math.sin(inputs[i] * Math.PI * this.superposition[i]);
    }
    return Math.tanh(interference / inputs.length);
  }
  
  forward(state) {
    // Expert routing based on terrain and depth
    const depth = Math.abs(state.depth);
    if (state.terrain === 'urban') this.activeExpert = 0;
    else if (state.terrain === 'coastal') this.activeExpert = 1;
    else if (depth < 300) this.activeExpert = 2;
    else this.activeExpert = 3;
    
    // Quantum interference for render decisions
    const qFactor = this.quantumInterference([state.speed / 8000, depth / 500, state.frameTime / 30]);
    
    // Performance scaling
    const perfScale = state.frameTime > 25 ? 0.6 : state.frameTime > 18 ? 0.8 : 1.0;
    const speedScale = Math.max(0.5, 1 - state.speed / 10000);
    
    return {
      renderDist: 400 + 600 * perfScale * speedScale,
      density: (0.3 + 0.7 * perfScale) * speedScale,
      lod: Math.max(1, Math.round(3 * perfScale)),
      tubeMod: 1 + qFactor * 0.3,
      lightMod: state.terrain === 'ocean' ? 0.3 : 0.8
    };
  }
  
  metaUpdate(score) {
    this.history.push(score);
    if (this.history.length > 100) this.history.shift();
    
    if (score > this.bestScore) {
      this.bestScore = score;
      this.selfMods++;
      console.log(`[HARP-3 SELF-MOD #${this.selfMods}] New best: ${score.toFixed(3)}`);
      
      // Reinforce successful superposition
      this.superposition = this.superposition.map(w => w + (Math.random() - 0.5) * 0.1);
    }
    
    // Architecture search
    if (this.history.length > 30 && Math.random() < 0.03) {
      const sizes = [16, 20, 24, 32, 48];
      const old = this.hiddenSize;
      this.hiddenSize = sizes[Math.floor(Math.random() * sizes.length)];
      if (old !== this.hiddenSize) {
        this.selfMods++;
        console.log(`[HARP-3 SELF-MOD #${this.selfMods}] Architecture: ${old} ‚Üí ${this.hiddenSize}`);
      }
    }
    
    if (this.history.length > 50 && this.nasPhase === 'explore') {
      this.nasPhase = 'exploit';
      this.selfMods++;
      console.log(`[HARP-3 SELF-MOD #${this.selfMods}] NAS phase ‚Üí exploit`);
    }
  }
  
  update(state) {
    const out = this.forward(state);
    
    const score = (60 / Math.max(10, state.frameTime)) * 0.4 + 
                  (1 - state.speed / 8000) * 0.3 + 
                  (state.terrain === 'ocean' ? 0.3 : 0.2);
    if (Math.random() < 0.1) this.metaUpdate(score);
    
    return {
      ...out,
      expert: this.experts[this.activeExpert],
      selfMods: this.selfMods,
      hiddenSize: this.hiddenSize,
      nasPhase: this.nasPhase,
      bestScore: this.bestScore,
      zone: state.terrain
    };
  }
}

const nn = new HARP3QuantumHybrid();

// ==================== THREE.JS SETUP ====================
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000510);
scene.fog = new THREE.FogExp2(0x000815, 0.0008);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 1, 5000);

// Lighting
const ambient = new THREE.AmbientLight(0x203040, 0.4);
scene.add(ambient);

const tubeLight = new THREE.PointLight(0x00aaff, 1, 200);
scene.add(tubeLight);

const trainLight = new THREE.SpotLight(0xffffff, 1, 300, Math.PI / 6);
scene.add(trainLight);

// ==================== TUBE TRACK ====================
// Visual track length = 10km, represents full journey
const TRACK_LEN = 10000; // 10km visual, 1 unit = 1 meter
const SEGS = 400;

const trackPts = [];
for (let i = 0; i <= SEGS; i++) {
  const t = i / SEGS;
  const z = t * TRACK_LEN;
  
  // Gentle curves
  const x = Math.sin(t * Math.PI * 6) * 80 + Math.sin(t * Math.PI * 20) * 20;
  
  // Depth profile: start at 0, go down to -450m mid-Atlantic, back up to 0
  const depthT = Math.sin(t * Math.PI);
  const y = -depthT * 200 + 20; // Visual depth scaling
  
  trackPts.push(new THREE.Vector3(x, y, z));
}

const trackCurve = new THREE.CatmullRomCurve3(trackPts);

// Tube shell (translucent)
const tubeGeo = new THREE.TubeGeometry(trackCurve, SEGS, SCIENCE.tubeDiameter / 2 + 0.5, 16, false);
const tubeMat = new THREE.MeshPhongMaterial({
  color: 0x102030,
  transparent: true,
  opacity: 0.3,
  side: THREE.DoubleSide,
  emissive: 0x001020,
  emissiveIntensity: 0.2
});
const tubeShell = new THREE.Mesh(tubeGeo, tubeMat);
scene.add(tubeShell);

// Inner track rail
const railGeo = new THREE.TubeGeometry(trackCurve, SEGS, 0.5, 8, false);
const railMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.3 });
const rail = new THREE.Mesh(railGeo, railMat);
scene.add(rail);

// Tube ring segments (every 50m)
const ringMat = new THREE.MeshStandardMaterial({ color: 0x1a3050, metalness: 0.6, roughness: 0.4 });
for (let i = 0; i < SEGS; i += 5) {
  const t = i / SEGS;
  const pos = trackCurve.getPoint(t);
  const ring = new THREE.Mesh(new THREE.TorusGeometry(SCIENCE.tubeDiameter / 2 + 0.3, 0.15, 8, 24), ringMat);
  ring.position.copy(pos);
  const tan = trackCurve.getTangent(t);
  ring.lookAt(pos.clone().add(tan));
  scene.add(ring);
}

// Emergency lights along tube
const lightMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
for (let i = 0; i < SEGS; i += 10) {
  const t = i / SEGS;
  const pos = trackCurve.getPoint(t);
  const light = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), lightMat);
  light.position.copy(pos);
  light.position.y += SCIENCE.tubeDiameter / 2;
  scene.add(light);
}

// ==================== VACTRAIN ====================
const train = new THREE.Group();

// Aerodynamic nose (hypersonic shape)
const noseGeo = new THREE.ConeGeometry(1.5, 20, 12);
const bodyMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, metalness: 0.7, roughness: 0.3 });
const nose = new THREE.Mesh(noseGeo, bodyMat);
nose.rotation.x = -Math.PI / 2;
nose.position.z = 15;
train.add(nose);

// Main body (sleek capsule)
const capsuleMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, metalness: 0.6, roughness: 0.3 });
for (let i = 0; i < 3; i++) {
  const capsule = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 25, 16), capsuleMat);
  capsule.rotation.x = Math.PI / 2;
  capsule.position.z = -i * 26;
  train.add(capsule);
}

// Blue accent stripe
const stripeMat = new THREE.MeshStandardMaterial({ color: 0x0066cc, metalness: 0.8, roughness: 0.2 });
for (let i = 0; i < 3; i++) {
  const stripe = new THREE.Mesh(new THREE.BoxGeometry(2.85, 0.1, 25), stripeMat);
  stripe.position.set(0, 1.35, -i * 26);
  train.add(stripe);
}

// Maglev coils (visible superconductor rings)
const coilMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x004488, emissiveIntensity: 0.5 });
for (let i = 0; i < 8; i++) {
  const coil = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.08, 8, 24), coilMat);
  coil.position.z = 10 - i * 10;
  coil.rotation.y = Math.PI / 2;
  train.add(coil);
}

scene.add(train);

// ==================== OCEAN ENVIRONMENT ====================
// Water caustics plane (when underwater)
const waterGeo = new THREE.PlaneGeometry(5000, 5000);
const waterMat = new THREE.MeshBasicMaterial({ 
  color: 0x001830, 
  transparent: true, 
  opacity: 0.5,
  side: THREE.DoubleSide 
});
const waterPlane = new THREE.Mesh(waterGeo, waterMat);
waterPlane.rotation.x = Math.PI / 2;
waterPlane.position.y = 20;
scene.add(waterPlane);

// Distant ocean floor particles
const floorParticles = new THREE.BufferGeometry();
const floorPositions = [];
for (let i = 0; i < 500; i++) {
  floorPositions.push(
    (Math.random() - 0.5) * 1000,
    -200 + Math.random() * 50,
    Math.random() * TRACK_LEN
  );
}
floorParticles.setAttribute('position', new THREE.Float32BufferAttribute(floorPositions, 3));
const floorPoints = new THREE.Points(floorParticles, new THREE.PointsMaterial({ color: 0x203040, size: 3 }));
scene.add(floorPoints);

// ==================== STATE ====================
const state = {
  t: 0,
  speed: 0,
  power: 0,
  brake: 0,
  camMode: 0,
  viewMode: 0,
  lastSpeed: 0
};

const keys = {};
addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key === 'c') state.camMode = (state.camMode + 1) % 4;
  if (e.key === 'v') state.viewMode = (state.viewMode + 1) % 2;
});
addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// ==================== ANIMATION ====================
let lastTime = performance.now();
let frameTime = 16, fps = 60;
let pred = {};

function animate() {
  requestAnimationFrame(animate);
  
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;
  frameTime = frameTime * 0.9 + (1000 / Math.max(1, 1 / dt)) * 0.1;
  fps = Math.round(1000 / Math.max(1, frameTime));

  // Input
  if (keys['w'] || keys['arrowup']) {
    state.power = Math.min(1, state.power + dt * 0.8);
    state.brake = Math.max(0, state.brake - dt * 2);
  } else {
    state.power = Math.max(0, state.power - dt * 0.3);
  }
  
  if (keys['s'] || keys['arrowdown']) {
    state.brake = Math.min(1, state.brake + dt * 1.5);
    state.power = 0;
  } else if (!keys['w']) {
    state.brake = Math.max(0, state.brake - dt * 0.5);
  }

  // Physics with g-force limits
  const targetAccel = state.power * SCIENCE.maxAcceleration * 9.81; // m/s¬≤
  const brakeDecel = state.brake * SCIENCE.maxDeceleration * 9.81;
  const dragCoef = 0.000001; // Near-vacuum, almost no drag
  const drag = dragCoef * state.speed * state.speed;
  
  const netAccel = targetAccel - brakeDecel - drag;
  state.speed = Math.max(0, Math.min(SCIENCE.maxSpeed, state.speed + netAccel * dt * 3.6)); // Convert to km/h
  
  // Calculate g-force for display
  const gForce = Math.abs(state.speed - state.lastSpeed) / (dt * 3.6) / 9.81;
  state.lastSpeed = state.speed;

  // Position on track
  const metersPerSecond = state.speed / 3.6;
  state.t = Math.min(0.9999, state.t + (metersPerSecond * dt) / TRACK_LEN);
  
  // Map visual track position to journey km
  const km = state.t * SCIENCE.totalDistance;
  const wp = getWaypoint(km);
  
  // Train position
  const pos = trackCurve.getPoint(state.t);
  const tan = trackCurve.getTangent(state.t);
  train.position.copy(pos);
  train.rotation.y = Math.atan2(tan.x, tan.z);

  // Neural network
  pred = nn.update({ 
    terrain: wp.terrain, 
    frameTime, 
    speed: state.speed,
    depth: wp.depth 
  });
  
  scene.fog.density = 0.0005 + (1 - pred.renderDist / 1000) * 0.001;

  // Lighting based on depth
  const depthFactor = Math.abs(wp.depth) / 500;
  ambient.intensity = 0.4 * (1 - depthFactor * 0.7);
  tubeLight.position.copy(pos);
  tubeLight.intensity = 1 + depthFactor * 0.5;
  
  // Water plane follows train
  waterPlane.position.z = pos.z;
  waterPlane.material.opacity = depthFactor * 0.6;
  
  // Tube color based on depth
  tubeShell.material.emissiveIntensity = 0.2 + depthFactor * 0.3;

  // Camera
  const speedRatio = state.speed / SCIENCE.maxSpeed;
  camera.fov = 75 + speedRatio * 30;
  camera.updateProjectionMatrix();

  if (state.camMode === 0) { // Interior cab
    const cabPos = pos.clone().add(tan.clone().multiplyScalar(12));
    cabPos.y += 0.5;
    camera.position.lerp(cabPos, 0.15);
    camera.lookAt(pos.clone().add(tan.clone().multiplyScalar(200)));
  } else if (state.camMode === 1) { // External follow
    const ext = pos.clone().add(tan.clone().multiplyScalar(-35));
    ext.y += 3;
    camera.position.lerp(ext, 0.05);
    camera.lookAt(pos);
  } else if (state.camMode === 2) { // Side
    const side = new THREE.Vector3(-tan.z, 0, tan.x).normalize().multiplyScalar(8);
    side.y = 1;
    camera.position.lerp(pos.clone().add(side), 0.08);
    camera.lookAt(pos);
  } else { // Cinematic
    const angle = now * 0.0003;
    const cine = pos.clone();
    cine.x += Math.cos(angle) * 15;
    cine.y += 5 + Math.sin(angle * 2) * 2;
    cine.z -= 20;
    camera.position.lerp(cine, 0.03);
    camera.lookAt(pos);
  }

  // Train headlight
  trainLight.position.copy(pos);
  trainLight.position.y += 0.5;
  trainLight.target.position.copy(pos.clone().add(tan.clone().multiplyScalar(100)));
  scene.add(trainLight.target);

  // Effects
  document.getElementById('tunnel-effect').style.opacity = 0.3 + speedRatio * 0.4;
  document.getElementById('speed-lines').style.opacity = speedRatio * 0.5;

  // HUD Updates
  const speedEl = document.getElementById('speed-value');
  speedEl.textContent = Math.round(state.speed);
  speedEl.className = state.speed >= 6000 ? 'hyper' : state.speed >= 4000 ? 'vfast' : state.speed >= 2000 ? 'fast' : '';
  
  const mach = state.speed / 1235; // Speed of sound ~1235 km/h
  document.getElementById('mach').textContent = `MACH ${mach.toFixed(2)}`;
  
  document.getElementById('location').textContent = wp.name || wp.region;
  document.getElementById('subtitle').textContent = wp.region + (wp.depth < -10 ? ` ‚Ä¢ Depth: ${Math.round(wp.depth)}m` : '');
  document.getElementById('dist').textContent = Math.round(km).toLocaleString();
  
  // ETA calculation
  const remaining = SCIENCE.totalDistance - km;
  const etaMinutes = state.speed > 100 ? remaining / state.speed * 60 : 999;
  const etaStr = etaMinutes < 999 ? `${Math.floor(etaMinutes)}:${String(Math.floor((etaMinutes % 1) * 60)).padStart(2, '0')}` : '--:--';
  document.getElementById('eta').textContent = etaStr;
  
  // Tech panel
  document.getElementById('vacuum').textContent = (99.97 - speedRatio * 0.02).toFixed(2) + '%';
  document.getElementById('pressure').textContent = (0.03 + speedRatio * 0.01).toFixed(3) + ' kPa';
  document.getElementById('tube-temp').textContent = Math.round(4 + speedRatio * 8) + '¬∞C';
  document.getElementById('mag-field').textContent = (2.4 + speedRatio * 0.8).toFixed(1) + ' T';
  document.getElementById('levitation').textContent = Math.round(150 - speedRatio * 20) + ' mm';
  
  const gEl = document.getElementById('gforce');
  gEl.textContent = gForce.toFixed(2) + ' g';
  gEl.className = 'val' + (gForce > 0.8 ? ' danger' : gForce > 0.4 ? ' warn' : '');
  
  document.getElementById('power-draw').textContent = Math.round(state.speed * SCIENCE.powerPerKmh) + ' MW';
  
  // Depth indicator
  const depthMarker = document.getElementById('depth-marker');
  const depthPct = (wp.depth + 500) / 600 * 100; // -500 to +100 range
  depthMarker.style.top = (100 - depthPct) + '%';
  document.getElementById('depth-label').textContent = wp.depth >= 0 ? `+${Math.round(wp.depth)}m` : `${Math.round(wp.depth)}m`;
  
  // NN panel
  document.getElementById('nn-lod').textContent = pred.lod;
  document.getElementById('nn-range').textContent = Math.round(pred.renderDist) + 'm';
  document.getElementById('nn-density').textContent = Math.round((pred.density || 1) * 100) + '%';
  document.getElementById('nn-mods').textContent = pred.selfMods;
  document.getElementById('nn-hidden').textContent = pred.hiddenSize;
  document.getElementById('nn-score').textContent = (pred.bestScore || 0).toFixed(2);
  document.getElementById('nn-zone').textContent = pred.zone || 'land';
  document.getElementById('nn-expert').textContent = pred.expert;
  document.getElementById('nn-nas').textContent = pred.nasPhase;

  renderer.render(scene, camera);
}

// Initialize camera
const startPos = trackCurve.getPoint(0);
camera.position.set(startPos.x, startPos.y + 5, startPos.z - 30);
camera.lookAt(startPos);

animate();

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

console.log('%cüöÑ TRANSATLANTIC VACTRAIN 2065', 'font-size: 20px; color: #0af;');
console.log('%cTamworth, UK ‚Üí New York City', 'font-size: 14px; color: #0fa;');
console.log('%c5,847 km in ~55 minutes at MACH 5+', 'font-size: 12px; color: #888;');
console.log('%cHARP-3 Quantum-Hybrid Neural Controller Active', 'font-size: 12px; color: #0f8;');
  </script>
</body>
</html>
