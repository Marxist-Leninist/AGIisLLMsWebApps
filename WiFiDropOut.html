<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Mobile-First WiFi Monitor with Orientation and Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Include Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
    #status { font-size: 1em; padding: 10px; background-color: #f4f4f4; text-align: center; }
    #log { padding: 10px; height: 150px; overflow-y: scroll; border-top: 1px solid #ccc; font-size: 0.9em; }
    .online { color: green; }
    .offline { color: red; }
    .error { color: orange; }
    #map { height: calc(100vh - 300px); } /* Adjust height for mobile */
    h1 { margin: 10px; font-size: 1.5em; text-align: center; }
    #compass { position: absolute; top: 70px; right: 10px; width: 50px; height: 50px; z-index: 1000; }
    #compass img { width: 100%; height: auto; transform: rotate(0deg); transform-origin: center center; }
  </style>
</head>
<body>
  <h1>WiFi Monitor with Orientation and Map</h1>
  <div id="status">Checking connection...</div>
  <div id="map"></div>
  <div id="compass"><img src="https://i.imgur.com/3j8O1oT.png" alt="Compass"></div>
  <div id="log"></div>

  <!-- Include Leaflet JavaScript -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Include Kalman Filter library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/kalmanjs/1.0.0/kalman.min.js"></script>
  <script>
    var initialPosition = null;
    var currentPosition = null;
    var map, marker, circle;
    var isFirstLoad = true;
    var kalmanFilterLat = new KalmanFilter({ R: 0.01, Q: 3 });
    var kalmanFilterLng = new KalmanFilter({ R: 0.01, Q: 3 });
    var lastUpdateTime = null;
    var compassHeading = 0;

    function getLocation(callback) {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          callback(position.coords);
        }, function(error) {
          console.error('Error obtaining location:', error);
          callback(null);
        }, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 5000
        });
      } else {
        console.error('Geolocation is not supported by this browser.');
        callback(null);
      }
    }

    function calculateDistance(coord1, coord2) {
      if (!coord1 || !coord2) return null;

      var R = 6371e3; // metres
      var φ1 = coord1.latitude * Math.PI/180;
      var φ2 = coord2.latitude * Math.PI/180;
      var Δφ = (coord2.latitude - coord1.latitude) * Math.PI/180;
      var Δλ = (coord2.longitude - coord1.longitude) * Math.PI/180;

      var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      var d = R * c;

      return d; // in metres
    }

    function checkConnectionType() {
      if ('connection' in navigator) {
        var type = navigator.connection.effectiveType;
        if (type === 'wifi' || type === 'ethernet') {
          console.log('Connected via WiFi/Ethernet.');
          return true;
        } else if (type === 'cellular') {
          console.warn('Connected via Cellular Data.');
          return false;
        } else {
          console.warn('Connection type is unknown or not WiFi.');
          return false;
        }
      } else {
        console.warn('Network Information API not supported.');
        // Assume WiFi if API not available
        return true;
      }
    }

    function updateStatus(event) {
      var statusElement = document.getElementById('status');
      var logElement = document.getElementById('log');
      var dateTime = new Date().toLocaleString();
      var status = navigator.onLine ? 'Connected' : 'Disconnected';
      var className = navigator.onLine ? 'online' : 'offline';

      if (!checkConnectionType()) {
        status = 'Connected via Cellular Data';
        className = 'error';
      }

      getLocation(function(gpsCoords) {
        if (gpsCoords) {
          // Apply Kalman Filter to latitude and longitude
          gpsCoords.latitude = kalmanFilterLat.filter(gpsCoords.latitude);
          gpsCoords.longitude = kalmanFilterLng.filter(gpsCoords.longitude);

          if (initialPosition === null) {
            initialPosition = gpsCoords;
            currentPosition = gpsCoords;
            initMap(gpsCoords);
            lastUpdateTime = Date.now();
          } else {
            currentPosition = gpsCoords;
          }

          var distance = calculateDistance(initialPosition, currentPosition);
          var distanceText = distance !== null ? 'Distance from start: ' + distance.toFixed(2) + ' meters' : 'Distance data not available';

          statusElement.textContent = status + ' - ' + distanceText;
          statusElement.className = className;
          logElement.innerHTML += '<div class="' + className + '">[' + dateTime + '] ' + status + ' - ' + distanceText + '</div>';
          logElement.scrollTop = logElement.scrollHeight;

          updateMap(currentPosition);
        }
      });
    }

    function initMap(coords) {
      if (isFirstLoad) {
        map = L.map('map').setView([coords.latitude, coords.longitude], 18);

        // Esri World Imagery with Labels
        L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 19,
          attribution: '&copy; Esri &mdash; Esri, DeLorme, NAVTEQ',
        }).addTo(map);

        // Overlay for labels
        L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 19,
          attribution: '&copy; Esri &mdash; Esri, DeLorme, NAVTEQ',
        }).addTo(map);

        marker = L.marker([coords.latitude, coords.longitude], {
          rotationAngle: compassHeading
        }).addTo(map);

        circle = L.circle([coords.latitude, coords.longitude], {
          color: 'red',
          fillColor: '#f03',
          fillOpacity: 0.2,
          radius: 5
        }).addTo(map);

        isFirstLoad = false;
      }
    }

    function updateMap(coords) {
      if (marker && circle) {
        var newLatLng = L.latLng(coords.latitude, coords.longitude);
        marker.setLatLng(newLatLng);
        marker.setRotationAngle(compassHeading);
        circle.setLatLng(newLatLng);
        map.setView(newLatLng);
      }
    }

    function startMonitoring() {
      // Start capturing orientation data
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientationabsolute', handleOrientationEvent, true);
        window.addEventListener('deviceorientation', handleOrientationEvent, true);
      } else {
        console.warn('DeviceOrientationEvent is not supported');
      }

      updateStatus();
      setInterval(updateStatus, 2000); // Update every 2 seconds
    }

    function handleOrientationEvent(event) {
      var compassElement = document.getElementById('compass').children[0];

      var heading = null;

      if (event.absolute && event.alpha !== null) {
        // Use the absolute orientation if available
        heading = event.alpha;
      } else if (event.webkitCompassHeading !== undefined) {
        // For iOS devices
        heading = event.webkitCompassHeading;
      } else if (event.alpha !== null) {
        // Calculate heading from alpha
        heading = 360 - event.alpha; // Adjust for device orientation
      } else {
        console.warn('Cannot determine device heading');
      }

      if (heading !== null) {
        compassHeading = heading;
        compassElement.style.transform = 'rotate(' + heading + 'deg)';

        if (marker) {
          marker.setRotationAngle(heading);
        }
      }
    }

    // Extend Leaflet Marker to support rotation
    L.Marker.include({
      setRotationAngle: function(angle) {
        this.options.rotationAngle = angle;
        this.update();
      },
      _setPos: function(pos) {
        L.Marker.prototype.__proto__._setPos.call(this, pos);
        if (this.options.rotationAngle) {
          this._icon.style.transform += ' rotate(' + this.options.rotationAngle + 'deg)';
        }
      }
    });

    window.addEventListener('load', function() {
      startMonitoring();
    });
    window.addEventListener('online', updateStatus);
    window.addEventListener('offline', updateStatus);
  </script>
</body>
</html>
