<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Advanced Sensor Fusion WiFi Monitor with Labeled Satellite Map</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    #status { font-size: 1.2em; padding: 10px; background-color: #f4f4f4; }
    #log { padding: 10px; height: 150px; overflow-y: scroll; border-top: 1px solid #ccc; }
    .online { color: green; }
    .offline { color: red; }
    .error { color: orange; }
    #map { height: calc(100vh - 250px); }
    h1 { margin: 10px; }
  </style>
  <!-- Include Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
</head>
<body>
  <h1>Advanced Sensor Fusion WiFi Monitor with Labeled Satellite Map</h1>
  <div id="status">Checking connection...</div>
  <div id="map"></div>
  <div id="log"></div>

  <!-- Include Leaflet JavaScript -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Include Kalman Filter library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/kalmanjs/1.0.0/kalman.min.js"></script>
  <script>
    var initialPosition = null;
    var currentPosition = null;
    var map, marker, circle;
    var isFirstLoad = true;
    var kalmanFilterLat = new KalmanFilter({ R: 0.01, Q: 3 });
    var kalmanFilterLng = new KalmanFilter({ R: 0.01, Q: 3 });
    var lastUpdateTime = null;
    var velocity = { x: 0, y: 0 };
    var acceleration = { x: 0, y: 0 };
    var alpha = 0.8; // Low-pass filter constant for acceleration
    var accelerationGravity = { x: 0, y: 0, z: 0 };
    var accelerationUser = { x: 0, y: 0, z: 0 };

    function getLocation(callback) {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          callback(position.coords);
        }, function(error) {
          console.error('Error obtaining location:', error);
          callback(null);
        }, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 5000
        });
      } else {
        console.error('Geolocation is not supported by this browser.');
        callback(null);
      }
    }

    function calculateDistance(coord1, coord2) {
      if (!coord1 || !coord2) return null;

      var R = 6371e3; // metres
      var φ1 = coord1.latitude * Math.PI/180;
      var φ2 = coord2.latitude * Math.PI/180;
      var Δφ = (coord2.latitude - coord1.latitude) * Math.PI/180;
      var Δλ = (coord2.longitude - coord1.longitude) * Math.PI/180;

      var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      var d = R * c;

      return d; // in metres
    }

    function checkConnectionType() {
      if ('connection' in navigator) {
        var type = navigator.connection.effectiveType;
        if (type === 'wifi' || type === 'ethernet') {
          console.log('Connected via WiFi/Ethernet.');
          return true;
        } else if (type === 'cellular') {
          console.warn('Connected via Cellular Data.');
          return false;
        } else {
          console.warn('Connection type is unknown or not WiFi.');
          return false;
        }
      } else {
        console.warn('Network Information API not supported.');
        // Assume WiFi if API not available
        return true;
      }
    }

    function updateStatus(event) {
      var statusElement = document.getElementById('status');
      var logElement = document.getElementById('log');
      var dateTime = new Date().toLocaleString();
      var status = navigator.onLine ? 'Connected' : 'Disconnected';
      var className = navigator.onLine ? 'online' : 'offline';

      if (!checkConnectionType()) {
        status = 'Connected via Cellular Data';
        className = 'error';
      }

      getLocation(function(gpsCoords) {
        if (gpsCoords) {
          // Apply Kalman Filter to latitude and longitude
          gpsCoords.latitude = kalmanFilterLat.filter(gpsCoords.latitude);
          gpsCoords.longitude = kalmanFilterLng.filter(gpsCoords.longitude);

          if (initialPosition === null) {
            initialPosition = gpsCoords;
            currentPosition = gpsCoords;
            initMap(gpsCoords);
            lastUpdateTime = Date.now();
          } else {
            // Fuse GPS data with inertial navigation estimation
            var fusedPosition = fusePosition(gpsCoords);
            currentPosition = fusedPosition;
          }

          var distance = calculateDistance(initialPosition, currentPosition);
          var distanceText = distance !== null ? 'Distance from start: ' + distance.toFixed(2) + ' meters' : 'Distance data not available';

          statusElement.textContent = status + ' - ' + distanceText;
          statusElement.className = className;
          logElement.innerHTML += '<div class="' + className + '">[' + dateTime + '] ' + status + ' - ' + distanceText + '</div>';
          logElement.scrollTop = logElement.scrollHeight;

          updateMap(currentPosition);
        }
      });
    }

    function fusePosition(gpsCoords) {
      // Time since last update
      var now = Date.now();
      var dt = (now - lastUpdateTime) / 1000; // Convert milliseconds to seconds
      lastUpdateTime = now;

      // Update velocity based on acceleration
      velocity.x += accelerationUser.x * dt;
      velocity.y += accelerationUser.y * dt;

      // Estimate displacement
      var displacement = {
        x: velocity.x * dt + 0.5 * accelerationUser.x * dt * dt,
        y: velocity.y * dt + 0.5 * accelerationUser.y * dt * dt
      };

      // Convert displacement from meters to degrees
      var deltaLat = (displacement.y / 111139); // Approximate meters per degree latitude
      var deltaLng = (displacement.x / (111139 * Math.cos(currentPosition.latitude * Math.PI / 180))); // Approximate meters per degree longitude

      // Update position estimate
      var estimatedPosition = {
        latitude: currentPosition.latitude + deltaLat,
        longitude: currentPosition.longitude + deltaLng
      };

      // Simple fusion by averaging GPS and estimated positions
      var fusedPosition = {
        latitude: (gpsCoords.latitude + estimatedPosition.latitude) / 2,
        longitude: (gpsCoords.longitude + estimatedPosition.longitude) / 2
      };

      return fusedPosition;
    }

    function initMap(coords) {
      if (isFirstLoad) {
        map = L.map('map').setView([coords.latitude, coords.longitude], 18);

        // Esri World Imagery with Labels
        L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 19,
          attribution: '&copy; Esri &mdash; Esri, DeLorme, NAVTEQ',
        }).addTo(map);

        // Overlay for labels
        L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 19,
          attribution: '&copy; Esri &mdash; Esri, DeLorme, NAVTEQ',
        }).addTo(map);

        marker = L.marker([coords.latitude, coords.longitude]).addTo(map);
        circle = L.circle([coords.latitude, coords.longitude], {
          color: 'red',
          fillColor: '#f03',
          fillOpacity: 0.2,
          radius: 5
        }).addTo(map);

        isFirstLoad = false;
      }
    }

    function updateMap(coords) {
      if (marker && circle) {
        var newLatLng = L.latLng(coords.latitude, coords.longitude);
        marker.setLatLng(newLatLng);
        circle.setLatLng(newLatLng);
        map.setView(newLatLng);
      }
    }

    function startMonitoring() {
      // Start capturing sensor data
      if (window.DeviceMotionEvent) {
        window.addEventListener('devicemotion', handleMotionEvent, true);
      } else {
        console.warn('DeviceMotionEvent is not supported');
      }

      updateStatus();
      setInterval(updateStatus, 2000); // Update every 2 seconds
    }

    function handleMotionEvent(event) {
      var acc = event.accelerationIncludingGravity;
      if (acc) {
        // Remove gravity component with a simple high-pass filter
        accelerationGravity.x = alpha * accelerationGravity.x + (1 - alpha) * acc.x;
        accelerationGravity.y = alpha * accelerationGravity.y + (1 - alpha) * acc.y;
        accelerationGravity.z = alpha * accelerationGravity.z + (1 - alpha) * acc.z;

        accelerationUser.x = acc.x - accelerationGravity.x;
        accelerationUser.y = acc.y - accelerationGravity.y;
        accelerationUser.z = acc.z - accelerationGravity.z;

        // Convert from m/s^2 to m/s^2 (no change), but you could adjust units if needed
      }
    }

    window.addEventListener('load', function() {
      startMonitoring();
    });
    window.addEventListener('online', updateStatus);
    window.addEventListener('offline', updateStatus);
  </script>
</body>
</html>
