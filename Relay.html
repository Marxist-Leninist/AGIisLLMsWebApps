<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Relay Device Simulation (Three.js)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute; top: 10px; left: 10px; z-index: 1; color: white;
      background-color: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="info">
    <h2>3D Relay Device Simulation</h2>
    <p>Use mouse to rotate and zoom the globe.</p>
  </div>

  <!-- Earth Texture (Base64 Data URI) -->
  <img id="earth-texture" src="data:image/jpeg;base64,
  /9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMSEBUQEhMVFRUXGR0dFxgXFxcdHRocIB0eICEeICQe
  HyghGBolGx4ZITEiJSkrLi4uGCAzODMtNygtLisBCgoKDg0OGhAQGy4lIB8vLS0tLS8tLS0tLS0tLS0t
  LS0tLS0tLS0tLS0tLS0tLSstLSstLS0tLy0tLS0tLf/AABEIAKgBLAMBIgACEQEDEQH/xAAcAAEAAgMBAQE
  BAQAAAAAAAAAAAQIDBAUGBwj/xABCEAABAwIEBQYEAgMBAQAAAAABAAIDBBEFEiExBhNBURQiYXGBkaGxwd
  Gx8ELw8RRC8fAjUjNicoKywSSCo7LS/8QAGQEBAQEBAQEAAAAAAAAAAAAAAAECAwQF/8QAIBEBAQADAQE
  BAAMAAAAAAAAAAAECEQMhEjFBE1Fhcf/aAAwDAQACEQMRAD8A8Ivl8e1qp0uPu1LI8V6T6NHcYdrf0bVrD
  qSubRjLymp1NKSOuwrwYwpAG1GlJ6V5ZzVF8RHkvEQO9DFYYGyDkCc9ZUXvwNifTvRVrbkhpA6F3I0ZvHX
  YiL527OYqRUvYViSUquJr8QHL5ZnRf6bIAt0faUtPg9qZVmnwHCXfjFXu1DyU5I/wBwMq4Z9pnea7KZt9v
  FDsFxNqXOkyrxYrhqe0lPa964UbhbRRriV8XDSkLM+jNq1xVm4RarW1Gm72YZX3Cq3EgfsZTr4/RNJGtLk
  he0mVJYcZyXA9EjsH6VZ9O5pNYiKtJLE6knTOUuNS6DpkGFl5Mpy271Ftth/D9NphhHTPalN3JVpYfS1Je
  UoAwAAAAAAAGgAAAAAAAAAAAAAAAAAAAAcqKm1+V0lGdJeWrIpSoACpAAAAAAAAAAAAAAAAAAAANoPT1VB
  220lj1FFZ0lQmkr+PoxqAMEAAAAAAAAAAAAAAAAAAAAAAAAA8OI7xHdNdn/SlfiWansfm8W7RmjXb8HR2z
  r4AbAAAAAAAABtAAAAAAAAAAAAAAAAAAAAAULN9XZKZMpkB1kuCzijk+PSbkYIgAAAAAAAAAAAAAAAAAAAAAAAAA
  8KfxI6hwnPMXzCGyuYbYdzi8E1s/wCWn+a1TTck+oqzjtvE6Xx6YcI0t7d/7k+sq3IkmKcRXYiAAAABzo
  AAAAAAAAAAAAAAAAAAAAPUx1nbXau5PerR7juswyG6J8mciwhp6sjQY5j0ca53AAAA8oAAAAAAAAAAAAAAAA
  AAP/2Q==" style="display: none;">

  <!-- Include Three.js via CDN (r123) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.min.js"></script>
  <!-- Include OrbitControls via CDN (r123) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/examples/js/controls/OrbitControls.js"></script>

  <script>
    // JavaScript code for the simulation
    let scene, camera, renderer, controls;
    let earth;

    // Coordinates for Point A
    const pointALat = 52.624788;
    const pointALng = -1.662570;

    // Coordinates for Point B
    const pointBLat = 52.615662;
    const pointBLng = -1.650945;

    init();
    animate();

    function init() {
      // Create the scene
      scene = new THREE.Scene();

      // Create the camera
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 2.5;

      // Create the renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create OrbitControls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Add light
      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      // Create Earth geometry and material
      const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
      const earthTexture = new THREE.TextureLoader().load(
        document.getElementById('earth-texture').src
      );
      const earthMaterial = new THREE.MeshBasicMaterial({ map: earthTexture });

      // Create the Earth mesh
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);

      // Add Points A and B
      addPoint(pointALat, pointALng, 0x0000ff); // Blue color
      addPoint(pointBLat, pointBLng, 0x00ff00); // Green color

      // Calculate midpoint
      const midLat = (pointALat + pointBLat) / 2;
      const midLng = (pointALng + pointBLng) / 2;

      // Calculate distance and minimum altitude
      const distanceAB = haversineDistance(pointALat, pointALng, pointBLat, pointBLng);
      const R = 6371e3; // Earth's radius in meters
      const minAltitudeMeters = (distanceAB * distanceAB) / (8 * R);

      // Convert altitude to model scale
      const earthRadiusInMeters = R;
      const modelEarthRadius = 1; // In our 3D model
      const altitudeScale = modelEarthRadius / earthRadiusInMeters;
      const minAltitude = minAltitudeMeters * altitudeScale;

      const minOperationalAltitude = 0.02; // Adjust as needed
      const relayAltitude = Math.max(minAltitude, minOperationalAltitude);

      // Add the relay device
      addRelayDevice(midLat, midLng, relayAltitude, 0xff0000); // Red color

      // Add lines for line-of-sight
      addLine(midLat, midLng, relayAltitude, pointALat, pointALng, 0, 0xffff00); // Yellow
      addLine(midLat, midLng, relayAltitude, pointBLat, pointBLng, 0, 0xffff00); // Yellow

      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Convert latitude and longitude to 3D position on sphere
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lng + 180) * (Math.PI / 180);

      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      const y = radius * Math.cos(phi);

      return new THREE.Vector3(x, y, z);
    }

    function addPoint(lat, lng, color) {
      const radius = 1; // Earth's radius in our model
      const pointGeometry = new THREE.SphereGeometry(0.02, 8, 8);
      const pointMaterial = new THREE.MeshBasicMaterial({ color: color });
      const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);

      const position = latLngToVector3(lat, lng, radius);
      pointMesh.position.copy(position);

      scene.add(pointMesh);
    }

    function addRelayDevice(lat, lng, altitude, color) {
      const radius = 1 + altitude; // Earth's radius + altitude
      const relayGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.1);
      const relayMaterial = new THREE.MeshBasicMaterial({ color: color });
      const relayMesh = new THREE.Mesh(relayGeometry, relayMaterial);

      const position = latLngToVector3(lat, lng, radius);
      relayMesh.position.copy(position);

      scene.add(relayMesh);
    }

    function addLine(lat1, lng1, alt1, lat2, lng2, alt2, color) {
      const radius1 = 1 + alt1;
      const radius2 = 1 + alt2;

      const startPoint = latLngToVector3(lat1, lng1, radius1);
      const endPoint = latLngToVector3(lat2, lng2, radius2);

      const material = new THREE.LineBasicMaterial({ color: color });
      const geometry = new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]);

      const line = new THREE.Line(geometry, material);
      scene.add(line);
    }

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3; // Earth's radius in meters
      const toRad = Math.PI / 180;
      const dLat = (lat2 - lat1) * toRad;
      const dLng = (lng2 - lng1) * toRad;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
        Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distance = R * c;
      return distance;
    }
  </script>
</body>
</html>
