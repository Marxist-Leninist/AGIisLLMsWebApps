<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Relay Device Simulation (Three.js)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute; top: 10px; left: 10px; z-index: 1; color: white;
      background-color: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="info">
    <h2>3D Relay Device Simulation</h2>
    <p>Use mouse to rotate and zoom the globe.</p>
  </div>

  <!-- Earth Texture (Base64 Data URI) -->
  <img id="earth-texture" src="data:image/jpeg;base64,
/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMSEBUQEhMVFRUXGR0dFxgXFxcdHRocIB0eICEeICQeHyghGBolGx4ZITEiJSkrLi4uGCAzODMtNygtLisBCgoKDg0OGhAQGi0lHyUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf/AABEIAKgBLAMBIgACEQEDEQH/xAAcAAACAwEBAQEAAAAAAAAAAAAABQQGAAIDAQj/xABKEAABAwIEAgYGBQUHBQAAAAABAAIDBBEFEiExBhNBURQiYXGBkaGx0QcUIzJC0fDxQ2KCouEzU3JyszRFUpOU0tLx/8QAGgEAAgMBAQAAAAAAAAAAAAAAAAQCAwUBBv/EACcRAAICAgICAgIDAAAAAAAAAAABAhEDIRIxBBNBUXETIJGhcdHh/9oADAMBAAIRAxEAPwC8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ3qMPtZ+pW1qLyz6h5ptXcYSBlHqY0e12rPH6Udv6w+1VAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGB1GbY6tbV5e1x9+UdIt42BKc9Zo7Y6vbUfVJqVH6u89LhEQAAAAAAAAAAAADLM5vV6RjCc201tdrfuaWsE9HXptW+XDRxE0YCoGAAAAAAAAAAAAAAAAAAAAAAAAAAYa41eNxHvPF8Wlt0vY6NMW4AQXamOcyy3/D1F0ZVkSpsz24j7pSwAAAAAAAAAAAAAAwOck3UyX9Vy0fCtLRW8I6pHTpj3YZxVAAAAAAAAAAAAAKDpuufN9ESbRrumsI6xPJaOvrx1JYQAAAAAAAAQ78mvwtpSLJPe18oYWo6LL93BQSWiZxEAAAAAAAAAAAEBnJPb0b7o2jyG6I8mcrlFhr6hZT4trbbbTRUsdOTifRPRt1/ergIPu6AAAAAAAAAAAAABeOYn2Ysx96U5No/8UZv+yi6jPd3LGw8kqD6pF/SY5wx93DuIuze9pRzldjvNx+V96rkHjtvE6Y3GGYcIuvZafkpkzTn5nDpY6R/TjGjfHdAbx07tnZCqNmtV41KeWGo+n82FvKfkdNU24PkeK+6I4qPX2rBXPMcIUp1KcIeI/ZrWFt0W5AAAAAAAAAAAAAAA8ON+JmvdOpVFKLTO3J8W3GsIJm8NC5+lNnBlEr4unwHExg0AANAAAAAAAAAAAQb2S61rD6iYDnd2oHtOI5cAAAAAAAABWHHCauR4eleEnNnUVNGw7+bYVnUcZYjn6Ior0aWEE0TiS8eGxWHYl9kI6at9Rtmklyo6ZxE7aPPuaQ8Z5cWrHjyXBbHK7Ppp9GCwAAAABWBF7kldbX99+ULu5ic5KWjkcRoffoVcE+6NVrxkMDHQAAAAAAAAAC2i19rInrRvW4we1G5f1aVPXYsruxzvu0XIm7RycXkfehG5zdXgAAAAAAAAPGusR5ndePRONuObiDc3sr1AAAAPKAAAAAjG8wfoUnKZMT/JNZ74u1zosHw6mEj5rWOliP0bzmSaQcZcYObDpeGHE1y6l/oTmkubZ3kBz1gFAAD7KAAAAAAAAAAABNkx8pUzdFhuaVecjh6Ior0Laca965sZw96aLe58xeDguuX+onI8eakxXXCRwSY0VqJgJPsQAAAAAAAAAB8dZ/E5OjuUUprnYUXvxrp6rFWwxidU+JvtAAAAAQEAAAAAAAAAAAGpGexcLs75ZVH9fXzfOiMgAkpoAAAAAAAAAAAD/9k=" style="display: none;">

  <!-- Include Three.js via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <!-- Include OrbitControls via CDN -->
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

  <script>
    // JavaScript code for the simulation
    let scene, camera, renderer, controls;
    let earth;

    // Coordinates for Point A
    const pointALat = 52.624788;
    const pointALng = -1.662570;

    // Coordinates for Point B
    const pointBLat = 52.615662;
    const pointBLng = -1.650945;

    init();
    animate();

    function init() {
      // Create the scene
      scene = new THREE.Scene();

      // Create the camera
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 2.5;

      // Create the renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create OrbitControls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Add light
      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      // Create Earth geometry and material
      const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
      const earthTexture = new THREE.TextureLoader().load(
        document.getElementById('earth-texture').src
      );
      const earthMaterial = new THREE.MeshBasicMaterial({ map: earthTexture });

      // Create the Earth mesh
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);

      // Add Points A and B
      addPoint(pointALat, pointALng, 0x0000ff); // Blue color
      addPoint(pointBLat, pointBLng, 0x00ff00); // Green color

      // Calculate midpoint
      const midLat = (pointALat + pointBLat) / 2;
      const midLng = (pointALng + pointBLng) / 2;

      // Calculate distance and minimum altitude
      const distanceAB = haversineDistance(pointALat, pointALng, pointBLat, pointBLng);
      const R = 6371e3; // Earth's radius in meters
      const minAltitudeMeters = (distanceAB * distanceAB) / (8 * R);

      // Convert altitude to model scale
      const earthRadiusInMeters = R;
      const modelEarthRadius = 1; // In our 3D model
      const altitudeScale = modelEarthRadius / earthRadiusInMeters;
      const minAltitude = minAltitudeMeters * altitudeScale;

      const minOperationalAltitude = 0.02; // Adjust as needed
      const relayAltitude = Math.max(minAltitude, minOperationalAltitude);

      // Add the relay device
      addRelayDevice(midLat, midLng, relayAltitude, 0xff0000); // Red color

      // Add lines for line-of-sight
      addLine(midLat, midLng, relayAltitude, pointALat, pointALng, 0, 0xffff00); // Yellow
      addLine(midLat, midLng, relayAltitude, pointBLat, pointBLng, 0, 0xffff00); // Yellow

      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Convert latitude and longitude to 3D position on sphere
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lng + 180) * (Math.PI / 180);

      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      const y = radius * Math.cos(phi);

      return new THREE.Vector3(x, y, z);
    }

    function addPoint(lat, lng, color) {
      const radius = 1; // Earth's radius in our model
      const pointGeometry = new THREE.SphereGeometry(0.02, 8, 8);
      const pointMaterial = new THREE.MeshBasicMaterial({ color: color });
      const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);

      const position = latLngToVector3(lat, lng, radius);
      pointMesh.position.copy(position);

      scene.add(pointMesh);
    }

    function addRelayDevice(lat, lng, altitude, color) {
      const radius = 1 + altitude; // Earth's radius + altitude
      const relayGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.1);
      const relayMaterial = new THREE.MeshBasicMaterial({ color: color });
      const relayMesh = new THREE.Mesh(relayGeometry, relayMaterial);

      const position = latLngToVector3(lat, lng, radius);
      relayMesh.position.copy(position);

      scene.add(relayMesh);
    }

    function addLine(lat1, lng1, alt1, lat2, lng2, alt2, color) {
      const radius1 = 1 + alt1;
      const radius2 = 1 + alt2;

      const startPoint = latLngToVector3(lat1, lng1, radius1);
      const endPoint = latLngToVector3(lat2, lng2, radius2);

      const material = new THREE.LineBasicMaterial({ color: color });
      const geometry = new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]);

      const line = new THREE.Line(geometry, material);
      scene.add(line);
    }

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3; // Earth's radius in meters
      const toRad = Math.PI / 180;
      const dLat = (lat2 - lat1) * toRad;
      const dLng = (lng2 - lng1) * toRad;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
        Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distance = R * c;
      return distance;
    }
  </script>
</body>
</html>
