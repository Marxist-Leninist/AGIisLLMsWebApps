<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL BOXING ULTIMATE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(180deg, #1a0a0a 0%, #0a0a12 50%, #0a0a0a 100%);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            padding: 8px;
            overflow-x: hidden;
        }
        
        .header { text-align: center; margin-bottom: 6px; }
        
        h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
        }
        
        .subtitle { color: #666; font-size: 0.7rem; }
        
        .ring-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        
        .corner-panel {
            background: linear-gradient(145deg, #1a1215, #0a0808);
            border: 2px solid #2a1a1a;
            border-radius: 8px;
            padding: 8px;
            width: 190px;
            font-size: 0.7rem;
        }
        .corner-panel.red { border-color: #ff4444; }
        .corner-panel.blue { border-color: #4444ff; }
        
        .fighter-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }
        
        .fighter-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        .corner-panel.red .fighter-icon { background: #ff4444; }
        .corner-panel.blue .fighter-icon { background: #4444ff; }
        
        .fighter-name { font-size: 0.85rem; font-weight: bold; }
        .corner-panel.red .fighter-name { color: #ff6666; }
        .corner-panel.blue .fighter-name { color: #6666ff; }
        
        .fighter-style { font-size: 0.55rem; color: #888; }
        
        .fighter-select {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
            margin-bottom: 6px;
        }
        .fighter-option {
            padding: 4px;
            background: #1a1a1a;
            border: 1px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.6rem;
            text-align: center;
        }
        .fighter-option:hover { border-color: #444; }
        .fighter-option.selected { border-color: #00ffaa; background: #1a2a2a; }
        .fighter-option .icon { font-size: 0.9rem; }
        .fighter-option .name { font-weight: bold; color: #fff; font-size: 0.55rem; }
        
        .stat-bars { margin-bottom: 6px; }
        .stat-bar { margin-bottom: 4px; }
        .stat-bar .label {
            display: flex;
            justify-content: space-between;
            font-size: 0.55rem;
            color: #666;
            margin-bottom: 1px;
        }
        .bar-bg { height: 10px; background: #1a1a1a; border-radius: 5px; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.15s; border-radius: 5px; }
        .bar-fill.hp { background: linear-gradient(90deg, #44ff44, #22aa22); }
        .bar-fill.stamina { background: linear-gradient(90deg, #ffaa00, #aa7700); }
        .bar-fill.super { background: linear-gradient(90deg, #ff00ff, #aa00aa); }
        .bar-fill.rage { background: linear-gradient(90deg, #ff0000, #ff4400); }
        .bar-fill.hp.low { background: linear-gradient(90deg, #ff4444, #aa2222); }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
            font-size: 0.6rem;
            margin-bottom: 6px;
        }
        .stat-item { background: #0a0a0a; padding: 3px; border-radius: 3px; text-align: center; }
        .stat-item .val { font-size: 0.8rem; font-weight: bold; color: #ffaa00; }
        
        .status-effects {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            margin-bottom: 4px;
            min-height: 18px;
        }
        .status-effect {
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.5rem;
            font-weight: bold;
        }
        .status-effect.rage { background: #ff0000; color: #fff; animation: pulse 0.5s infinite; }
        .status-effect.stunned { background: #ffff00; color: #000; }
        .status-effect.bleeding { background: #aa0000; color: #fff; }
        .status-effect.exhausted { background: #666; color: #fff; }
        .status-effect.combo { background: #ff00ff; color: #fff; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .brain-panel { background: #0a0808; border-radius: 4px; padding: 5px; }
        .brain-panel h4 { font-size: 0.5rem; color: #555; margin-bottom: 3px; text-transform: uppercase; }
        .brain-viz { min-height: 35px; }
        .memory-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 1px; }
        .mem-cell { width: 12px; height: 12px; border-radius: 2px; background: #1a1a1a; }
        .hidden-neurons { display: flex; flex-wrap: wrap; gap: 1px; }
        .neuron { width: 8px; height: 8px; border-radius: 50%; background: #1a1a1a; }
        
        .corner-advice {
            background: #0a0a0a;
            padding: 4px;
            border-radius: 3px;
            font-size: 0.55rem;
            color: #888;
            min-height: 28px;
            margin-top: 4px;
        }
        .corner-advice .label { color: #ffaa00; font-weight: bold; }
        
        .ring {
            position: relative;
            width: 520px;
            height: 380px;
            background: linear-gradient(180deg, #2a2a35 0%, #1a1a22 100%);
            border: 6px solid #8B4513;
            border-radius: 4px;
            overflow: hidden;
        }
        .ring-floor {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 160px;
            background: linear-gradient(180deg, #3a3a45 0%, #2a2a35 100%);
        }
        .ropes { position: absolute; inset: 0; pointer-events: none; }
        .rope { position: absolute; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, #aa2222, #ff4444, #aa2222); }
        .rope:nth-child(1) { top: 12%; }
        .rope:nth-child(2) { top: 28%; }
        .rope:nth-child(3) { bottom: 38%; }
        .rope:nth-child(4) { bottom: 22%; }
        
        .corner-post { position: absolute; width: 10px; height: 100%; background: linear-gradient(90deg, #555, #888, #555); }
        .corner-post.left { left: 0; }
        .corner-post.right { right: 0; }
        
        .crowd {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            opacity: 0.7;
            transition: all 0.3s;
            pointer-events: none;
        }
        .crowd.hyped { font-size: 1.5rem; animation: crowd-wave 0.3s ease-in-out; }
        @keyframes crowd-wave {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        .boxer {
            position: absolute;
            width: 75px;
            height: 125px;
            transition: left 0.06s, bottom 0.06s, transform 0.06s, filter 0.2s;
        }
        .boxer-body {
            position: absolute;
            bottom: 18px;
            width: 50px;
            height: 75px;
            left: 12px;
            border-radius: 25px 25px 15px 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.08s, box-shadow 0.2s;
        }
        .boxer.red .boxer-body { background: linear-gradient(180deg, #ff6666, #cc3333); }
        .boxer.blue .boxer-body { background: linear-gradient(180deg, #6666ff, #3333cc); }
        
        .boxer-head {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            background: #ffcc99;
            margin-top: -12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            border: 2px solid;
            position: relative;
            z-index: 2;
            transition: transform 0.08s;
        }
        .boxer.red .boxer-head { border-color: #ff4444; }
        .boxer.blue .boxer-head { border-color: #4444ff; }
        
        .injury-indicator {
            position: absolute;
            font-size: 0.6rem;
            top: -5px;
            right: -5px;
        }
        
        .glove {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            top: 42px;
            transition: all 0.06s;
            z-index: 3;
        }
        .boxer.red .glove { background: radial-gradient(circle at 30% 30%, #ff6666, #cc2222); }
        .boxer.blue .glove { background: radial-gradient(circle at 30% 30%, #6666ff, #2222cc); }
        .glove.left { left: -3px; }
        .glove.right { right: -3px; }
        
        .leg {
            position: absolute;
            width: 14px;
            height: 32px;
            bottom: 0;
            border-radius: 8px;
            left: 10px;
            transition: transform 0.08s;
        }
        .leg.right { left: 26px; }
        .boxer.red .leg { background: #b03030; }
        .boxer.blue .leg { background: #3030b0; }
        
        /* States */
        .boxer.rage { filter: brightness(1.3) saturate(1.5); }
        .boxer.rage .boxer-body { box-shadow: 0 0 20px #ff0000; animation: rage-pulse 0.3s infinite; }
        @keyframes rage-pulse {
            0%, 100% { box-shadow: 0 0 15px #ff0000; }
            50% { box-shadow: 0 0 25px #ff4400; }
        }
        
        .boxer.super-charging { animation: super-charge 0.5s infinite; }
        @keyframes super-charge {
            0%, 100% { filter: brightness(1) hue-rotate(0deg); }
            50% { filter: brightness(1.5) hue-rotate(30deg); }
        }
        
        .boxer.blocking .glove { top: 20px !important; }
        .boxer.blocking .glove.left { left: 5px !important; }
        .boxer.blocking .glove.right { right: 5px !important; }
        
        .boxer.parrying .glove.left { left: -12px !important; top: 18px !important; }
        .boxer.parrying .glove.right { right: -12px !important; top: 18px !important; }
        .boxer.parrying { filter: drop-shadow(0 0 6px #ffaa00); }
        
        .boxer.dodging { transform: translateY(-8px); opacity: 0.85; }
        .boxer.weaving .boxer-body { animation: weave 0.3s ease-in-out; }
        @keyframes weave {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(10px) rotate(5deg); }
        }
        
        .boxer.jabbing .glove.right { right: -40px !important; top: 35px !important; }
        .boxer.hooking .glove.right { right: -35px !important; top: 28px !important; transform: rotate(-25deg); }
        .boxer.uppercutting .glove.right { right: -22px !important; top: 8px !important; }
        .boxer.crossing .glove.right { right: -45px !important; top: 32px !important; }
        .boxer.body-shotting .glove.right { right: -35px !important; top: 50px !important; }
        .boxer.elbowing .glove.right { right: -25px !important; top: 22px !important; transform: rotate(45deg); }
        .boxer.spinning-elbow { animation: spin-attack 0.3s ease-out; }
        
        .boxer.kicking .leg.right { transform: rotate(-30deg) translate(6px, -8px); }
        .boxer.spin-kicking .leg.right { transform: rotate(-55deg) translate(14px, -14px); }
        .boxer.sweeping .leg.right { transform: rotate(-35deg) translate(8px, -4px); }
        .boxer.knee-striking .leg.right { transform: rotate(-70deg) translate(5px, -15px); }
        .boxer.flying-knee { transform: translateY(-15px); }
        .boxer.flying-knee .leg.right { transform: rotate(-80deg) translate(5px, -20px); }
        
        .boxer.clinching .glove.left { left: 15px !important; top: 15px !important; }
        .boxer.clinching .glove.right { right: 15px !important; top: 15px !important; }
        
        .boxer.taunting .glove.left { left: 0 !important; top: 5px !important; transform: rotate(-20deg); }
        .boxer.taunting .boxer-head { animation: taunt-head 0.4s ease-in-out infinite; }
        @keyframes taunt-head {
            0%, 100% { transform: rotate(0); }
            50% { transform: rotate(10deg) scale(1.05); }
        }
        
        .boxer.feinting .glove.right { right: -20px !important; top: 38px !important; }
        
        .boxer.super-attacking {
            animation: super-attack 0.4s ease-out;
        }
        .boxer.super-attacking .boxer-body {
            box-shadow: 0 0 30px #ff00ff;
        }
        .boxer.super-attacking .glove.right {
            right: -55px !important;
            top: 25px !important;
            transform: scale(1.4);
        }
        @keyframes super-attack {
            0% { filter: brightness(1); }
            50% { filter: brightness(2) hue-rotate(90deg); }
            100% { filter: brightness(1); }
        }
        
        @keyframes spin-attack {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .boxer.hit { animation: hit-shake 0.15s; }
        @keyframes hit-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px) rotate(-4deg); }
            75% { transform: translateX(8px) rotate(4deg); }
        }
        
        .boxer.knocked-down .boxer-body { transform: rotate(85deg) translateY(30px); }
        .boxer.knocked-down .boxer-head { transform: rotate(-85deg); }
        
        .boxer.stunned .boxer-head { animation: stun-stars 0.4s linear infinite; }
        @keyframes stun-stars {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Effects */
        .effect {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        
        .punch-effect {
            font-size: 1.8rem;
            animation: punch-pop 0.35s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }
        @keyframes punch-pop {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(1.4) translateY(-25px); opacity: 0; }
        }
        
        .damage-text {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ff4444;
            animation: damage-float 0.7s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }
        .damage-text.crit { color: #ff00ff; font-size: 1.5rem; }
        @keyframes damage-float {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-40px); opacity: 0; }
        }
        
        .combo-text {
            font-size: 1.6rem;
            font-weight: bold;
            color: #ffaa00;
            animation: combo-pop 0.8s ease-out forwards;
            text-shadow: 3px 3px 0 #000;
        }
        @keyframes combo-pop {
            0% { transform: scale(0.3) rotate(-10deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) translateY(-25px); opacity: 0; }
        }
        
        .taunt-bubble {
            background: #000000ee;
            color: #fff;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            animation: taunt-float 2s ease-out forwards;
            white-space: nowrap;
            max-width: 150px;
            text-align: center;
        }
        @keyframes taunt-float {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-40px); }
        }
        
        .blood-effect {
            color: #aa0000;
            font-size: 0.8rem;
            animation: blood-drip 1s ease-out forwards;
        }
        @keyframes blood-drip {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(30px); }
        }
        
        .super-effect {
            font-size: 2.5rem;
            animation: super-explode 0.5s ease-out forwards;
        }
        @keyframes super-explode {
            0% { transform: scale(0); opacity: 1; filter: hue-rotate(0deg); }
            50% { transform: scale(2); filter: hue-rotate(180deg); }
            100% { transform: scale(2.5); opacity: 0; filter: hue-rotate(360deg); }
        }
        
        .thought-bubble {
            position: absolute;
            background: #000000dd;
            color: #fff;
            padding: 3px 6px;
            border-radius: 6px;
            font-size: 0.55rem;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 120px;
            text-align: center;
        }
        .thought-bubble.visible { opacity: 1; }
        
        .scoreboard {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            background: #000000dd;
            padding: 5px 15px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1rem;
            font-weight: bold;
            z-index: 10;
        }
        .scoreboard .red { color: #ff4444; }
        .scoreboard .blue { color: #4444ff; }
        .scoreboard .round { color: #ffaa00; font-size: 0.7rem; }
        .scoreboard .timer { color: #aaa; font-size: 0.65rem; }
        
        .round-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 3px 3px 0 #000;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        .round-banner.visible { animation: round-announce 1.8s ease-out forwards; }
        @keyframes round-announce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        .ko-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 4px 4px 0 #000, 0 0 25px #ff0000;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        .ko-banner.visible { opacity: 1; animation: ko-shake 0.5s ease-out; }
        @keyframes ko-shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0); }
            25% { transform: translate(-50%, -50%) rotate(-4deg) scale(1.1); }
            75% { transform: translate(-50%, -50%) rotate(4deg) scale(1.1); }
        }
        
        .controls {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin: 8px 0;
            flex-wrap: wrap;
        }
        button {
            background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
            border: 1px solid #3a3a4e;
            padding: 6px 12px;
            font-family: inherit;
            font-size: 0.75rem;
            color: #aaa;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { border-color: #00ffaa; color: #00ffaa; }
        button.active { background: #00aa7733; border-color: #00ffaa; color: #00ffaa; }
        
        .commentary {
            max-width: 920px;
            margin: 8px auto;
            background: linear-gradient(145deg, #1a1215, #0a0808);
            border: 1px solid #2a1a1a;
            border-radius: 6px;
            padding: 8px;
        }
        .commentary h3 { color: #ffaa00; font-size: 0.7rem; margin-bottom: 4px; }
        #commentary-text { color: #aaa; font-size: 0.75rem; line-height: 1.4; min-height: 30px; }
        
        .fight-log {
            max-height: 50px;
            overflow-y: auto;
            font-size: 0.55rem;
            color: #555;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid #222;
        }
        .fight-log div { padding: 1px 0; }
        .fight-log .red { color: #ff6666; }
        .fight-log .blue { color: #6666ff; }
        .fight-log .crit { color: #ff00ff; }
        .fight-log .ko { color: #ff0000; font-weight: bold; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü•ä NEURAL BOXING ULTIMATE ü•ä</h1>
        <div class="subtitle">8 Architectures ‚Ä¢ 20+ Moves ‚Ä¢ Combos ‚Ä¢ Supers ‚Ä¢ Rage Mode ‚Ä¢ Injuries</div>
    </div>
    
    <div class="controls">
        <button id="btn-fight" onclick="toggleFight()">üîî FIGHT</button>
        <button onclick="resetFight()">‚Ü∫ RESET</button>
        <button onclick="setSpeed(0.5)">0.5x</button>
        <button onclick="setSpeed(1)" class="active">1x</button>
        <button onclick="setSpeed(2)">2x</button>
        <button onclick="setSpeed(3)">3x</button>
    </div>
    
    <div class="ring-container">
        <div class="corner-panel red">
            <div class="fighter-header">
                <div class="fighter-icon" id="icon1">üß†</div>
                <div>
                    <div class="fighter-name" id="name1">TNTM</div>
                    <div class="fighter-style" id="style1">Technical Outboxer</div>
                </div>
            </div>
            
            <div class="fighter-select" id="select1"></div>
            
            <div class="status-effects" id="status1"></div>
            
            <div class="stat-bars">
                <div class="stat-bar">
                    <div class="label"><span>‚ù§Ô∏è HP</span><span id="hp1-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill hp" id="hp1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>‚ö° STAM</span><span id="stam1-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill stamina" id="stam1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üíú SUPER</span><span id="super1-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill super" id="super1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üî• RAGE</span><span id="rage1-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill rage" id="rage1"></div></div>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-item"><div class="val" id="hits1">0</div>Hits</div>
                <div class="stat-item"><div class="val" id="combo1">0</div>Combo</div>
                <div class="stat-item"><div class="val" id="kd1">0</div>KDs</div>
            </div>
            
            <div class="brain-panel">
                <h4 id="brain1-title">External Memory</h4>
                <div class="brain-viz" id="brain1"></div>
            </div>
            
            <div class="corner-advice" id="advice1">
                <span class="label">CORNER:</span> <span id="advice1-text">Fight smart!</span>
            </div>
        </div>
        
        <div class="ring" id="ring">
            <div class="ring-floor"></div>
            <div class="ropes"><div class="rope"></div><div class="rope"></div><div class="rope"></div><div class="rope"></div></div>
            <div class="corner-post left"></div>
            <div class="corner-post right"></div>
            
            <div class="crowd" id="crowd">üë•üë•üë•üë•üë•üë•üë•üë•üë•üë•</div>
            
            <div class="scoreboard">
                <span class="red" id="score1">0</span>
                <span class="round" id="round-display">R1</span>
                <span class="timer" id="timer">3:00</span>
                <span class="blue" id="score2">0</span>
            </div>
            
            <div class="boxer red" id="boxer1">
                <div class="thought-bubble" id="thought1"></div>
                <div class="boxer-body">
                    <div class="boxer-head">üß†<span class="injury-indicator" id="injury1"></span></div>
                </div>
                <div class="glove left"></div>
                <div class="glove right"></div>
                <div class="leg left"></div>
                <div class="leg right"></div>
            </div>
            
            <div class="boxer blue" id="boxer2">
                <div class="thought-bubble" id="thought2"></div>
                <div class="boxer-body">
                    <div class="boxer-head">‚ö°<span class="injury-indicator" id="injury2"></span></div>
                </div>
                <div class="glove left"></div>
                <div class="glove right"></div>
                <div class="leg left"></div>
                <div class="leg right"></div>
            </div>
            
            <div class="round-banner" id="round-banner">ROUND 1</div>
            <div class="ko-banner" id="ko-banner">K.O.!</div>
        </div>
        
        <div class="corner-panel blue">
            <div class="fighter-header">
                <div class="fighter-icon" id="icon2">‚ö°</div>
                <div>
                    <div class="fighter-name" id="name2">Transformer</div>
                    <div class="fighter-style" id="style2">Aggressive Brawler</div>
                </div>
            </div>
            
            <div class="fighter-select" id="select2"></div>
            
            <div class="status-effects" id="status2"></div>
            
            <div class="stat-bars">
                <div class="stat-bar">
                    <div class="label"><span>‚ù§Ô∏è HP</span><span id="hp2-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill hp" id="hp2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>‚ö° STAM</span><span id="stam2-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill stamina" id="stam2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üíú SUPER</span><span id="super2-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill super" id="super2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üî• RAGE</span><span id="rage2-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill rage" id="rage2"></div></div>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-item"><div class="val" id="hits2">0</div>Hits</div>
                <div class="stat-item"><div class="val" id="combo2">0</div>Combo</div>
                <div class="stat-item"><div class="val" id="kd2">0</div>KDs</div>
            </div>
            
            <div class="brain-panel">
                <h4 id="brain2-title">Attention Heads</h4>
                <div class="brain-viz" id="brain2"></div>
            </div>
            
            <div class="corner-advice" id="advice2">
                <span class="label">CORNER:</span> <span id="advice2-text">Fight smart!</span>
            </div>
        </div>
    </div>
    
    <div class="commentary">
        <h3>üì¢ COMMENTARY</h3>
        <div id="commentary-text">Select fighters and ring the bell!</div>
        <div class="fight-log" id="fight-log"></div>
    </div>

<script>
// =============================================
// FIGHTER DEFINITIONS
// =============================================

const FIGHTERS = {
    tntm: {
        name: 'TNTM', icon: 'üß†', style: 'Technical Outboxer',
        superName: 'MEMORY OVERLOAD', color: '#ff6666',
        stats: { power: 7, speed: 6, defense: 8, stamina: 7 },
        brainTitle: 'External Memory'
    },
    transformer: {
        name: 'Transformer', icon: '‚ö°', style: 'Aggressive Brawler',
        superName: 'ATTENTION STORM', color: '#6666ff',
        stats: { power: 8, speed: 9, defense: 5, stamina: 6 },
        brainTitle: 'Attention Heads'
    },
    lstm: {
        name: 'LSTM', icon: 'üîÑ', style: 'Patient Counter',
        superName: 'GATE OVERFLOW', color: '#66ff66',
        stats: { power: 6, speed: 5, defense: 9, stamina: 8 },
        brainTitle: 'Cell State'
    },
    mlp: {
        name: 'MLP', icon: 'üìä', style: 'Simple Striker',
        superName: 'GRADIENT BOMB', color: '#ffaa00',
        stats: { power: 7, speed: 7, defense: 6, stamina: 7 },
        brainTitle: 'ReLU Layer'
    },
    cnn: {
        name: 'CNN', icon: 'üëÅÔ∏è', style: 'Pattern Reader',
        superName: 'KERNEL CRUSH', color: '#00ffaa',
        stats: { power: 6, speed: 7, defense: 7, stamina: 8 },
        brainTitle: 'Feature Maps'
    },
    gan: {
        name: 'GAN', icon: 'üé≠', style: 'Deceptive Trickster',
        superName: 'MODE COLLAPSE', color: '#ff66ff',
        stats: { power: 7, speed: 8, defense: 6, stamina: 6 },
        brainTitle: 'Gen/Disc'
    },
    mamba: {
        name: 'Mamba', icon: 'üêç', style: 'State Space Striker',
        superName: 'SELECTIVE SCAN', color: '#88ff88',
        stats: { power: 8, speed: 8, defense: 6, stamina: 6 },
        brainTitle: 'SSM State'
    },
    rwkv: {
        name: 'RWKV', icon: 'üåä', style: 'Linear Attacker',
        superName: 'RECEPTANCE WAVE', color: '#66ffff',
        stats: { power: 7, speed: 7, defense: 7, stamina: 7 },
        brainTitle: 'WKV State'
    }
};

const MOVES = {
    // Punches
    jab: { dmg: [4,7], stam: 4, range: 95, speed: 12, type: 'punch' },
    cross: { dmg: [8,12], stam: 8, range: 100, speed: 18, type: 'punch' },
    hook: { dmg: [10,16], stam: 12, range: 85, speed: 22, type: 'punch' },
    uppercut: { dmg: [14,22], stam: 16, range: 75, speed: 26, type: 'punch' },
    body_shot: { dmg: [6,10], stam: 8, range: 80, speed: 16, type: 'punch', drainStam: 8 },
    overhand: { dmg: [12,20], stam: 14, range: 90, speed: 24, type: 'punch', knockdownBonus: 0.1 },
    
    // Elbows & Knees
    elbow: { dmg: [8,14], stam: 10, range: 60, speed: 16, type: 'elbow', cutChance: 0.2 },
    spinning_elbow: { dmg: [14,22], stam: 18, range: 70, speed: 28, type: 'elbow', cutChance: 0.35 },
    knee: { dmg: [10,16], stam: 12, range: 65, speed: 20, type: 'knee' },
    flying_knee: { dmg: [18,28], stam: 22, range: 80, speed: 30, type: 'knee', knockdownBonus: 0.2 },
    
    // Kicks
    kick: { dmg: [10,16], stam: 12, range: 120, speed: 22, type: 'kick' },
    body_kick: { dmg: [8,14], stam: 10, range: 115, speed: 20, type: 'kick', drainStam: 12 },
    head_kick: { dmg: [16,26], stam: 18, range: 125, speed: 28, type: 'kick', knockdownBonus: 0.15 },
    spin_kick: { dmg: [14,24], stam: 16, range: 130, speed: 26, type: 'kick' },
    sweep: { dmg: [6,10], stam: 10, range: 110, speed: 24, type: 'kick', knockdownBonus: 0.25 },
    
    // Combos
    one_two: { dmg: [10,16], stam: 10, range: 95, speed: 20, type: 'combo', hits: 2 },
    three_piece: { dmg: [16,26], stam: 18, range: 90, speed: 28, type: 'combo', hits: 3 },
    blitz: { dmg: [22,34], stam: 26, range: 85, speed: 35, type: 'combo', hits: 4 },
    
    // Defense
    block: { stam: 2, speed: 8 },
    parry: { stam: 4, speed: 10 },
    slip: { stam: 5, speed: 10 },
    weave: { stam: 6, speed: 12 },
    dodge: { stam: 8, speed: 14 },
    
    // Other
    clinch: { stam: -12, speed: 25, range: 55 },
    feint: { stam: 3, speed: 8, superGain: 5 },
    taunt: { stam: 5, speed: 30, superGain: 12, rageGain: 8 },
    
    // Super
    super: { dmg: [30,45], stam: 35, range: 110, speed: 45, type: 'super', knockdownBonus: 0.4 }
};

const TAUNTS = {
    tntm: ["I've memorized your whole moveset!", "Pattern recognized: LOSER", "Content-addressing YOUR FACE", "Write head says you're done!"],
    transformer: ["All 4 heads agree: you SUCK!", "Attending to your DEFEAT!", "No memory needed to beat YOU", "Self-attention > your skills"],
    lstm: ["Forget gate just forgot your win chance!", "Cell state = CHAMPION state", "Gated recurrence gonna wreck you!", "Patience pays, you're about to pay!"],
    mlp: ["Feedforward THESE HANDS!", "ReLU(your chances) = 0", "Simple network, simple DESTRUCTION", "16 neurons of PAIN incoming!"],
    cnn: ["I SEE your weakness!", "Convolved your face already!", "Feature map says you're trash!", "Pooling your tears!"],
    gan: ["Generator: your loss | Discriminator: REAL", "Can't tell if fake... YOUR SKILLS!", "Adversarial training ON YOUR FACE", "Mode collapse? More like YOU collapse!"],
    mamba: ["State space says you're done!", "Selective scan found: WEAKNESS", "Linear time complexity, LINEAR PAIN", "Sssslithering to victory!"],
    rwkv: ["Linear attention LINEAR DESTRUCTION!", "Receptance: your surrender!", "WKV = Win Knockout Victory", "Channeling the wave of your DEFEAT!"]
};

const CORNER_ADVICE = [
    "Keep that guard up!", "Go to the body!", "You've got this!", "Watch the counter!",
    "Stay patient!", "Time to pressure!", "Conserve stamina!", "Super is ready!",
    "They're hurt, FINISH IT!", "Back off, recover!", "Use your reach!", "Mix it up!"
];

// =============================================
// BRAIN IMPLEMENTATIONS
// =============================================

class BaseBrain {
    constructor(type) {
        this.type = type;
        this.info = FIGHTERS[type];
    }
    renderBrain(container) { container.innerHTML = '<div style="color:#444;font-size:0.5rem;">No viz</div>'; }
}

class TNTMBrain extends BaseBrain {
    constructor() {
        super('tntm');
        this.memory = Array(32).fill(null).map(() => Array(10).fill(0));
        this.readWeights = Array(32).fill(1/32);
        this.writeHead = 0;
        this.patternBuffer = [];
        this.patterns = {};
    }
    
    write(vec) {
        this.writeHead = (this.writeHead + 1) % 32;
        for (let i = 0; i < vec.length && i < 10; i++) {
            this.memory[this.writeHead][i] = this.memory[this.writeHead][i] * 0.2 + vec[i] * 0.8;
        }
    }
    
    read(query) {
        const sims = this.memory.map(mem => {
            let dot = 0, nQ = 0, nM = 0;
            for (let j = 0; j < 10; j++) {
                dot += (query[j]||0) * mem[j];
                nQ += (query[j]||0) ** 2;
                nM += mem[j] ** 2;
            }
            return dot / (Math.sqrt(nQ) * Math.sqrt(nM) + 1e-8);
        });
        const max = Math.max(...sims);
        const exps = sims.map(s => Math.exp((s - max) * 2.5));
        const sum = exps.reduce((a, b) => a + b);
        this.readWeights = exps.map(e => e / sum);
        return Math.max(...this.readWeights);
    }
    
    recordPattern(action) {
        this.patternBuffer.push(action);
        if (this.patternBuffer.length > 20) this.patternBuffer.shift();
        if (this.patternBuffer.length >= 3) {
            const key = this.patternBuffer.slice(-3, -1).join('-');
            const next = this.patternBuffer[this.patternBuffer.length - 1];
            if (!this.patterns[key]) this.patterns[key] = {};
            this.patterns[key][next] = (this.patterns[key][next] || 0) + 1;
        }
    }
    
    predict() {
        if (this.patternBuffer.length < 2) return null;
        const key = this.patternBuffer.slice(-2).join('-');
        const p = this.patterns[key];
        if (!p) return null;
        return Object.entries(p).sort((a,b) => b[1] - a[1])[0]?.[0];
    }
    
    decide(me, enemy, dist) {
        const state = [me.hp/100, me.stamina/100, me.superMeter/100, enemy.hp/100, enemy.stamina/100, dist/300, enemy.isStunned?1:0, me.comboCount/5, enemy.inRage?1:0, me.inRage?1:0];
        this.recordPattern(enemy.lastAction);
        this.write(state);
        const conf = this.read(state);
        const predicted = this.predict();
        
        let action = { type: 'idle', move: 0, thought: '' };
        
        // Super ready
        if (me.superMeter >= 100 && dist < 100) {
            return { type: 'super', move: 0, thought: 'MEMORY OVERLOAD!' };
        }
        
        // Rage mode aggression
        if (me.inRage && dist < 90 && me.stamina > 30) {
            return { type: ['blitz', 'three_piece', 'flying_knee'][Math.floor(Math.random()*3)], move: 0.5, thought: 'RAGE MODE!' };
        }
        
        // Counter predictions
        if (predicted && conf > 0.25 && dist < 100) {
            if (['jab', 'cross'].includes(predicted)) {
                return { type: Math.random() < 0.6 ? 'parry' : 'hook', move: -0.3, thought: `Predicted ${predicted}!` };
            }
            if (['hook', 'overhand'].includes(predicted)) {
                return { type: 'slip', move: 0, thought: 'Slip incoming hook!' };
            }
            if (['kick', 'head_kick'].includes(predicted)) {
                return { type: 'block', move: -0.5, thought: 'Block the kick!' };
            }
        }
        
        // Low stamina
        if (me.stamina < 20) {
            return { type: dist < 60 ? 'clinch' : 'block', move: -0.5, thought: 'Recovering...' };
        }
        
        // Stunned enemy
        if (enemy.isStunned && dist < 85) {
            return { type: 'three_piece', move: 0.5, thought: 'STUNNED! COMBO!' };
        }
        
        // Fighting
        if (dist < 80 && me.stamina > 35) {
            const moves = ['jab', 'hook', 'body_shot', 'one_two', 'elbow', 'knee'];
            action.type = moves[Math.floor(Math.random() * moves.length)];
            action.thought = `Conf: ${(conf*100).toFixed(0)}%`;
        } else if (dist < 120 && me.stamina > 50) {
            const moves = ['kick', 'body_kick', 'cross', 'jab'];
            action.type = moves[Math.floor(Math.random() * moves.length)];
            action.move = 0.5;
        } else if (dist > 130) {
            action.move = 1.5;
            action.type = Math.random() < 0.15 ? 'feint' : 'idle';
            action.thought = 'Closing...';
        } else {
            action.type = Math.random() < 0.2 ? 'jab' : 'idle';
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const grid = document.createElement('div');
        grid.className = 'memory-grid';
        for (let i = 0; i < 32; i++) {
            const cell = document.createElement('div');
            cell.className = 'mem-cell';
            const w = this.readWeights[i];
            const content = Math.sqrt(this.memory[i].reduce((a, b) => a + b*b, 0));
            cell.style.background = `rgb(${Math.floor(255*w)}, ${Math.floor(80*content)}, ${Math.floor(40*w)})`;
            if (i === this.writeHead) cell.style.boxShadow = '0 0 2px #fff';
            grid.appendChild(cell);
        }
        container.appendChild(grid);
    }
}

class TransformerBrain extends BaseBrain {
    constructor() {
        super('transformer');
        this.context = [];
        this.attnWeights = Array(4).fill([]);
    }
    
    decide(me, enemy, dist) {
        const state = [me.hp/100, me.stamina/100, enemy.hp/100, dist/300, Math.random()];
        this.context.push(state);
        if (this.context.length > 8) this.context.shift();
        
        for (let h = 0; h < 4; h++) {
            this.attnWeights[h] = this.context.map(ctx => Math.exp(state.reduce((s, v, j) => s + v * ctx[j] * Math.sin(h + j), 0)));
            const sum = this.attnWeights[h].reduce((a, b) => a + b);
            this.attnWeights[h] = this.attnWeights[h].map(w => w / sum);
        }
        
        let action = { type: 'idle', move: 0, thought: '' };
        
        if (me.superMeter >= 100 && dist < 110) {
            return { type: 'super', move: 0, thought: 'ATTENTION STORM!' };
        }
        
        if (me.inRage) {
            const moves = ['blitz', 'flying_knee', 'spinning_elbow', 'head_kick'];
            return { type: moves[Math.floor(Math.random()*moves.length)], move: 1, thought: 'RAGE ATTACK!' };
        }
        
        // Transformer is AGGRESSIVE
        if (enemy.lastAction && ['jab', 'hook', 'kick'].includes(enemy.lastAction)) {
            return { type: Math.random() < 0.5 ? 'weave' : 'parry', move: 0, thought: 'Quick reaction!' };
        }
        
        if (me.stamina < 25) {
            return { type: Math.random() < 0.3 ? 'taunt' : 'block', move: -0.5, thought: 'Catching breath...' };
        }
        
        if (enemy.isStunned && dist < 90) {
            return { type: 'blitz', move: 0.5, thought: 'ALL HEADS: ATTACK!' };
        }
        
        if (dist < 85 && me.stamina > 30) {
            const moves = ['hook', 'one_two', 'three_piece', 'elbow', 'knee', 'uppercut', 'body_shot'];
            action.type = moves[Math.floor(Math.random() * moves.length)];
            action.thought = 'Full attention!';
        } else if (dist < 130) {
            const moves = ['kick', 'spin_kick', 'head_kick', 'jab'];
            action.type = moves[Math.floor(Math.random() * moves.length)];
            action.move = 1;
        } else {
            action.move = 2;
            action.type = Math.random() < 0.1 ? 'taunt' : 'idle';
            action.thought = 'Rushing!';
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const div = document.createElement('div');
        div.style.cssText = 'display:flex;gap:3px;';
        for (let h = 0; h < 4; h++) {
            const head = document.createElement('div');
            head.style.cssText = 'flex:1;height:30px;background:#1a1a2e;border-radius:2px;position:relative;overflow:hidden;';
            const maxW = this.attnWeights[h]?.length > 0 ? Math.max(...this.attnWeights[h]) : 0;
            const bar = document.createElement('div');
            bar.style.cssText = `position:absolute;bottom:0;left:0;right:0;height:${maxW*100}%;background:hsl(${200+h*40},80%,50%);`;
            head.appendChild(bar);
            div.appendChild(head);
        }
        container.appendChild(div);
    }
}

class LSTMBrain extends BaseBrain {
    constructor() {
        super('lstm');
        this.hidden = Array(16).fill(0);
        this.cell = Array(16).fill(0);
        this.forgetGate = Array(16).fill(0.5);
    }
    
    step(input) {
        for (let i = 0; i < 16; i++) {
            let f = 0, inp = 0, o = 0, c = 0;
            input.forEach((v, j) => {
                f += v * Math.sin(i * 7 + j * 3);
                inp += v * Math.cos(i * 11 + j * 5);
                o += v * Math.sin(i * 13 + j * 7);
                c += v * Math.cos(i * 17 + j * 11);
            });
            const sig = x => 1 / (1 + Math.exp(-Math.max(-10, Math.min(10, x))));
            this.forgetGate[i] = sig(f);
            this.cell[i] = this.forgetGate[i] * this.cell[i] + sig(inp) * Math.tanh(c);
            this.hidden[i] = sig(o) * Math.tanh(this.cell[i]);
        }
    }
    
    decide(me, enemy, dist) {
        this.step([me.hp/100, me.stamina/100, enemy.hp/100, enemy.stamina/100, dist/300, enemy.lastAction==='jab'?1:0, enemy.lastAction==='hook'?1:0, me.superMeter/100]);
        
        let action = { type: 'idle', move: 0, thought: '' };
        const avgForget = this.forgetGate.reduce((a, b) => a + b) / 16;
        
        if (me.superMeter >= 100 && dist < 95) {
            return { type: 'super', move: 0, thought: 'GATE OVERFLOW!' };
        }
        
        // LSTM is patient counter-puncher
        if (enemy.lastAction && ['jab', 'hook', 'cross'].includes(enemy.lastAction) && dist < 95) {
            return { type: enemy.lastAction === 'jab' ? 'cross' : 'uppercut', move: 0, thought: 'Counter!' };
        }
        
        if (enemy.isStunned) {
            return { type: dist < 80 ? 'three_piece' : 'kick', move: 0.5, thought: 'Capitalizing!' };
        }
        
        if (enemy.stamina < 30 && dist < 90) {
            return { type: 'body_shot', move: 0.3, thought: 'Drain their stamina!' };
        }
        
        if (me.stamina < 25) {
            return { type: 'clinch', move: dist > 60 ? 0.5 : 0, thought: 'Need recovery' };
        }
        
        // Maintain distance
        if (dist < 70) {
            action.type = Math.random() < 0.25 ? 'jab' : 'slip';
            action.move = -0.8;
            action.thought = 'Creating space...';
        } else if (dist > 130) {
            action.move = 0.8;
            action.thought = `Forget: ${(avgForget*100).toFixed(0)}%`;
        } else {
            action.type = Math.random() < 0.15 ? 'feint' : Math.random() < 0.2 ? 'jab' : 'idle';
            action.thought = 'Waiting for opening...';
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        const sig = x => 1 / (1 + Math.exp(-x));
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const act = sig(this.hidden[i]);
            n.style.background = `rgb(${Math.floor(100+155*this.forgetGate[i])},${Math.floor(200*act)},${Math.floor(100*(1-this.forgetGate[i]))})`;
            neurons.appendChild(n);
        }
        container.appendChild(neurons);
    }
}

class MLPBrain extends BaseBrain {
    constructor() {
        super('mlp');
        this.activations = Array(16).fill(0);
    }
    
    forward(input) {
        for (let i = 0; i < 16; i++) {
            let sum = input.reduce((s, v, j) => s + v * Math.sin(i * 17 + j * 31), 0);
            this.activations[i] = Math.max(0, sum);
        }
    }
    
    decide(me, enemy, dist) {
        this.forward([me.hp/100, me.stamina/100, enemy.hp/100, dist/300, me.superMeter/100, Math.random()]);
        
        let action = { type: 'idle', move: 0, thought: '' };
        const active = this.activations.filter(a => a > 0).length;
        
        if (me.superMeter >= 100 && dist < 100) {
            return { type: 'super', move: 0, thought: 'GRADIENT BOMB!' };
        }
        
        // MLP is simple and predictable
        if (dist < 75) {
            const sum = this.activations.reduce((a, b) => a + b, 0);
            if (sum > 2) action.type = 'hook';
            else if (sum > 1) action.type = 'jab';
            else action.type = 'block';
            action.thought = `${active}/16 ReLU`;
        } else if (dist < 120) {
            action.type = Math.random() < 0.4 ? 'kick' : 'jab';
            action.move = 0.5;
        } else {
            action.move = 1.2;
            action.thought = 'Feedforward approach';
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const act = Math.min(1, this.activations[i] / 2);
            n.style.background = act > 0 ? `rgb(${Math.floor(255*act)},${Math.floor(170*act)},0)` : '#1a1a1a';
            neurons.appendChild(n);
        }
        container.appendChild(neurons);
    }
}

class CNNBrain extends BaseBrain {
    constructor() {
        super('cnn');
        this.features = Array(16).fill(0);
        this.posHistory = [];
    }
    
    decide(me, enemy, dist) {
        this.posHistory.push(enemy.x || 250);
        if (this.posHistory.length > 10) this.posHistory.shift();
        
        // Convolution
        const kernels = [[1, -1], [1, 0, -1], [1, 2, 1]];
        let idx = 0;
        kernels.forEach(k => {
            let sum = 0;
            for (let i = 0; i < k.length && i < this.posHistory.length; i++) {
                sum += (this.posHistory[this.posHistory.length - 1 - i] || 0) * k[i];
            }
            this.features[idx++] = Math.max(0, sum / 100);
        });
        
        let action = { type: 'idle', move: 0, thought: '' };
        
        if (me.superMeter >= 100 && dist < 100) {
            return { type: 'super', move: 0, thought: 'KERNEL CRUSH!' };
        }
        
        const movingLeft = this.features[0] > 0.3;
        const movingRight = this.features[0] < -0.3;
        
        if (enemy.isStunned && dist < 85) {
            return { type: 'three_piece', move: 0.5, thought: 'Pattern: STUNNED!' };
        }
        
        if (dist < 80) {
            if (movingLeft) {
                action.type = 'hook';
                action.move = -0.3;
                action.thought = 'Detected left!';
            } else if (movingRight) {
                action.type = 'cross';
                action.move = 0.3;
                action.thought = 'Detected right!';
            } else {
                action.type = Math.random() < 0.4 ? 'jab' : 'body_shot';
                action.thought = 'Scanning...';
            }
        } else {
            action.move = 1.2;
            action.thought = 'Analyzing...';
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const grid = document.createElement('div');
        grid.style.cssText = 'display:grid;grid-template-columns:repeat(4,1fr);gap:1px;';
        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            cell.style.cssText = `width:12px;height:12px;border-radius:2px;background:rgb(0,${Math.floor(200*Math.min(1,this.features[i]))},${Math.floor(150*Math.min(1,this.features[i]))});`;
            grid.appendChild(cell);
        }
        container.appendChild(grid);
    }
}

class GANBrain extends BaseBrain {
    constructor() {
        super('gan');
        this.genState = Array(8).fill(0);
        this.discState = Array(8).fill(0);
        this.fakeoutMode = false;
    }
    
    decide(me, enemy, dist) {
        this.genState = this.genState.map(() => Math.random());
        this.discState = [me.hp/100, enemy.hp/100, dist/300, me.stamina/100, ...Array(4).fill(0).map(() => Math.random())];
        
        let action = { type: 'idle', move: 0, thought: '' };
        
        if (me.superMeter >= 100 && dist < 100) {
            return { type: 'super', move: 0, thought: 'MODE COLLAPSE!' };
        }
        
        // GAN is deceptive
        if (Math.random() < 0.12) {
            this.fakeoutMode = true;
            return { type: 'taunt', move: 0, thought: 'Generating fakes...' };
        }
        
        if (this.fakeoutMode && dist < 90) {
            this.fakeoutMode = false;
            return { type: Math.random() < 0.5 ? 'spinning_elbow' : 'flying_knee', move: 0.5, thought: 'SURPRISE!' };
        }
        
        if (enemy.isStunned) {
            return { type: 'blitz', move: 0.5, thought: 'Discriminator: ATTACK!' };
        }
        
        if (dist < 80) {
            const moves = ['jab', 'hook', 'body_shot', 'slip', 'feint', 'elbow'];
            action.type = moves[Math.floor(Math.random() * moves.length)];
            action.thought = 'Generator mixing...';
        } else {
            action.move = 1;
            action.type = Math.random() < 0.15 ? 'taunt' : 'idle';
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const div = document.createElement('div');
        div.style.cssText = 'display:flex;gap:3px;';
        
        const gen = document.createElement('div');
        gen.style.cssText = 'flex:1;display:flex;flex-wrap:wrap;gap:1px;';
        for (let i = 0; i < 8; i++) {
            const n = document.createElement('div');
            n.style.cssText = `width:7px;height:7px;border-radius:50%;background:rgb(${Math.floor(255*this.genState[i])},50,${Math.floor(200*this.genState[i])});`;
            gen.appendChild(n);
        }
        
        const disc = document.createElement('div');
        disc.style.cssText = 'flex:1;display:flex;flex-wrap:wrap;gap:1px;';
        for (let i = 0; i < 8; i++) {
            const n = document.createElement('div');
            n.style.cssText = `width:7px;height:7px;border-radius:50%;background:rgb(50,${Math.floor(200*this.discState[i])},${Math.floor(255*this.discState[i])});`;
            disc.appendChild(n);
        }
        
        div.appendChild(gen);
        div.appendChild(disc);
        container.appendChild(div);
    }
}

class MambaBrain extends BaseBrain {
    constructor() {
        super('mamba');
        this.state = Array(16).fill(0);
        this.selectivity = Array(16).fill(0.5);
    }
    
    decide(me, enemy, dist) {
        // SSM-style state update
        const input = [me.hp/100, me.stamina/100, enemy.hp/100, dist/300, me.superMeter/100];
        for (let i = 0; i < 16; i++) {
            this.selectivity[i] = 1 / (1 + Math.exp(-input[i % input.length] * Math.sin(i * 7)));
            this.state[i] = this.state[i] * (1 - this.selectivity[i]) + input[i % input.length] * this.selectivity[i];
        }
        
        let action = { type: 'idle', move: 0, thought: '' };
        
        if (me.superMeter >= 100 && dist < 100) {
            return { type: 'super', move: 0, thought: 'SELECTIVE SCAN!' };
        }
        
        const avgState = this.state.reduce((a, b) => a + Math.abs(b), 0) / 16;
        
        if (me.inRage) {
            return { type: 'blitz', move: 1, thought: 'MAMBA MODE!' };
        }
        
        if (enemy.isStunned && dist < 85) {
            return { type: 'three_piece', move: 0.5, thought: 'State: ATTACK!' };
        }
        
        if (dist < 80 && me.stamina > 30) {
            const moves = ['jab', 'hook', 'one_two', 'elbow', 'knee', 'body_shot'];
            action.type = moves[Math.floor(Math.random() * moves.length)];
            action.thought = `State: ${avgState.toFixed(2)}`;
        } else if (dist < 130) {
            action.type = Math.random() < 0.3 ? 'kick' : 'jab';
            action.move = 1;
        } else {
            action.move = 1.5;
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const s = Math.abs(this.state[i]);
            const sel = this.selectivity[i];
            n.style.background = `rgb(${Math.floor(100*sel)},${Math.floor(255*s)},${Math.floor(100*s)})`;
            neurons.appendChild(n);
        }
        container.appendChild(neurons);
    }
}

class RWKVBrain extends BaseBrain {
    constructor() {
        super('rwkv');
        this.state = Array(16).fill(0);
        this.wkv = Array(16).fill(0);
    }
    
    decide(me, enemy, dist) {
        const input = [me.hp/100, me.stamina/100, enemy.hp/100, dist/300];
        for (let i = 0; i < 16; i++) {
            const w = Math.exp(-Math.abs(input[i % input.length] - 0.5));
            const k = input[i % input.length] * Math.sin(i);
            const v = input[(i + 1) % input.length];
            this.wkv[i] = this.wkv[i] * 0.9 + w * k * v;
            this.state[i] = Math.tanh(this.wkv[i]);
        }
        
        let action = { type: 'idle', move: 0, thought: '' };
        
        if (me.superMeter >= 100 && dist < 100) {
            return { type: 'super', move: 0, thought: 'RECEPTANCE WAVE!' };
        }
        
        const avgWKV = this.wkv.reduce((a, b) => a + Math.abs(b), 0) / 16;
        
        if (enemy.isStunned && dist < 85) {
            return { type: 'blitz', move: 0.5, thought: 'WKV: ATTACK!' };
        }
        
        if (dist < 80 && me.stamina > 30) {
            const moves = ['jab', 'cross', 'hook', 'body_kick', 'one_two'];
            action.type = moves[Math.floor(Math.random() * moves.length)];
            action.thought = `WKV: ${avgWKV.toFixed(2)}`;
        } else if (dist < 130) {
            action.type = Math.random() < 0.35 ? 'kick' : 'jab';
            action.move = 1;
        } else {
            action.move = 1.3;
        }
        
        return action;
    }
    
    renderBrain(container) {
        container.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const s = (this.state[i] + 1) / 2;
            n.style.background = `rgb(${Math.floor(100*s)},${Math.floor(255*s)},${Math.floor(255*s)})`;
            neurons.appendChild(n);
        }
        container.appendChild(neurons);
    }
}

const BRAINS = { tntm: TNTMBrain, transformer: TransformerBrain, lstm: LSTMBrain, mlp: MLPBrain, cnn: CNNBrain, gan: GANBrain, mamba: MambaBrain, rwkv: RWKVBrain };

// =============================================
// GAME ENGINE
// =============================================

let boxers = [];
let running = false;
let speed = 1;
let round = 1;
let roundTime = 0;
let maxRoundTime = 180;
let scores = [0, 0];
let fightLog = [];
let crowdHype = 0;

function log(msg, type = '') {
    fightLog.unshift({ msg, type, time: Date.now() });
    if (fightLog.length > 50) fightLog.pop();
    const el = document.getElementById('fight-log');
    el.innerHTML = fightLog.slice(0, 10).map(l => `<div class="${l.type}">${l.msg}</div>`).join('');
}

function comment(text) {
    document.getElementById('commentary-text').textContent = text;
}

function showEffect(x, y, type, text, extra = '') {
    const el = document.createElement('div');
    el.className = `effect ${type} ${extra}`;
    el.textContent = text;
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
    document.getElementById('ring').appendChild(el);
    setTimeout(() => el.remove(), type === 'taunt-bubble' ? 2000 : 700);
}

function hypeCrowd(amount = 1) {
    crowdHype = Math.min(10, crowdHype + amount);
    const crowd = document.getElementById('crowd');
    const emojis = ['üë•', 'üôå', 'üò±', 'üî•', 'üí•'];
    const hypeEmoji = emojis[Math.min(emojis.length - 1, Math.floor(crowdHype / 2))];
    crowd.textContent = hypeEmoji.repeat(10);
    if (crowdHype > 5) crowd.classList.add('hyped');
    else crowd.classList.remove('hyped');
}

function createBoxer(id, type) {
    const info = FIGHTERS[type];
    const BrainClass = BRAINS[type];
    return {
        id, type,
        brain: new BrainClass(),
        info,
        hp: 100, maxHp: 100,
        stamina: 100, maxStamina: 100,
        superMeter: 0,
        rageMeter: 0,
        inRage: false,
        x: id === 1 ? 120 : 400,
        action: 'idle',
        lastAction: null,
        actionTimer: 0,
        comboCount: 0,
        comboTimer: 0,
        hits: 0,
        knockdowns: 0,
        isDown: false,
        downTimer: 0,
        isStunned: false,
        stunTimer: 0,
        isBleeding: false,
        bleedTimer: 0
    };
}

function initFighterSelects() {
    [1, 2].forEach(slot => {
        const container = document.getElementById(`select${slot}`);
        container.innerHTML = '';
        Object.entries(FIGHTERS).forEach(([type, info]) => {
            const opt = document.createElement('div');
            opt.className = 'fighter-option' + (slot === 1 && type === 'tntm' ? ' selected' : '') + (slot === 2 && type === 'transformer' ? ' selected' : '');
            opt.dataset.type = type;
            opt.innerHTML = `<div class="icon">${info.icon}</div><div class="name">${info.name}</div>`;
            opt.onclick = () => selectFighter(slot, type);
            container.appendChild(opt);
        });
    });
}

function selectFighter(slot, type) {
    document.querySelectorAll(`#select${slot} .fighter-option`).forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.type === type);
    });
    
    boxers[slot - 1] = createBoxer(slot, type);
    const b = boxers[slot - 1];
    const info = b.info;
    
    document.getElementById(`name${slot}`).textContent = info.name;
    document.getElementById(`style${slot}`).textContent = info.style;
    document.getElementById(`icon${slot}`).textContent = info.icon;
    document.getElementById(`brain${slot}-title`).textContent = info.brainTitle;
    document.getElementById(`boxer${slot}`).querySelector('.boxer-head').innerHTML = info.icon + `<span class="injury-indicator" id="injury${slot}"></span>`;
    
    updateUI();
    renderBrains();
}

function processAction(attacker, defender) {
    if (attacker.isDown || (attacker.isStunned && attacker.stunTimer > 0) || attacker.actionTimer > 0) return;
    if (attacker.stamina < 3) return;
    
    const dist = Math.abs(attacker.x - defender.x);
    const decision = attacker.brain.decide(attacker, defender, dist);
    
    // Thought bubble
    const thought = document.getElementById(`thought${attacker.id}`);
    thought.textContent = decision.thought || '';
    thought.classList.toggle('visible', !!decision.thought);
    
    // Movement
    let move = (decision.move || 0) * speed * 2;
    if (attacker.id === 2) move = -move;
    attacker.x = Math.max(45, Math.min(475, attacker.x + move));
    
    const actionType = decision.type || 'idle';
    if (actionType === 'idle') return;
    
    const moveData = MOVES[actionType];
    if (!moveData) return;
    
    // Stamina check
    const stamCost = moveData.stam || 0;
    if (attacker.stamina < Math.abs(stamCost)) return;
    
    attacker.stamina = Math.max(0, attacker.stamina - stamCost);
    attacker.action = actionType;
    attacker.lastAction = actionType;
    attacker.actionTimer = (moveData.speed || 15) / speed;
    
    // Super/rage gains
    if (moveData.superGain) attacker.superMeter = Math.min(100, attacker.superMeter + moveData.superGain);
    if (moveData.rageGain) attacker.rageMeter = Math.min(100, attacker.rageMeter + moveData.rageGain);
    
    // Taunt
    if (actionType === 'taunt') {
        const tauntList = TAUNTS[attacker.type] || TAUNTS.mlp;
        const taunt = tauntList[Math.floor(Math.random() * tauntList.length)];
        showEffect(attacker.x, 80, 'taunt-bubble', taunt);
        comment(`${attacker.info.name} TAUNTS: "${taunt}"`);
        log(`${attacker.info.name} taunts!`, attacker.id === 1 ? 'red' : 'blue');
        hypeCrowd(0.5);
        return;
    }
    
    // Feint
    if (actionType === 'feint') {
        log(`${attacker.info.name} feints`, attacker.id === 1 ? 'red' : 'blue');
        return;
    }
    
    // Clinch
    if (actionType === 'clinch' && dist < (moveData.range || 60)) {
        attacker.stamina = Math.min(attacker.maxStamina, attacker.stamina + 12);
        defender.actionTimer = Math.max(defender.actionTimer, 20);
        log(`${attacker.info.name} clinches`, attacker.id === 1 ? 'red' : 'blue');
        return;
    }
    
    // Attack
    if (!moveData.dmg) return;
    if (dist > (moveData.range || 80)) {
        if (Math.random() < 0.1) log(`${attacker.info.name} misses ${actionType}`, attacker.id === 1 ? 'red' : 'blue');
        return;
    }
    
    // Defense check
    let damage = moveData.dmg[0] + Math.random() * (moveData.dmg[1] - moveData.dmg[0]);
    let blocked = false, parried = false, dodged = false;
    
    if (defender.action === 'block' && defender.actionTimer > 0) {
        damage *= 0.2;
        blocked = true;
        showEffect(defender.x, 90, 'punch-effect', 'üõ°Ô∏è');
        if (Math.random() < 0.2) comment(`${defender.info.name} blocks!`);
    } else if (defender.action === 'parry' && defender.actionTimer > 0) {
        damage = 0;
        parried = true;
        showEffect(defender.x, 80, 'punch-effect', '‚ú®');
        attacker.isStunned = true;
        attacker.stunTimer = 25;
        defender.superMeter = Math.min(100, defender.superMeter + 15);
        comment(`PERFECT PARRY by ${defender.info.name}!`);
        log(`${defender.info.name} PARRIES!`, 'crit');
        hypeCrowd(2);
    } else if (['slip', 'weave', 'dodge'].includes(defender.action) && defender.actionTimer > 0) {
        if (Math.random() < (defender.action === 'dodge' ? 0.75 : 0.6)) {
            damage = 0;
            dodged = true;
            showEffect(defender.x, 80, 'punch-effect', 'üí®');
            if (Math.random() < 0.2) comment(`${defender.info.name} slips away!`);
        } else {
            damage *= 0.5;
        }
    }
    
    if (parried || dodged) {
        attacker.comboCount = 0;
        attacker.comboTimer = 0;
        return;
    }
    
    // Rage bonus
    if (attacker.inRage) damage *= 1.3;
    
    // Combo bonus
    if (attacker.comboTimer > 0) {
        attacker.comboCount++;
        damage *= (1 + attacker.comboCount * 0.08);
    } else {
        attacker.comboCount = 1;
    }
    attacker.comboTimer = 60;
    
    // Apply damage
    defender.hp -= damage;
    attacker.hits++;
    attacker.superMeter = Math.min(100, attacker.superMeter + damage * 0.6);
    defender.rageMeter = Math.min(100, defender.rageMeter + damage * 0.8);
    
    // Stamina drain
    if (moveData.drainStam) defender.stamina = Math.max(0, defender.stamina - moveData.drainStam);
    
    // Effects
    const effects = { jab: 'üí•', cross: '‚ú®', hook: 'üí´', uppercut: '‚≠ê', body_shot: 'üí®', overhand: 'üí¢', elbow: 'üî•', spinning_elbow: 'üåÄ', knee: 'ü¶µ', flying_knee: 'üöÄ', kick: 'ü¶∂', body_kick: 'üí®', head_kick: 'üíÄ', spin_kick: 'üå™Ô∏è', sweep: 'üåä', one_two: 'üí•üí•', three_piece: 'üí•üí•üí•', blitz: 'üî•üî•üî•üî•', super: 'üíÄ' };
    showEffect(defender.x, 75, 'punch-effect', effects[actionType] || 'üí•');
    showEffect(defender.x + 15, 55, 'damage-text', `-${Math.floor(damage)}`, damage > 20 ? 'crit' : '');
    
    if (attacker.comboCount >= 3) {
        showEffect(250, 120, 'combo-text', `${attacker.comboCount}x COMBO!`);
        hypeCrowd(attacker.comboCount * 0.3);
    }
    
    // Hit animation
    const defEl = document.getElementById(`boxer${defender.id}`);
    defEl.classList.add('hit');
    setTimeout(() => defEl.classList.remove('hit'), 150);
    
    // Super attack
    if (actionType === 'super') {
        attacker.superMeter = 0;
        defender.isStunned = true;
        defender.stunTimer = 40;
        showEffect(defender.x, 60, 'super-effect', 'üíÄ');
        comment(`${attacker.info.name}'s ${attacker.info.superName}! DEVASTATING!`);
        log(`${attacker.info.name}'s ${attacker.info.superName}!`, 'crit');
        hypeCrowd(4);
    }
    
    // Cut chance
    if (moveData.cutChance && Math.random() < moveData.cutChance) {
        defender.isBleeding = true;
        defender.bleedTimer = 200;
        showEffect(defender.x, 50, 'blood-effect', 'ü©∏ü©∏');
        comment(`${defender.info.name} is CUT!`);
        log(`${defender.info.name} is bleeding!`, 'ko');
    }
    
    // Knockdown check
    let kdChance = (moveData.knockdownBonus || 0) + (defender.hp < 25 ? 0.15 : 0) + (damage > 20 ? 0.1 : 0);
    if (defender.hp < 15) kdChance += 0.2;
    
    if (Math.random() < kdChance) {
        defender.isDown = true;
        defender.downTimer = 100;
        defender.knockdowns++;
        attacker.comboCount = 0;
        comment(`${defender.info.name} IS DOWN! Can they beat the count?!`);
        log(`${defender.info.name} KNOCKED DOWN!`, 'ko');
        hypeCrowd(5);
    } else {
        // Regular commentary
        if (Math.random() < 0.25 && !blocked) {
            const phrases = [
                `${attacker.info.name} lands a ${actionType}!`,
                `${actionType.toUpperCase()} connects!`,
                `${defender.info.name} eats a ${actionType}!`,
                `Solid ${actionType} from ${attacker.info.name}!`
            ];
            comment(phrases[Math.floor(Math.random() * phrases.length)]);
        }
    }
    
    log(`${attacker.info.name} ${actionType} (-${Math.floor(damage)})`, attacker.id === 1 ? 'red' : 'blue');
}

function updateBoxer(b) {
    if (b.actionTimer > 0) b.actionTimer -= speed;
    if (b.actionTimer <= 0 && b.action !== 'idle') b.action = 'idle';
    
    if (b.isDown) {
        b.downTimer -= speed;
        if (b.downTimer <= 0) {
            b.isDown = false;
            b.hp = Math.max(b.hp, 15);
            b.isStunned = true;
            b.stunTimer = 25;
        }
    }
    
    if (b.isStunned) {
        b.stunTimer -= speed;
        if (b.stunTimer <= 0) b.isStunned = false;
    }
    
    if (b.isBleeding) {
        b.bleedTimer -= speed;
        b.hp -= 0.02 * speed;
        if (b.bleedTimer <= 0) b.isBleeding = false;
    }
    
    // Stamina recovery
    if (b.action === 'idle' && !b.isDown) {
        b.stamina = Math.min(b.maxStamina, b.stamina + 0.3 * speed);
    }
    
    // Combo decay
    if (b.comboTimer > 0) {
        b.comboTimer -= speed;
        if (b.comboTimer <= 0) b.comboCount = 0;
    }
    
    // Rage activation
    if (!b.inRage && b.rageMeter >= 100 && b.hp < 35) {
        b.inRage = true;
        b.rageMeter = 100;
        comment(`${b.info.name} enters RAGE MODE!`);
        log(`${b.info.name} RAGE MODE!`, 'crit');
        hypeCrowd(3);
    }
    if (b.inRage) {
        b.rageMeter -= 0.15 * speed;
        if (b.rageMeter <= 0) {
            b.inRage = false;
            b.rageMeter = 0;
        }
    }
    
    // Crowd hype decay
    crowdHype = Math.max(0, crowdHype - 0.01 * speed);
}

function renderBoxers() {
    boxers.forEach((b, i) => {
        const el = document.getElementById(`boxer${i + 1}`);
        el.style.left = `${b.x - 37}px`;
        
        // Clear classes
        el.className = `boxer ${i === 0 ? 'red' : 'blue'}`;
        
        if (b.inRage) el.classList.add('rage');
        if (b.action === 'super' && b.actionTimer > 20) el.classList.add('super-charging');
        
        if (b.isDown) el.classList.add('knocked-down');
        else if (b.isStunned) el.classList.add('stunned');
        else {
            const actionMap = {
                'jab': 'jabbing', 'cross': 'crossing', 'hook': 'hooking', 'uppercut': 'uppercutting',
                'body_shot': 'body-shotting', 'overhand': 'hooking', 'elbow': 'elbowing',
                'spinning_elbow': 'spinning-elbow', 'knee': 'knee-striking', 'flying_knee': 'flying-knee',
                'kick': 'kicking', 'body_kick': 'kicking', 'head_kick': 'kicking',
                'spin_kick': 'spin-kicking', 'sweep': 'sweeping',
                'one_two': 'jabbing', 'three_piece': 'hooking', 'blitz': 'hooking',
                'block': 'blocking', 'parry': 'parrying', 'slip': 'weaving', 'weave': 'weaving', 'dodge': 'dodging',
                'clinch': 'clinching', 'taunt': 'taunting', 'feint': 'feinting', 'super': 'super-attacking'
            };
            if (actionMap[b.action]) el.classList.add(actionMap[b.action]);
        }
        
        if (i === 1) el.style.transform = 'scaleX(-1)';
        
        // Injury indicator
        const injury = document.getElementById(`injury${i + 1}`);
        injury.textContent = b.isBleeding ? 'ü©∏' : '';
    });
}

function renderBrains() {
    boxers.forEach((b, i) => b.brain.renderBrain(document.getElementById(`brain${i + 1}`)));
}

function updateUI() {
    boxers.forEach((b, i) => {
        const n = i + 1;
        const hpPct = Math.max(0, b.hp) / b.maxHp * 100;
        
        document.getElementById(`hp${n}`).style.width = `${hpPct}%`;
        document.getElementById(`hp${n}`).classList.toggle('low', hpPct < 30);
        document.getElementById(`hp${n}-text`).textContent = Math.floor(Math.max(0, b.hp));
        
        document.getElementById(`stam${n}`).style.width = `${Math.max(0, b.stamina)}%`;
        document.getElementById(`stam${n}-text`).textContent = Math.floor(Math.max(0, b.stamina));
        
        document.getElementById(`super${n}`).style.width = `${b.superMeter}%`;
        document.getElementById(`super${n}-text`).textContent = `${Math.floor(b.superMeter)}%`;
        
        document.getElementById(`rage${n}`).style.width = `${b.rageMeter}%`;
        document.getElementById(`rage${n}-text`).textContent = `${Math.floor(b.rageMeter)}%`;
        
        document.getElementById(`hits${n}`).textContent = b.hits;
        document.getElementById(`combo${n}`).textContent = b.comboCount;
        document.getElementById(`kd${n}`).textContent = b.knockdowns;
        
        // Status effects
        const status = document.getElementById(`status${n}`);
        status.innerHTML = '';
        if (b.inRage) status.innerHTML += '<span class="status-effect rage">üî• RAGE</span>';
        if (b.isStunned) status.innerHTML += '<span class="status-effect stunned">üí´ STUNNED</span>';
        if (b.isBleeding) status.innerHTML += '<span class="status-effect bleeding">ü©∏ CUT</span>';
        if (b.stamina < 20) status.innerHTML += '<span class="status-effect exhausted">üòÆ‚Äçüí® TIRED</span>';
        if (b.comboCount >= 3) status.innerHTML += `<span class="status-effect combo">${b.comboCount}x</span>`;
        
        // Corner advice
        let advice = CORNER_ADVICE[Math.floor(Math.random() * CORNER_ADVICE.length)];
        if (b.hp < 30) advice = "You're hurt, be careful!";
        if (b.stamina < 20) advice = "Conserve energy!";
        if (b.superMeter >= 100) advice = "SUPER IS READY! USE IT!";
        if (b.inRage) advice = "RAGE MODE! GO ALL OUT!";
        document.getElementById(`advice${n}-text`).textContent = advice;
    });
    
    document.getElementById('score1').textContent = scores[0];
    document.getElementById('score2').textContent = scores[1];
    document.getElementById('round-display').textContent = `R${round}`;
    
    const timeLeft = Math.max(0, maxRoundTime - roundTime);
    const mins = Math.floor(timeLeft / 60);
    const secs = Math.floor(timeLeft % 60);
    document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
}

function checkRoundEnd() {
    // KO check
    for (let i = 0; i < 2; i++) {
        if (boxers[i].hp <= 0) {
            running = false;
            scores[1 - i]++;
            document.getElementById('ko-banner').classList.add('visible');
            comment(`K.O.! ${boxers[1 - i].info.name} WINS!`);
            log(`${boxers[1 - i].info.name} WINS BY KO!`, 'ko');
            document.getElementById('btn-fight').textContent = 'üîî NEW';
            return true;
        }
    }
    
    // Round time
    roundTime += 0.016 * speed;
    if (roundTime >= maxRoundTime) {
        // Score round
        const dmg0 = boxers[0].hits + boxers[0].knockdowns * 3;
        const dmg1 = boxers[1].hits + boxers[1].knockdowns * 3;
        if (dmg0 > dmg1 + 2) scores[0]++;
        else if (dmg1 > dmg0 + 2) scores[1]++;
        
        round++;
        roundTime = 0;
        
        if (round > 12) {
            running = false;
            const winner = scores[0] > scores[1] ? boxers[0] : scores[1] > scores[0] ? boxers[1] : null;
            comment(winner ? `DECISION! ${winner.info.name} wins ${Math.max(scores[0], scores[1])}-${Math.min(scores[0], scores[1])}!` : 'DRAW!');
            document.getElementById('btn-fight').textContent = 'üîî NEW';
            return true;
        }
        
        // Reset for new round
        boxers.forEach(b => {
            b.hp = Math.min(b.maxHp, b.hp + 15);
            b.stamina = b.maxStamina;
            b.x = b.id === 1 ? 120 : 400;
            b.action = 'idle';
            b.actionTimer = 0;
            b.isDown = false;
            b.isStunned = false;
        });
        
        document.getElementById('round-banner').textContent = `ROUND ${round}`;
        document.getElementById('round-banner').classList.add('visible');
        setTimeout(() => document.getElementById('round-banner').classList.remove('visible'), 1800);
        comment(`ROUND ${round}! FIGHT!`);
    }
    
    return false;
}

function gameLoop() {
    if (!running) return;
    
    processAction(boxers[0], boxers[1]);
    processAction(boxers[1], boxers[0]);
    
    boxers.forEach(updateBoxer);
    
    renderBoxers();
    renderBrains();
    updateUI();
    
    if (!checkRoundEnd()) requestAnimationFrame(gameLoop);
}

function toggleFight() {
    if (boxers.some(b => b.hp <= 0) || round > 12) {
        resetFight();
        return;
    }
    
    running = !running;
    document.getElementById('btn-fight').textContent = running ? '‚è∏ PAUSE' : 'üîî FIGHT';
    
    if (running) {
        if (roundTime === 0 && round === 1) {
            document.getElementById('round-banner').textContent = 'ROUND 1';
            document.getElementById('round-banner').classList.add('visible');
            setTimeout(() => document.getElementById('round-banner').classList.remove('visible'), 1800);
            comment(`${boxers[0].info.name} vs ${boxers[1].info.name}! FIGHT!`);
        }
        requestAnimationFrame(gameLoop);
    }
}

function resetFight() {
    running = false;
    round = 1;
    roundTime = 0;
    scores = [0, 0];
    fightLog = [];
    crowdHype = 0;
    
    document.getElementById('ko-banner').classList.remove('visible');
    document.getElementById('btn-fight').textContent = 'üîî FIGHT';
    document.getElementById('fight-log').innerHTML = '';
    
    const type1 = document.querySelector('#select1 .selected')?.dataset.type || 'tntm';
    const type2 = document.querySelector('#select2 .selected')?.dataset.type || 'transformer';
    
    boxers = [createBoxer(1, type1), createBoxer(2, type2)];
    
    renderBoxers();
    renderBrains();
    updateUI();
    
    comment(`${boxers[0].info.name} (${boxers[0].info.style}) vs ${boxers[1].info.name} (${boxers[1].info.style})!`);
}

function setSpeed(s) {
    speed = s;
    document.querySelectorAll('.controls button').forEach(btn => {
        if (btn.textContent.includes('x')) btn.classList.toggle('active', btn.textContent === `${s}x`);
    });
}

// Init
initFighterSelects();
boxers = [createBoxer(1, 'tntm'), createBoxer(2, 'transformer')];
renderBoxers();
renderBrains();
updateUI();
</script>
</body>
</html>
