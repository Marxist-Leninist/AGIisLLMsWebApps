<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Arena - AGI Team Deathmatch</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #hud { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 14px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        #health { color: #f44; }
        #ammo { color: #4af; }
        #neuralInfo { position: absolute; top: 20px; left: 20px; color: #0ff; font-size: 10px; max-width: 260px; background: rgba(0,0,0,0.85); padding: 8px; border: 1px solid #0ff; }
        .tf-col { color: #ff0; }
        .mb-col { color: #0f0; }
        .rw-col { color: #f0f; }
        #teamScores { position: absolute; top: 20px; right: 180px; color: #fff; font-size: 11px; background: rgba(0,0,0,0.85); padding: 8px; border: 1px solid #fff; }
        #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 26px; text-align: center; text-shadow: 2px 2px 8px rgba(0,0,0,0.9); pointer-events: none; display: none; }
        #startScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; }
        #startScreen h1 { font-size: 36px; margin-bottom: 8px; background: linear-gradient(90deg, #ff0, #0ff, #f0f); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #startScreen p { font-size: 12px; margin: 4px 0; color: #aaa; }
        .controls { margin-top: 12px; text-align: left; background: rgba(255,255,255,0.05); padding: 10px 16px; border-radius: 4px; font-size: 11px; }
        .btn-group { display: flex; gap: 12px; margin-top: 16px; }
        .game-btn { padding: 10px 28px; font-size: 15px; background: linear-gradient(135deg, #0aa, #066); color: #fff; border: none; cursor: pointer; font-family: inherit; }
        .game-btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        .game-btn.secondary { background: linear-gradient(135deg, #555, #333); }
        #minimap { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.7); border: 2px solid #0f0; }
        .damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%); opacity: 0; transition: opacity 0.1s; }
        #saveNotice { position: absolute; bottom: 100px; left: 20px; color: #0f0; font-size: 14px; opacity: 0; transition: opacity 0.3s; }
        #pauseMenu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; justify-content: center; align-items: center; color: #fff; }
        #pauseMenu h2 { font-size: 30px; margin-bottom: 20px; }
        #pauseMenu button { margin: 6px; padding: 10px 30px; font-size: 15px; background: #444; color: #fff; border: none; cursor: pointer; font-family: inherit; }
        #pauseMenu button:hover { background: #666; }
        .legend { display: flex; gap: 12px; margin: 10px 0; font-size: 10px; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; }
        #killFeed { position: absolute; top: 180px; right: 20px; font-size: 10px; text-align: right; width: 180px; }
        .kill-entry { padding: 2px 5px; margin: 2px 0; background: rgba(0,0,0,0.6); animation: fadeOut 5s forwards; }
        @keyframes fadeOut { 0%, 80% { opacity: 1; } 100% { opacity: 0; } }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div id="health">HEALTH: 100</div>
            <div id="ammo">AMMO: 50 / 250</div>
            <div id="kills">KILLS: 0</div>
            <div id="round">ROUND: 1</div>
            <div id="fireMode">MODE: AUTO [V]</div>
        </div>
        <div id="neuralInfo"><b>⚡ AGI NEURAL NETS</b><div id="nnStatus"></div></div>
        <div id="teamScores"><b>TEAM KILLS</b><div id="teamScoreList"></div></div>
        <canvas id="minimap"></canvas>
        <div id="killFeed"></div>
        <div id="message"></div>
        <div class="damage-overlay" id="damageOverlay"></div>
        <div id="saveNotice">SAVED</div>
        
        <div id="startScreen">
            <h1>NEURAL ARENA</h1>
            <p style="color:#888;font-size:11px;margin-bottom:10px;">AGI Team Deathmatch — Three architectures battle</p>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#dd0;"></div>Transformer</div>
                <div class="legend-item"><div class="legend-color" style="background:#0d0;"></div>Mamba</div>
                <div class="legend-item"><div class="legend-color" style="background:#d0d;"></div>RWKV</div>
            </div>
            <div class="controls">
                <p><b>WASD</b> - Move | <b>SHIFT</b> - Sprint | <b>MOUSE</b> - Look</p>
                <p><b>CLICK</b> - Shoot | <b>V</b> - Fire mode | <b>R</b> - Reload</p>
                <p><b>ESC</b> - Pause | <b>F5</b> - Save | <b>F9</b> - Load</p>
            </div>
            <p style="margin-top:10px;color:#0ff;font-size:9px;max-width:400px;text-align:center;">
                <b>Transformer:</b> Self-attention O(n²) | <b>Mamba:</b> Selective SSM O(n) | <b>RWKV:</b> Linear attention RNN O(n)<br>
                Teams fight each other AND you. They have guns. They learn.
            </p>
            <div class="btn-group">
                <button class="game-btn" id="startBtn">NEW GAME</button>
                <button class="game-btn secondary" id="loadBtn">LOAD</button>
            </div>
        </div>
        
        <div id="pauseMenu">
            <h2>PAUSED</h2>
            <button id="resumeBtn">RESUME</button>
            <button id="saveBtn">SAVE</button>
            <button id="quitBtn">QUIT</button>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    minimapCanvas.width = 150;
    minimapCanvas.height = 150;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let gameStarted = false, gameOver = false, gamePaused = false;
let roundInProgress = false, roundTransition = false;

const FIRE_MODES = ['SEMI', 'AUTO', 'BURST'];
let currentFireMode = 1, burstCount = 0, mouseDown = false;

const player = {
    x: 24, y: 24, angle: 0, pitch: 0,
    health: 100, maxHealth: 100,
    ammo: 50, maxAmmo: 50, reserveAmmo: 250,
    kills: 0, speed: 0.06, sprintSpeed: 0.1,
    isReloading: false, reloadTime: 1000,
    shootCooldown: 0, shootDelay: 65
};

// 48x48 MAP
const mapWidth = 48, mapHeight = 48;
const map = generateMap();

function generateMap() {
    const m = Array(mapHeight).fill(0).map(() => Array(mapWidth).fill(0));
    
    // Borders
    for (let i = 0; i < mapWidth; i++) { m[0][i] = 1; m[mapHeight-1][i] = 1; }
    for (let i = 0; i < mapHeight; i++) { m[i][0] = 1; m[i][mapWidth-1] = 1; }
    
    const addBox = (sx, sy, w, h, hollow = false) => {
        for (let y = sy; y < sy + h && y < mapHeight-1; y++)
            for (let x = sx; x < sx + w && x < mapWidth-1; x++)
                if (!hollow || x === sx || x === sx+w-1 || y === sy || y === sy+h-1)
                    if (x > 0 && y > 0) m[y][x] = 1;
    };
    
    // Center
    addBox(21, 21, 6, 6, true);
    m[24][21] = 0; m[24][26] = 0; m[21][24] = 0; m[26][24] = 0;
    
    // Corners
    addBox(4, 4, 5, 5, true); m[6][4] = 0; m[4][6] = 0;
    addBox(39, 4, 5, 5, true); m[6][43] = 0; m[4][41] = 0;
    addBox(4, 39, 5, 5, true); m[41][4] = 0; m[43][6] = 0;
    addBox(39, 39, 5, 5, true); m[41][43] = 0; m[43][41] = 0;
    
    // Side structures
    addBox(21, 4, 6, 3);
    addBox(21, 41, 6, 3);
    addBox(4, 21, 3, 6);
    addBox(41, 21, 3, 6);
    
    // Pillars
    [[14,14],[33,14],[14,33],[33,33],[10,24],[37,24],[24,10],[24,37]].forEach(([px,py]) => {
        m[py][px] = 1; m[py+1][px] = 1; m[py][px+1] = 1; m[py+1][px+1] = 1;
    });
    
    // Walls
    for (let x = 8; x < 16; x++) { m[11][x] = 1; m[36][x] = 1; m[11][mapWidth-1-x] = 1; m[36][mapWidth-1-x] = 1; }
    
    return m;
}

let projectiles = [];
let teamScores = { transformer: 0, mamba: 0, rwkv: 0 };
let round = 1;

class Projectile {
    constructor(x, y, angle, owner, damage, speed, team) {
        this.x = x; this.y = y; this.angle = angle;
        this.owner = owner; this.damage = damage;
        this.speed = speed; this.team = team; this.life = 80;
    }
    
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        
        if (map[Math.floor(this.y)]?.[Math.floor(this.x)] === 1) return false;
        
        if (this.team !== 'player') {
            const d = Math.hypot(this.x - player.x, this.y - player.y);
            if (d < 0.4) { player.health -= this.damage; showDamage(); return false; }
        }
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if (e === this.owner) continue;
            if (this.team !== 'player' && e.brainType === this.team) continue;
            
            if (Math.hypot(this.x - e.x, this.y - e.y) < e.size) {
                if (e.takeDamage(this.damage)) {
                    const killer = this.team === 'player' ? 'PLAYER' : this.owner?.brainType?.toUpperCase() || '?';
                    addKillFeed(killer, e.brainType.toUpperCase());
                    if (this.team === 'player') { player.kills++; player.reserveAmmo += 10; }
                    else if (this.owner) { this.owner.kills++; teamScores[this.owner.brainType]++; }
                    e.onDeath();
                    enemies.splice(i, 1);
                }
                return false;
            }
        }
        return this.life > 0;
    }
}

function addKillFeed(killer, victim) {
    const feed = document.getElementById('killFeed');
    const e = document.createElement('div');
    e.className = 'kill-entry';
    e.innerHTML = `<span style="color:${getCol(killer)}">${killer}</span> ⚔ <span style="color:${getCol(victim)}">${victim}</span>`;
    feed.appendChild(e);
    setTimeout(() => e.remove(), 5000);
}

function getCol(n) {
    return { PLAYER: '#0af', TRANSFORMER: '#ff0', MAMBA: '#0f0', RWKV: '#f0f' }[n] || '#fff';
}

// === TRANSFORMER ===
class TransformerBrain {
    constructor() {
        this.type = 'transformer';
        this.dim = 12;
        this.Wq = this.init(this.dim, this.dim);
        this.Wk = this.init(this.dim, this.dim);
        this.Wv = this.init(this.dim, this.dim);
        this.Wout = this.init(this.dim, 4);
        this.memory = [];
        this.totalUpdates = 0;
    }
    init(r, c) { const s = Math.sqrt(2/(r+c)); return Array(r).fill(0).map(() => Array(c).fill(0).map(() => (Math.random()*2-1)*s)); }
    mv(m, v) { return m.map(row => row.reduce((s, x, i) => s + x * (v[i]||0), 0)); }
    
    forward(obs) {
        const x = [obs.dx, obs.dy, obs.vx, obs.vy, obs.dist, obs.hp, obs.los ? 1 : 0, obs.ally,
                   Math.sin(obs.dx), Math.cos(obs.dy), obs.dist * obs.hp, obs.vx * obs.vy];
        this.memory.push(x);
        if (this.memory.length > 8) this.memory.shift();
        
        const Q = this.mv(this.Wq, x);
        let out = Array(this.dim).fill(0), tw = 0;
        for (const mem of this.memory) {
            const K = this.mv(this.Wk, mem), V = this.mv(this.Wv, mem);
            const w = Math.exp(Q.reduce((s, q, i) => s + q * K[i], 0) / 4);
            for (let i = 0; i < this.dim; i++) out[i] += w * V[i];
            tw += w;
        }
        for (let i = 0; i < this.dim; i++) out[i] /= tw;
        
        const a = this.mv(this.Wout, out);
        return { dx: Math.tanh(a[0]), dy: Math.tanh(a[1]), shoot: a[2] > 0, aggro: (Math.tanh(a[3])+1)/2 };
    }
    
    learn(r) {
        this.totalUpdates++;
        [this.Wq, this.Wk, this.Wv, this.Wout].forEach(m => {
            for (let i = 0; i < m.length; i++)
                for (let j = 0; j < m[i].length; j++)
                    m[i][j] += (Math.random()*2-1) * 0.01 * r;
        });
    }
    
    cloneFrom(o) {
        this.Wq = o.Wq.map(r => [...r]);
        this.Wk = o.Wk.map(r => [...r]);
        this.Wv = o.Wv.map(r => [...r]);
        this.Wout = o.Wout.map(r => [...r]);
    }
    
    serialize() { return { t: 'tf', Wq: this.Wq, Wk: this.Wk, Wv: this.Wv, Wout: this.Wout, u: this.totalUpdates }; }
    deserialize(d) { this.Wq = d.Wq; this.Wk = d.Wk; this.Wv = d.Wv; this.Wout = d.Wout; this.totalUpdates = d.u; }
}

// === MAMBA ===
class MambaBrain {
    constructor() {
        this.type = 'mamba';
        this.dim = 12;
        this.A = Array(this.dim).fill(0).map(() => -0.3 - Math.random()*0.3);
        this.WB = this.init(8, this.dim);
        this.WC = this.init(8, this.dim);
        this.Wd = this.init(8, this.dim);
        this.Wout = this.init(this.dim, 4);
        this.h = Array(this.dim).fill(0);
        this.totalUpdates = 0;
    }
    init(r, c) { const s = Math.sqrt(2/(r+c)); return Array(r).fill(0).map(() => Array(c).fill(0).map(() => (Math.random()*2-1)*s)); }
    mv(m, v) { return m[0].map((_, j) => m.reduce((s, row, i) => s + row[j] * (v[i]||0), 0)); }
    sig(x) { return 1 / (1 + Math.exp(-Math.max(-10, Math.min(10, x)))); }
    
    forward(obs) {
        const x = [obs.dx, obs.dy, obs.vx, obs.vy, obs.dist, obs.hp, obs.los ? 1 : 0, obs.ally];
        const B = this.mv(this.WB, x).map(v => Math.tanh(v));
        const C = this.mv(this.WC, x).map(v => Math.tanh(v));
        const delta = this.mv(this.Wd, x).map(v => Math.abs(this.sig(v) * 0.1));
        
        for (let i = 0; i < this.dim; i++) {
            this.h[i] = Math.exp(delta[i] * this.A[i]) * this.h[i] + delta[i] * B[i] * x[i % 8];
            this.h[i] = Math.max(-5, Math.min(5, this.h[i]));
        }
        
        const y = this.h.map((h, i) => C[i] * h);
        const a = this.mv(this.Wout, y);
        return { dx: Math.tanh(a[0]), dy: Math.tanh(a[1]), shoot: a[2] > 0, aggro: (Math.tanh(a[3])+1)/2 };
    }
    
    learn(r) {
        this.totalUpdates++;
        for (let i = 0; i < this.A.length; i++) this.A[i] += (Math.random()*2-1) * 0.005 * r;
        [this.WB, this.WC, this.Wd, this.Wout].forEach(m => {
            for (let i = 0; i < m.length; i++)
                for (let j = 0; j < m[i].length; j++)
                    m[i][j] += (Math.random()*2-1) * 0.01 * r;
        });
    }
    
    cloneFrom(o) {
        this.A = [...o.A];
        this.WB = o.WB.map(r => [...r]);
        this.WC = o.WC.map(r => [...r]);
        this.Wd = o.Wd.map(r => [...r]);
        this.Wout = o.Wout.map(r => [...r]);
        this.h = Array(this.dim).fill(0);
    }
    
    serialize() { return { t: 'mb', A: this.A, WB: this.WB, WC: this.WC, Wd: this.Wd, Wout: this.Wout, u: this.totalUpdates }; }
    deserialize(d) { this.A = d.A; this.WB = d.WB; this.WC = d.WC; this.Wd = d.Wd; this.Wout = d.Wout; this.totalUpdates = d.u; this.h = Array(this.dim).fill(0); }
}

// === RWKV ===
class RWKVBrain {
    constructor() {
        this.type = 'rwkv';
        this.dim = 12;
        this.decay = Array(this.dim).fill(0).map(() => -0.3 - Math.random()*0.4);
        this.bonus = Array(this.dim).fill(0).map(() => Math.random()*0.3);
        this.Wr = this.init(8, this.dim);
        this.Wk = this.init(8, this.dim);
        this.Wv = this.init(8, this.dim);
        this.mixR = Array(8).fill(0.5);
        this.mixK = Array(8).fill(0.5);
        this.Wout = this.init(this.dim, 4);
        this.prevX = Array(8).fill(0);
        this.aa = Array(this.dim).fill(0);
        this.bb = Array(this.dim).fill(1);
        this.pp = Array(this.dim).fill(-1e30);
        this.totalUpdates = 0;
    }
    init(r, c) { const s = Math.sqrt(2/(r+c)); return Array(r).fill(0).map(() => Array(c).fill(0).map(() => (Math.random()*2-1)*s)); }
    mv(m, v) { return m[0].map((_, j) => m.reduce((s, row, i) => s + row[j] * (v[i]||0), 0)); }
    sig(x) { return 1 / (1 + Math.exp(-Math.max(-10, Math.min(10, x)))); }
    
    forward(obs) {
        const x = [obs.dx, obs.dy, obs.vx, obs.vy, obs.dist, obs.hp, obs.los ? 1 : 0, obs.ally];
        
        const xr = x.map((v, i) => v * this.mixR[i] + this.prevX[i] * (1 - this.mixR[i]));
        const xk = x.map((v, i) => v * this.mixK[i] + this.prevX[i] * (1 - this.mixK[i]));
        
        const r = this.mv(this.Wr, xr).map(v => this.sig(v));
        const k = this.mv(this.Wk, xk);
        const v = this.mv(this.Wv, x);
        
        const wkv = Array(this.dim).fill(0);
        for (let i = 0; i < this.dim; i++) {
            const ww = this.bonus[i] + k[i];
            const p = Math.max(this.pp[i], ww);
            const e1 = Math.exp(this.pp[i] - p);
            const e2 = Math.exp(ww - p);
            wkv[i] = (e1 * this.aa[i] + e2 * v[i]) / (e1 * this.bb[i] + e2);
            
            const ww2 = this.pp[i] + this.decay[i];
            const p2 = Math.max(ww2, k[i]);
            this.aa[i] = Math.exp(ww2 - p2) * this.aa[i] + Math.exp(k[i] - p2) * v[i];
            this.bb[i] = Math.exp(ww2 - p2) * this.bb[i] + Math.exp(k[i] - p2);
            this.pp[i] = p2;
        }
        
        const out = wkv.map((w, i) => r[i] * w);
        this.prevX = [...x];
        
        const a = this.mv(this.Wout, out);
        return { dx: Math.tanh(a[0]), dy: Math.tanh(a[1]), shoot: a[2] > 0, aggro: (Math.tanh(a[3])+1)/2 };
    }
    
    learn(r) {
        this.totalUpdates++;
        for (let i = 0; i < this.decay.length; i++) {
            this.decay[i] += (Math.random()*2-1) * 0.005 * r;
            this.bonus[i] += (Math.random()*2-1) * 0.005 * r;
            this.mixR[i] = Math.max(0, Math.min(1, this.mixR[i] + (Math.random()*2-1) * 0.01 * r));
            this.mixK[i] = Math.max(0, Math.min(1, this.mixK[i] + (Math.random()*2-1) * 0.01 * r));
        }
        [this.Wr, this.Wk, this.Wv, this.Wout].forEach(m => {
            for (let i = 0; i < m.length; i++)
                for (let j = 0; j < m[i].length; j++)
                    m[i][j] += (Math.random()*2-1) * 0.01 * r;
        });
    }
    
    cloneFrom(o) {
        this.decay = [...o.decay]; this.bonus = [...o.bonus];
        this.mixR = [...o.mixR]; this.mixK = [...o.mixK];
        this.Wr = o.Wr.map(r => [...r]);
        this.Wk = o.Wk.map(r => [...r]);
        this.Wv = o.Wv.map(r => [...r]);
        this.Wout = o.Wout.map(r => [...r]);
        this.reset();
    }
    
    reset() {
        this.prevX = Array(8).fill(0);
        this.aa = Array(this.dim).fill(0);
        this.bb = Array(this.dim).fill(1);
        this.pp = Array(this.dim).fill(-1e30);
    }
    
    serialize() { return { t: 'rw', decay: this.decay, bonus: this.bonus, mixR: this.mixR, mixK: this.mixK, Wr: this.Wr, Wk: this.Wk, Wv: this.Wv, Wout: this.Wout, u: this.totalUpdates }; }
    deserialize(d) { this.decay = d.decay; this.bonus = d.bonus; this.mixR = d.mixR; this.mixK = d.mixK; this.Wr = d.Wr; this.Wk = d.Wk; this.Wv = d.Wv; this.Wout = d.Wout; this.totalUpdates = d.u; this.reset(); }
}

const sharedBrains = {
    transformer: new TransformerBrain(),
    mamba: new MambaBrain(),
    rwkv: new RWKVBrain()
};

let enemies = [];

class Enemy {
    constructor(x, y, type = null) {
        this.x = x; this.y = y;
        this.health = 40 + round * 6;
        this.maxHealth = this.health;
        this.baseSpeed = 0.028 + round * 0.002;
        this.size = 0.35;
        this.angle = Math.random() * Math.PI * 2;
        
        this.brainType = type || ['transformer', 'mamba', 'rwkv'][Math.floor(Math.random() * 3)];
        
        if (this.brainType === 'transformer') this.brain = new TransformerBrain();
        else if (this.brainType === 'mamba') this.brain = new MambaBrain();
        else this.brain = new RWKVBrain();
        
        if (sharedBrains[this.brainType].totalUpdates > 0) {
            this.brain.cloneFrom(sharedBrains[this.brainType]);
            this.brain.learn(Math.random() * 0.2 - 0.1);
        }
        
        this.shootCooldown = Math.random() * 500;
        this.shootDelay = 600 - round * 20;
        this.damage = 6 + round;
        this.kills = 0;
        this.dmgDealt = 0;
        this.life = 0;
        this.lastTX = 0; this.lastTY = 0;
    }
    
    findTarget() {
        let best = { x: player.x, y: player.y, d: Math.hypot(this.x - player.x, this.y - player.y) };
        for (const e of enemies) {
            if (e === this || e.brainType === this.brainType) continue;
            const d = Math.hypot(this.x - e.x, this.y - e.y);
            if (d < best.d) best = { x: e.x, y: e.y, d, e };
        }
        return best;
    }
    
    hasLOS(tx, ty) {
        const dx = tx - this.x, dy = ty - this.y;
        const d = Math.hypot(dx, dy), steps = Math.floor(d / 0.3);
        for (let i = 1; i < steps; i++) {
            const x = this.x + dx / steps * i, y = this.y + dy / steps * i;
            if (map[Math.floor(y)]?.[Math.floor(x)] === 1) return false;
        }
        return true;
    }
    
    nearestAlly() {
        let min = 20;
        for (const e of enemies) {
            if (e !== this && e.brainType === this.brainType) {
                const d = Math.hypot(this.x - e.x, this.y - e.y);
                if (d < min) min = d;
            }
        }
        return min;
    }
    
    update(dt) {
        this.life += dt;
        this.shootCooldown = Math.max(0, this.shootCooldown - dt);
        
        const t = this.findTarget();
        const dx = t.x - this.x, dy = t.y - this.y;
        const vx = t.x - this.lastTX, vy = t.y - this.lastTY;
        this.lastTX = t.x; this.lastTY = t.y;
        
        const los = this.hasLOS(t.x, t.y);
        
        const obs = { dx: dx/25, dy: dy/25, vx: vx*5, vy: vy*5, dist: t.d/25, hp: this.health/this.maxHealth, los, ally: this.nearestAlly()/15 };
        const act = this.brain.forward(obs);
        
        const inf = Math.min(0.6, this.brain.totalUpdates / 60);
        let mx = (dx/t.d) * (1-inf) + act.dx * inf;
        let my = (dy/t.d) * (1-inf) + act.dy * inf;
        const spd = this.baseSpeed * (0.5 + act.aggro * 0.7);
        const md = Math.hypot(mx, my);
        if (md > 0) { mx = mx/md * spd; my = my/md * spd; }
        
        if (map[Math.floor(this.y)]?.[Math.floor(this.x + mx*2)] === 0) this.x += mx;
        if (map[Math.floor(this.y + my*2)]?.[Math.floor(this.x)] === 0) this.y += my;
        
        this.angle = Math.atan2(dy, dx);
        
        if (los && t.d < 18 && this.shootCooldown <= 0 && (act.shoot || t.d < 6)) {
            this.shoot(t);
            this.shootCooldown = this.shootDelay * (1.1 - act.aggro * 0.3);
        }
        
        if (this.life % 1500 < dt) this.brain.learn(0.03);
    }
    
    shoot(t) {
        const ang = Math.atan2(t.y - this.y, t.x - this.x) + (Math.random() - 0.5) * 0.12;
        projectiles.push(new Projectile(
            this.x + Math.cos(ang) * 0.4,
            this.y + Math.sin(ang) * 0.4,
            ang, this, this.damage, 0.35, this.brainType
        ));
    }
    
    takeDamage(amt) {
        this.health -= amt;
        this.brain.learn(-0.15);
        return this.health <= 0;
    }
    
    onDeath() {
        const fit = this.kills * 40 + this.dmgDealt - (this.maxHealth - this.health) * 0.2 + this.life / 400;
        if (fit > 0) {
            sharedBrains[this.brainType].learn(fit * 0.003);
            const blend = Math.min(0.2, fit / 120);
            const bm = (s, l) => { for (let i = 0; i < s.length; i++) for (let j = 0; j < s[i].length; j++) s[i][j] = s[i][j]*(1-blend) + l[i][j]*blend; };
            if (this.brainType === 'transformer') bm(sharedBrains.transformer.Wout, this.brain.Wout);
            else if (this.brainType === 'mamba') bm(sharedBrains.mamba.Wout, this.brain.Wout);
            else bm(sharedBrains.rwkv.Wout, this.brain.Wout);
        }
    }
}

function spawnEnemies() {
    enemies = [];
    const perTeam = 3 + round;
    const types = ['transformer', 'mamba', 'rwkv'];
    const spawns = [[6,6],[42,6],[6,42],[42,42],[24,6],[24,42],[6,24],[42,24],[16,16],[32,16],[16,32],[32,32]];
    let si = 0;
    
    for (const type of types) {
        for (let i = 0; i < perTeam; i++) {
            let x, y, att = 0;
            do {
                if (si < spawns.length) { [x, y] = spawns[si++]; x += Math.random()*2-1; y += Math.random()*2-1; }
                else { x = 3 + Math.random()*(mapWidth-6); y = 3 + Math.random()*(mapHeight-6); }
                att++;
            } while ((map[Math.floor(y)]?.[Math.floor(x)] === 1 || Math.hypot(x-player.x, y-player.y) < 8) && att < 50);
            enemies.push(new Enemy(x, y, type));
        }
    }
    roundInProgress = true;
}

// Input
const keys = {};
let mouseMovement = { x: 0, y: 0 };

document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && gameStarted && !gameOver) { togglePause(); return; }
    if (e.key === 'F5') { e.preventDefault(); saveGame(); return; }
    if (e.key === 'F9') { e.preventDefault(); loadGame(); return; }
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'r' && !player.isReloading && player.ammo < player.maxAmmo && player.reserveAmmo > 0) reload();
    if (e.key.toLowerCase() === 'v') currentFireMode = (currentFireMode + 1) % 3;
});
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
document.addEventListener('mousemove', e => { if (document.pointerLockElement === canvas) { mouseMovement.x += e.movementX; mouseMovement.y += e.movementY; } });
document.addEventListener('mousedown', e => { if (e.button === 0 && gameStarted && !gameOver && !gamePaused) { mouseDown = true; if (FIRE_MODES[currentFireMode] === 'BURST') burstCount = 3; } });
document.addEventListener('mouseup', e => { if (e.button === 0) { mouseDown = false; burstCount = 0; } });
canvas.addEventListener('click', () => { if (gameStarted && !gamePaused) canvas.requestPointerLock(); });

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('loadBtn').addEventListener('click', () => { if (loadGame()) { document.getElementById('startScreen').style.display = 'none'; gameStarted = true; canvas.requestPointerLock(); } });
document.getElementById('resumeBtn').addEventListener('click', togglePause);
document.getElementById('saveBtn').addEventListener('click', saveGame);
document.getElementById('quitBtn').addEventListener('click', () => location.reload());

function startGame() {
    document.getElementById('startScreen').style.display = 'none';
    gameStarted = true; gameOver = false;
    round = 1; player.health = 100; player.ammo = 50; player.reserveAmmo = 250; player.kills = 0;
    player.x = 24; player.y = 24; player.angle = 0; player.pitch = 0;
    teamScores = { transformer: 0, mamba: 0, rwkv: 0 };
    projectiles = [];
    canvas.requestPointerLock();
    spawnEnemies();
}

function togglePause() {
    gamePaused = !gamePaused;
    document.getElementById('pauseMenu').style.display = gamePaused ? 'flex' : 'none';
    if (!gamePaused) canvas.requestPointerLock();
    else document.exitPointerLock();
}

function saveGame() {
    const data = {
        player: { x: player.x, y: player.y, angle: player.angle, health: player.health, ammo: player.ammo, reserveAmmo: player.reserveAmmo, kills: player.kills },
        round, teamScores,
        brains: { transformer: sharedBrains.transformer.serialize(), mamba: sharedBrains.mamba.serialize(), rwkv: sharedBrains.rwkv.serialize() }
    };
    localStorage.setItem('neuralArenaSave', JSON.stringify(data));
    const n = document.getElementById('saveNotice'); n.style.opacity = '1'; setTimeout(() => n.style.opacity = '0', 1500);
}

function loadGame() {
    const s = localStorage.getItem('neuralArenaSave');
    if (!s) { alert('No save!'); return false; }
    try {
        const d = JSON.parse(s);
        Object.assign(player, d.player);
        round = d.round; teamScores = d.teamScores;
        sharedBrains.transformer.deserialize(d.brains.transformer);
        sharedBrains.mamba.deserialize(d.brains.mamba);
        sharedBrains.rwkv.deserialize(d.brains.rwkv);
        gameOver = false; projectiles = [];
        spawnEnemies();
        return true;
    } catch (e) { alert('Load failed!'); return false; }
}

function reload() {
    player.isReloading = true;
    showMessage('RELOADING...');
    setTimeout(() => {
        const need = player.maxAmmo - player.ammo;
        const got = Math.min(need, player.reserveAmmo);
        player.ammo += got; player.reserveAmmo -= got;
        player.isReloading = false;
        hideMessage();
    }, player.reloadTime);
}

let semiAutoFired = false;
function shoot() {
    if (player.shootCooldown > 0 || player.isReloading || player.ammo <= 0) return false;
    player.ammo--;
    player.shootCooldown = player.shootDelay;
    
    const ang = player.angle + (Math.random() - 0.5) * 0.03;
    projectiles.push(new Projectile(player.x + Math.cos(ang)*0.3, player.y + Math.sin(ang)*0.3, ang, null, 20, 0.5, 'player'));
    
    if (player.ammo === 0 && player.reserveAmmo > 0) reload();
    return true;
}

function showDamage() { const o = document.getElementById('damageOverlay'); o.style.opacity = '1'; setTimeout(() => o.style.opacity = '0', 100); }
function showMessage(t) { const m = document.getElementById('message'); m.textContent = t; m.style.display = 'block'; }
function hideMessage() { document.getElementById('message').style.display = 'none'; }

function castRays() {
    const fov = Math.PI / 3, numRays = canvas.width;
    const horizon = canvas.height / 2 + player.pitch * canvas.height;
    
    ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, horizon);
    ctx.fillStyle = '#333'; ctx.fillRect(0, horizon, canvas.width, canvas.height - horizon);
    
    const zBuf = [];
    for (let i = 0; i < numRays; i++) {
        const ang = player.angle - fov/2 + (i/numRays) * fov;
        let rx = player.x, ry = player.y, dist = 0;
        while (dist < 25) {
            rx += Math.cos(ang) * 0.02; ry += Math.sin(ang) * 0.02; dist += 0.02;
            if (map[Math.floor(ry)]?.[Math.floor(rx)] === 1) break;
        }
        const corrDist = dist * Math.cos(ang - player.angle);
        zBuf[i] = corrDist;
        const wallH = Math.min(canvas.height * 1.5, (canvas.height / corrDist) * 0.8);
        const shade = Math.max(0.2, 1 - corrDist / 18);
        ctx.fillStyle = `rgba(100,100,120,${shade})`;
        ctx.fillRect(i, horizon - wallH/2, 1, wallH);
    }
    return zBuf;
}

function renderEnemies(zBuf) {
    const horizon = canvas.height / 2 + player.pitch * canvas.height;
    const sorted = enemies.map(e => ({ e, d: Math.hypot(e.x - player.x, e.y - player.y) })).sort((a, b) => b.d - a.d);
    
    for (const { e, d } of sorted) {
        let ang = Math.atan2(e.y - player.y, e.x - player.x) - player.angle;
        while (ang > Math.PI) ang -= Math.PI * 2;
        while (ang < -Math.PI) ang += Math.PI * 2;
        
        if (Math.abs(ang) < Math.PI / 3) {
            const sx = canvas.width / 2 + (ang / (Math.PI/3)) * canvas.width;
            const size = (canvas.height / d) * 0.4;
            
            if (sx >= 0 && sx < zBuf.length && d < zBuf[Math.floor(sx)]) {
                const col = { transformer: '#cc0', mamba: '#0c0', rwkv: '#c0c' }[e.brainType];
                ctx.fillStyle = col;
                if (e.brainType === 'mamba') {
                    ctx.beginPath(); ctx.ellipse(sx, horizon, size/2, size/2*1.1, 0, 0, Math.PI*2); ctx.fill();
                } else if (e.brainType === 'rwkv') {
                    ctx.beginPath(); ctx.moveTo(sx, horizon-size/2); ctx.lineTo(sx+size/2, horizon+size/2); ctx.lineTo(sx-size/2, horizon+size/2); ctx.closePath(); ctx.fill();
                } else {
                    ctx.fillRect(sx-size/2, horizon-size/2, size, size);
                }
                
                // Eyes
                ctx.fillStyle = '#f00';
                ctx.fillRect(sx-size/4, horizon-size/6, size/8, size/8);
                ctx.fillRect(sx+size/8, horizon-size/6, size/8, size/8);
                
                // Gun
                ctx.fillStyle = '#333';
                ctx.fillRect(sx+size/3, horizon, size/2, size/6);
                
                // Health bar
                ctx.fillStyle = '#400'; ctx.fillRect(sx-size/2, horizon-size/2-8, size, 4);
                ctx.fillStyle = col; ctx.fillRect(sx-size/2, horizon-size/2-8, size*(e.health/e.maxHealth), 4);
                
                // Label
                ctx.fillStyle = '#fff'; ctx.font = '9px monospace'; ctx.textAlign = 'center';
                ctx.fillText(e.brainType.substr(0,2).toUpperCase(), sx, horizon-size/2-12);
            }
        }
    }
}

function renderProjectiles(zBuf) {
    const horizon = canvas.height / 2 + player.pitch * canvas.height;
    for (const p of projectiles) {
        const d = Math.hypot(p.x - player.x, p.y - player.y);
        let ang = Math.atan2(p.y - player.y, p.x - player.x) - player.angle;
        while (ang > Math.PI) ang -= Math.PI * 2;
        while (ang < -Math.PI) ang += Math.PI * 2;
        
        if (Math.abs(ang) < Math.PI / 3 && d > 0.5) {
            const sx = canvas.width / 2 + (ang / (Math.PI/3)) * canvas.width;
            if (sx >= 0 && sx < zBuf.length && d < zBuf[Math.floor(sx)]) {
                const size = Math.max(2, 8 / d);
                ctx.fillStyle = p.team === 'player' ? '#ff0' : getCol(p.team.toUpperCase());
                ctx.beginPath(); ctx.arc(sx, horizon, size, 0, Math.PI*2); ctx.fill();
            }
        }
    }
}

function renderWeapon() {
    const bob = (keys['w']||keys['s']||keys['a']||keys['d']) ? Math.sin(performance.now()/150)*4 : 0;
    const recoil = player.shootCooldown > 0 ? (player.shootCooldown/player.shootDelay)*12 : 0;
    const wx = canvas.width/2 + 80 + bob;
    const wy = canvas.height - 160 + player.pitch*80 + recoil + Math.abs(bob);
    
    ctx.save();
    ctx.translate(wx+60, wy+50); ctx.rotate(-0.1); ctx.translate(-wx-60, -wy-50);
    
    // Gun body
    ctx.fillStyle = '#1a1a1a'; ctx.fillRect(wx, wy+10, 120, 40);
    ctx.fillStyle = '#222'; ctx.fillRect(wx, wy+10, 120, 5);
    ctx.fillStyle = '#111'; ctx.fillRect(wx+100, wy+18, 50, 24);
    ctx.fillStyle = '#0d0d0d'; ctx.fillRect(wx+30, wy+45, 25, 40);
    ctx.fillStyle = '#151515'; ctx.fillRect(wx+60, wy+45, 30, 50);
    
    // Hand
    ctx.fillStyle = '#c9a078';
    ctx.fillRect(wx+55, wy+55, 35, 35);
    ctx.fillRect(wx+100, wy+38, 35, 25);
    
    // Sights
    ctx.fillStyle = '#0f0'; ctx.fillRect(wx+25, wy+5, 4, 4); ctx.fillRect(wx+95, wy+8, 4, 4);
    
    ctx.restore();
    
    // Muzzle flash
    if (player.shootCooldown > player.shootDelay - 30) {
        ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(wx+155, wy+30, 15, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(wx+155, wy+30, 6, 0, Math.PI*2); ctx.fill();
    }
}

function renderCrosshair() {
    const cx = canvas.width/2, cy = canvas.height/2;
    const spread = (keys['w']||keys['s']||keys['a']||keys['d']) ? 12 : 8;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx-spread, cy); ctx.lineTo(cx-4, cy);
    ctx.moveTo(cx+4, cy); ctx.lineTo(cx+spread, cy);
    ctx.moveTo(cx, cy-spread); ctx.lineTo(cx, cy-4);
    ctx.moveTo(cx, cy+4); ctx.lineTo(cx, cy+spread);
    ctx.stroke();
    ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(cx, cy, 2, 0, Math.PI*2); ctx.fill();
}

function renderMinimap() {
    minimapCtx.fillStyle = '#000'; minimapCtx.fillRect(0, 0, 150, 150);
    const s = 150 / mapWidth;
    minimapCtx.fillStyle = '#333';
    for (let y = 0; y < mapHeight; y++) for (let x = 0; x < mapWidth; x++) if (map[y][x] === 1) minimapCtx.fillRect(x*s, y*s, s, s);
    
    for (const e of enemies) {
        minimapCtx.fillStyle = { transformer: '#cc0', mamba: '#0c0', rwkv: '#c0c' }[e.brainType];
        minimapCtx.beginPath(); minimapCtx.arc(e.x*s, e.y*s, 2, 0, Math.PI*2); minimapCtx.fill();
    }
    
    minimapCtx.fillStyle = '#0af';
    minimapCtx.beginPath(); minimapCtx.arc(player.x*s, player.y*s, 3, 0, Math.PI*2); minimapCtx.fill();
    minimapCtx.strokeStyle = '#0af'; minimapCtx.beginPath();
    minimapCtx.moveTo(player.x*s, player.y*s);
    minimapCtx.lineTo(player.x*s + Math.cos(player.angle)*10, player.y*s + Math.sin(player.angle)*10);
    minimapCtx.stroke();
}

function updateHUD() {
    document.getElementById('health').textContent = `HEALTH: ${Math.max(0, player.health)}`;
    document.getElementById('ammo').textContent = `AMMO: ${player.ammo} / ${player.reserveAmmo}`;
    document.getElementById('kills').textContent = `KILLS: ${player.kills}`;
    document.getElementById('round').textContent = `ROUND: ${round}`;
    document.getElementById('fireMode').textContent = `MODE: ${FIRE_MODES[currentFireMode]} [V]`;
    
    const tfE = enemies.filter(e => e.brainType === 'transformer');
    const mbE = enemies.filter(e => e.brainType === 'mamba');
    const rwE = enemies.filter(e => e.brainType === 'rwkv');
    
    document.getElementById('nnStatus').innerHTML = `
        <span class="tf-col">TF(${tfE.length})</span> u:${sharedBrains.transformer.totalUpdates}<br>
        <span class="mb-col">MB(${mbE.length})</span> u:${sharedBrains.mamba.totalUpdates}<br>
        <span class="rw-col">RW(${rwE.length})</span> u:${sharedBrains.rwkv.totalUpdates}
    `;
    
    document.getElementById('teamScoreList').innerHTML = `
        <span class="tf-col">TF: ${teamScores.transformer}</span><br>
        <span class="mb-col">MB: ${teamScores.mamba}</span><br>
        <span class="rw-col">RW: ${teamScores.rwkv}</span>
    `;
}

let lastTime = performance.now();

function gameLoop() {
    const now = performance.now();
    const dt = now - lastTime;
    lastTime = now;
    
    if (!gameStarted || gameOver || gamePaused) { requestAnimationFrame(gameLoop); return; }
    
    player.shootCooldown = Math.max(0, player.shootCooldown - dt);
    
    // Shooting
    if (mouseDown) {
        const mode = FIRE_MODES[currentFireMode];
        if (mode === 'SEMI') { if (!semiAutoFired) { shoot(); semiAutoFired = true; } }
        else if (mode === 'AUTO') shoot();
        else if (mode === 'BURST' && burstCount > 0) { if (shoot()) burstCount--; }
    } else semiAutoFired = false;
    
    // Look
    player.angle += mouseMovement.x * 0.002;
    player.pitch = Math.max(-0.4, Math.min(0.4, player.pitch - mouseMovement.y * 0.002));
    mouseMovement.x = 0; mouseMovement.y = 0;
    
    // Move
    const spd = keys['shift'] ? player.sprintSpeed : player.speed;
    let mx = 0, my = 0;
    if (keys['w']) { mx += Math.cos(player.angle)*spd; my += Math.sin(player.angle)*spd; }
    if (keys['s']) { mx -= Math.cos(player.angle)*spd; my -= Math.sin(player.angle)*spd; }
    if (keys['a']) { mx += Math.cos(player.angle-Math.PI/2)*spd; my += Math.sin(player.angle-Math.PI/2)*spd; }
    if (keys['d']) { mx += Math.cos(player.angle+Math.PI/2)*spd; my += Math.sin(player.angle+Math.PI/2)*spd; }
    
    if (map[Math.floor(player.y)]?.[Math.floor(player.x + mx + Math.sign(mx)*0.2)] === 0) player.x += mx;
    if (map[Math.floor(player.y + my + Math.sign(my)*0.2)]?.[Math.floor(player.x)] === 0) player.y += my;
    
    // Update enemies
    for (const e of enemies) e.update(dt);
    
    // Update projectiles
    projectiles = projectiles.filter(p => p.update());
    
    // Round check
    if (enemies.length === 0 && roundInProgress && !roundTransition) {
        roundTransition = true; roundInProgress = false;
        round++;
        showMessage(`ROUND ${round}\nAIs evolving...`);
        setTimeout(() => { hideMessage(); spawnEnemies(); player.reserveAmmo += 60; roundTransition = false; }, 2500);
    }
    
    // Death
    if (player.health <= 0) {
        gameOver = true;
        const winner = Object.entries(teamScores).sort((a,b) => b[1]-a[1])[0];
        showMessage(`GAME OVER\nYour Kills: ${player.kills} | Round: ${round}\n\nWinning AI: ${winner[0].toUpperCase()} (${winner[1]} kills)\n\nRefresh to restart`);
    }
    
    // Render
    const zBuf = castRays();
    renderEnemies(zBuf);
    renderProjectiles(zBuf);
    renderWeapon();
    renderCrosshair();
    renderMinimap();
    updateHUD();
    
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
