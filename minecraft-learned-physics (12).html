<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Voxels - Learned Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #game { width: 100vw; height: 100vh; display: block; }
        
        #crosshair {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 100;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: white; mix-blend-mode: difference;
        }
        #crosshair::before { width: 24px; height: 2px; top: -1px; left: -12px; }
        #crosshair::after { width: 2px; height: 24px; left: -1px; top: -12px; }
        
        #hotbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 3px; padding: 6px; background: rgba(0,0,0,0.7);
            border-radius: 6px; z-index: 100;
        }
        .hotbar-slot {
            width: 44px; height: 44px; border: 2px solid #555; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            position: relative; cursor: pointer;
        }
        .hotbar-slot.selected { border-color: #fff; box-shadow: 0 0 8px rgba(255,255,255,0.5); }
        .hotbar-slot canvas { width: 30px; height: 30px; image-rendering: pixelated; border-radius: 3px; }
        .hotbar-slot .key-hint { position: absolute; bottom: 1px; right: 3px; font-size: 8px; color: #aaa; }
        .hotbar-slot .count { position: absolute; bottom: 1px; left: 3px; font-size: 9px; color: #fff; text-shadow: 1px 1px 1px #000; }
        
        #info { position: fixed; top: 12px; left: 12px; color: white; font-size: 10px; text-shadow: 1px 1px 2px black; z-index: 100; line-height: 1.5; }
        #info .nar { color: #00ffaa; }
        #info .phys { color: #00aaff; }
        #info .mix { color: #ffaa00; }
        #info .music { color: #ff88ff; }
        
        #biome-mix {
            position: fixed; top: 12px; left: 180px; color: white; font-size: 9px;
            background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; z-index: 100;
            max-width: 180px;
        }
        #biome-mix h4 { color: #ffaa00; margin-bottom: 4px; font-size: 10px; }
        .mix-bar { display: flex; align-items: center; margin: 2px 0; }
        .mix-bar .name { width: 65px; font-size: 8px; }
        .mix-bar .bar { flex: 1; height: 5px; background: #333; border-radius: 3px; overflow: hidden; }
        .mix-bar .fill { height: 100%; transition: width 0.2s; }
        
        #physics-info {
            position: fixed; bottom: 85px; left: 12px; color: white; font-size: 9px;
            background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; z-index: 100;
        }
        #physics-info h4 { color: #00aaff; margin-bottom: 4px; font-size: 10px; }
        .phys-stat { display: flex; justify-content: space-between; margin: 2px 0; }
        .phys-stat .label { opacity: 0.7; }
        .phys-stat .value { font-family: monospace; color: #00aaff; }
        
        #nn-info {
            position: fixed; top: 12px; right: 12px; color: white; font-size: 8px;
            text-shadow: 1px 1px 2px black; z-index: 100; background: rgba(0,0,0,0.85);
            padding: 8px; border-radius: 6px; max-width: 200px;
        }
        #nn-info h3 { margin-bottom: 3px; font-size: 9px; }
        .nn-world { color: #00ffaa; }
        .nn-phys { color: #00aaff; }
        .nn-tex { color: #ffaa00; }
        .nn-music { color: #ff88ff; }
        .nn-time { color: #ffcc00; }
        .nn-perf { color: #ff66ff; }
        .time { color: #ffcc00; }
        .time-epochs { color: #ffaa00; font-size: 10px; }
        .perf { color: #ff66ff; }
        .perf-extended { color: #cc55cc; font-size: 9px; }
        .perf-epochs { color: #ff88ff; font-size: 10px; }
        #nn-info .arch { font-family: monospace; font-size: 7px; line-height: 1.2; opacity: 0.8; margin: 2px 0; }
        
        #music-info {
            position: fixed; bottom: 85px; right: 12px; color: white; font-size: 9px;
            background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; z-index: 100;
        }
        #music-info h4 { color: #ff88ff; margin-bottom: 3px; font-size: 10px; }
        #music-viz { display: flex; gap: 2px; height: 25px; align-items: flex-end; margin-top: 4px; }
        .viz-bar { width: 5px; background: linear-gradient(to top, #ff88ff, #88ffff); border-radius: 2px; transition: height 0.08s; }
        
        #inventory-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); display: none; align-items: center;
            justify-content: center; z-index: 500;
        }
        #inventory-overlay.open { display: flex; }
        #inventory {
            background: #8b8b8b; border: 4px solid #373737;
            border-radius: 4px; padding: 10px;
        }
        #inventory h2 { color: #3f3f3f; font-size: 14px; margin-bottom: 6px; text-align: center; }
        .inv-grid { display: grid; grid-template-columns: repeat(9, 36px); gap: 2px; }
        .inv-slot {
            width: 36px; height: 36px; background: #8b8b8b; border: 2px solid;
            border-color: #373737 #fff #fff #373737; display: flex;
            align-items: center; justify-content: center; cursor: pointer; position: relative;
        }
        .inv-slot:hover { transform: scale(1.08); z-index: 10; }
        .inv-slot canvas { width: 24px; height: 24px; image-rendering: pixelated; }
        .inv-slot .item-count { position: absolute; bottom: 0; right: 2px; font-size: 9px; font-weight: bold; color: #fff; text-shadow: 1px 1px 1px #000; }
        
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a1a1a 0%, #1a2a3a 50%, #0a2020 100%);
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; z-index: 200; color: white;
        }
        #start-screen h1 { font-size: 24px; text-shadow: 3px 3px 0 #000; margin-bottom: 5px; }
        #start-screen .subtitle { font-size: 11px; opacity: 0.9; margin-bottom: 12px; }
        .sub-nar { color: #00ffaa; }
        .sub-phys { color: #00aaff; }
        .sub-mix { color: #ffaa00; }
        .sub-music { color: #ff88ff; }
        #start-screen .nn-desc { font-size: 10px; opacity: 0.7; margin-bottom: 14px; max-width: 500px; text-align: center; line-height: 1.6; }
        #start-btn {
            padding: 10px 32px; font-size: 16px;
            background: linear-gradient(135deg, #00aaff, #0077aa);
            border: none; color: #fff; cursor: pointer; border-radius: 6px;
            transition: all 0.2s; font-weight: bold;
        }
        #start-btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(0,170,255,0.5); }
        #controls-info { margin-top: 14px; text-align: center; font-size: 9px; opacity: 0.5; line-height: 1.8; }
        
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050a0a; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 300; color: white;
        }
        #loading h2 { margin-bottom: 10px; font-size: 13px; }
        #progress-bar { width: 300px; height: 12px; background: #222; border-radius: 6px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #00ffaa, #00aaff, #ffaa00, #ff88ff); transition: width 0.05s; }
        #loading-text { margin-top: 6px; font-size: 10px; opacity: 0.7; }
        #loss-display { margin-top: 6px; font-family: monospace; font-size: 9px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        .loss-world { color: #00ffaa; }
        .loss-phys { color: #00aaff; }
        .loss-tex { color: #ffaa00; }
        .loss-time { color: #ffcc00; }
        .loss-perf { color: #ff66ff; }
        
        #pause-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: none; align-items: center;
            justify-content: center; z-index: 150; cursor: pointer;
        }
        #pause-overlay.visible { display: flex; }
        .pause-content {
            text-align: center; color: white;
        }
        .pause-content h2 { font-size: 32px; margin-bottom: 10px; }
        .pause-content p { font-size: 16px; opacity: 0.9; margin-bottom: 15px; }
        .pause-hint { font-size: 11px; opacity: 0.5; }
    </style>
</head>
<body>
    <div id="loading">
        <h2>ğŸ§  Training 6 NAR Tensor Transformers (2220 epochs)</h2>
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <div id="loading-text">Initializing...</div>
        <div id="loss-display">
            <span class="loss-world">World: --</span>
            <span class="loss-phys">Physics: --</span>
            <span class="loss-time">Time: --</span>
            <span class="loss-tex">Texture: --</span>
            <span class="loss-perf">Perf: --</span>
        </div>
    </div>

    <div id="start-screen" style="display: none;">
        <h1>ğŸ® NEURAL VOXELS</h1>
        <div class="subtitle">
            <span class="sub-nar">16 Biomes</span> Â· 
            <span class="sub-phys">Learned Physics</span> Â· 
            <span class="sub-mix">Day/Night Cycle</span> Â· 
            <span class="sub-music">Auto-Optimize</span>
        </div>
        <div class="nn-desc">
            6 neural networks with 2220 total epochs! The Performance NN is now an ADVANCED
            TENSOR TRANSFORMER with 4-head self-attention, 2 layers, temporal sequence modeling,
            and FPS prediction! Controls 16 systems: render distance, LOD, fog, shadows, music,
            physics rate, cleanup, batch size, particles, audio quality and more. Learns YOUR hardware!
        </div>
        <button id="start-btn">Enter World</button>
        <div id="controls-info">
            <div>WASD - Move | SPACE - Jump/Swim | SHIFT - Sprint | M - Music</div>
            <div>Left Click - Break | Right Click - Place/Door | E - Inventory | C - Craft</div>
        </div>
    </div>
    
    <canvas id="game"></canvas>
    <div id="crosshair"></div>
    
    <div id="pause-overlay">
        <div class="pause-content">
            <h2>â¸ï¸ PAUSED</h2>
            <p>Click anywhere to continue</p>
            <div class="pause-hint">ESC to pause | M for music</div>
        </div>
    </div>
    
    <div id="inventory-overlay">
        <div id="inventory">
            <h2>Inventory (C = Craft Door: 6 Wood)</h2>
            <div class="inv-grid" id="inv-blocks"></div>
        </div>
    </div>
    
    <div id="hotbar"></div>
    
    <div id="info">
        <div>FPS: <span id="fps">0</span></div>
        <div>Pos: <span id="pos">0, 0, 0</span></div>
        <div class="mix">Biome: <span id="biome">--</span></div>
        <div class="nar">World: <span id="world-epochs">0</span> ep</div>
        <div class="phys">Physics: <span id="phys-epochs">0</span> ep</div>
        <div class="music">Music: <span id="music-status">Off [M]</span></div>
        <div class="time">Time: <span id="game-time">06:00</span> <span id="time-period">â˜€ï¸ Day</span></div>
        <div class="time-epochs">Time NN: <span id="time-epochs">0</span> ep</div>
        <div class="perf">âš¡ Perf: RD=<span id="perf-rd">4</span> TF=<span id="perf-tf">180</span> (<span id="perf-fps">60</span>fps)</div>
        <div class="perf-extended" id="perf-extended">LOD:1.00 Fog:35-80 â¡ï¸+0% Pred:60 Smooth:100%</div>
        <div class="perf-epochs">Tensor Transformer: <span id="perf-epochs">0</span> ep</div>
    </div>
    
    <div id="biome-mix">
        <h4>ğŸ§¬ Biome Mix</h4>
        <div id="mix-bars"></div>
    </div>
    
    <div id="physics-info">
        <h4>âš¡ Physics NN Output</h4>
        <div class="phys-stat"><span class="label">Gravity:</span><span class="value" id="phys-gravity">--</span></div>
        <div class="phys-stat"><span class="label">Jump:</span><span class="value" id="phys-jump">--</span></div>
        <div class="phys-stat"><span class="label">Friction:</span><span class="value" id="phys-friction">--</span></div>
        <div class="phys-stat"><span class="label">Vel Y:</span><span class="value" id="phys-vely">--</span></div>
    </div>
    
    <div id="nn-info">
        <h3 class="nn-world">âš¡ World NAR</h3>
        <div class="arch">Pos â†’ 16 Biome Mix â†’ Terrain</div>
        
        <h3 class="nn-phys">ğŸ¯ Physics NAR</h3>
        <div class="arch">State[vel,pos,ground,water,keys]</div>
        <div class="arch">â†’ Î”Vel, Gravity, Jump, Friction</div>
        
        <h3 class="nn-tex">ğŸ¨ Texture NAR</h3>
        <div class="arch">BlockâŠ•UVâŠ•Face â†’ RGB</div>
        
        <h3 class="nn-music">ğŸµ Music NAR</h3>
        <div class="arch">TimeâŠ•Biome â†’ Notes+Scale</div>
        
        <h3 class="nn-time">ğŸŒ… Time NAR</h3>
        <div class="arch">GameTime â†’ Sky/Light/Fog</div>
        
        <h3 class="nn-perf">âš¡ Perf Tensor (48h, 4-head, 2L)</h3>
        <div class="arch">Temporal Seq â†’ 16 Controls</div>
    </div>
    
    <div id="music-info">
        <h4>ğŸµ Neural Music</h4>
        <div>Chord: <span id="current-chord">I</span> | <span id="music-epochs">0</span> ep</div>
        <div id="music-viz"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUDIO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let audioCtx = null, masterGain = null, musicEnabled = false;
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.25;
            masterGain.connect(audioCtx.destination);
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIMPLEX NOISE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class SimplexNoise {
        constructor(seed) {
            this.p = new Uint8Array(256);
            this.perm = new Uint8Array(512);
            const rng = this.mulberry32(seed * 1e6);
            for (let i = 0; i < 256; i++) this.p[i] = i;
            for (let i = 255; i > 0; i--) { const j = (rng() * (i + 1)) | 0; [this.p[i], this.p[j]] = [this.p[j], this.p[i]]; }
            for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
        }
        mulberry32(s) { return () => { let t = s += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
        noise2D(x, y) {
            const F2 = 0.3660254, G2 = 0.2113249;
            const s = (x + y) * F2, i = Math.floor(x + s), j = Math.floor(y + s);
            const t = (i + j) * G2, x0 = x - i + t, y0 = y - j + t;
            const i1 = x0 > y0 ? 1 : 0, j1 = 1 - i1;
            const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2, x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
            const ii = i & 255, jj = j & 255;
            const g = (h, x, y) => { const a = h & 7, u = a < 4 ? x : y, v = a < 4 ? y : x; return ((a & 1) ? -u : u) + ((a & 2) ? -2 * v : 2 * v); };
            let n0 = 0, n1 = 0, n2 = 0, t0 = 0.5 - x0*x0 - y0*y0, t1 = 0.5 - x1*x1 - y1*y1, t2 = 0.5 - x2*x2 - y2*y2;
            if (t0 >= 0) { t0 *= t0; n0 = t0 * t0 * g(this.perm[ii + this.perm[jj]], x0, y0); }
            if (t1 >= 0) { t1 *= t1; n1 = t1 * t1 * g(this.perm[ii + i1 + this.perm[jj + j1]], x1, y1); }
            if (t2 >= 0) { t2 *= t2; n2 = t2 * t2 * g(this.perm[ii + 1 + this.perm[jj + 1]], x2, y2); }
            return 70 * (n0 + n1 + n2);
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PURE NAR TRANSFORMER BASE - OPTIMIZED
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class PureNARTransformer {
        constructor(inputDim, hiddenDim, outputDim, numLayers, seed) {
            this.inputDim = inputDim;
            this.hiddenDim = hiddenDim;
            this.outputDim = outputDim;
            this.numLayers = numLayers;
            this.lr = 0.005;
            this.rng = this.mulberry32(seed);
            this.epochs = 0;
            this.initWeights();
        }
        
        mulberry32(s) { return () => { let t = s += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
        
        logUnaryEncode(val, bits) {
            const t = new Float32Array(bits);
            const v = Math.abs(val) & ((1 << bits) - 1);
            const ones = v === 0 ? 0 : Math.min(bits, Math.ceil(Math.log2(v + 1)));
            for (let i = 0; i < ones; i++) t[i] = 1;
            if (val < 0) t[bits - 1] = -1;
            return t;
        }
        
        initWeights() {
            const he = n => Math.sqrt(2/n);
            this.Wemb = this.randMat(this.inputDim, this.hiddenDim, he(this.inputDim));
            this.bemb = new Float32Array(this.hiddenDim);
            
            this.L = [];
            for (let l = 0; l < this.numLayers; l++) {
                this.L.push({
                    Wv: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    Wo: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    W1: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    b1: new Float32Array(this.hiddenDim),
                    W2: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    b2: new Float32Array(this.hiddenDim)
                });
            }
            
            this.Wout = this.randMat(this.hiddenDim, this.outputDim, he(this.hiddenDim));
            this.bout = new Float32Array(this.outputDim);
        }
        
        randMat(rows, cols, scale) {
            const w = new Float32Array(rows * cols);
            for (let i = 0; i < w.length; i++) w[i] = (this.rng() * 2 - 1) * scale;
            return { w, rows, cols };
        }
        
        // Optimized matrix multiply
        matMul(input, M, batch) {
            const out = new Float32Array(batch * M.cols);
            const inDim = M.rows, outDim = M.cols;
            for (let b = 0; b < batch; b++) {
                const bIn = b * inDim, bOut = b * outDim;
                for (let j = 0; j < outDim; j++) {
                    let sum = 0;
                    for (let i = 0; i < inDim; i++) sum += input[bIn + i] * M.w[i * outDim + j];
                    out[bOut + j] = sum > 6 ? 6 : sum < -6 ? -6 : sum;
                }
            }
            return out;
        }
        
        addBias(x, bias, dim, batch) {
            for (let i = 0; i < batch * dim; i++) x[i] += bias[i % dim];
        }
        
        layerNorm(x, dim, batch) {
            for (let b = 0; b < batch; b++) {
                const off = b * dim;
                let mean = 0, vari = 0;
                for (let i = 0; i < dim; i++) mean += x[off + i];
                mean /= dim;
                for (let i = 0; i < dim; i++) { const d = x[off + i] - mean; vari += d * d; }
                const invStd = 1 / Math.sqrt(vari / dim + 1e-5);
                for (let i = 0; i < dim; i++) x[off + i] = (x[off + i] - mean) * invStd;
            }
        }
        
        relu(x) { for (let i = 0; i < x.length; i++) if (x[i] < 0) x[i] = 0; }
        
        forward(inputBatch, batch) {
            let h = this.matMul(inputBatch, this.Wemb, batch);
            this.addBias(h, this.bemb, this.hiddenDim, batch);
            this.layerNorm(h, this.hiddenDim, batch);
            
            for (const l of this.L) {
                const v = this.matMul(h, l.Wv, batch);
                const a = this.matMul(v, l.Wo, batch);
                for (let i = 0; i < h.length; i++) h[i] += a[i] * 0.5;
                
                const ff = this.matMul(h, l.W1, batch);
                this.addBias(ff, l.b1, this.hiddenDim, batch);
                this.relu(ff);
                const ff2 = this.matMul(ff, l.W2, batch);
                this.addBias(ff2, l.b2, this.hiddenDim, batch);
                for (let i = 0; i < h.length; i++) h[i] += ff2[i] * 0.5;
            }
            
            const out = this.matMul(h, this.Wout, batch);
            this.addBias(out, this.bout, this.outputDim, batch);
            return { h, out };
        }
        
        updateWeights(grads, batch) {
            const lr = this.lr / batch;
            if (grads.Wout) {
                const M = this.Wout, g = grads.Wout;
                for (let i = 0; i < M.w.length; i++) {
                    const grad = g[i] > 1 ? 1 : g[i] < -1 ? -1 : g[i];
                    M.w[i] -= lr * grad;
                    if (M.w[i] > 2.5) M.w[i] = 2.5;
                    else if (M.w[i] < -2.5) M.w[i] = -2.5;
                }
            }
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHYSICS NAR TRANSFORMER - Learns gravity, friction, jump!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class PhysicsNAR extends PureNARTransformer {
        constructor(seed) {
            // Input: velY(6) + posY(6) + onGround(1) + inWater(1) + jumping(1) + sprinting(1) = 16
            // Output: newVelY(1) + gravity(1) + jumpForce(1) + friction(1) + waterMult(1) = 5
            super(16, 24, 5, 1, seed);  // Reduced: 24 hidden, 1 layer
            
            // Current predicted physics params (for display)
            this.currentGravity = 0.015;
            this.currentJump = 0.26;
            this.currentFriction = 0.9;
            this.currentWaterMult = 0.3;
        }
        
        encodeState(velY, posY, onGround, inWater, jumping, sprinting) {
            const t = new Float32Array(16);
            // Encode velocity as signed log-unary
            const velSign = velY < 0 ? -1 : 1;
            const velMag = Math.min(63, Math.abs(velY) * 100);
            t.set(this.logUnaryEncode(velMag * velSign, 6), 0);
            // Position (fractional part matters for physics)
            t.set(this.logUnaryEncode(Math.floor(posY * 4) & 63, 6), 6);
            // Flags
            t[12] = onGround ? 1 : 0;
            t[13] = inWater ? 1 : 0;
            t[14] = jumping ? 1 : 0;
            t[15] = sprinting ? 1 : 0;
            return t;
        }
        
        // Simulate physics using learned parameters
        simulate(velY, posY, onGround, inWater, jumping, sprinting) {
            const input = new Float32Array(16);
            input.set(this.encodeState(velY, posY, onGround, inWater, jumping, sprinting), 0);
            
            const { out } = this.forward(input, 1);
            
            // Decode outputs with appropriate scaling
            const gravity = Math.abs(Math.tanh(out[1])) * 0.025 + 0.005;  // 0.005 - 0.03
            const jumpForce = Math.abs(Math.tanh(out[2])) * 0.2 + 0.15;   // 0.15 - 0.35
            const friction = Math.tanh(out[3]) * 0.1 + 0.9;               // 0.8 - 1.0
            const waterMult = Math.abs(Math.tanh(out[4])) * 0.4 + 0.2;    // 0.2 - 0.6
            
            // Store for display
            this.currentGravity = gravity;
            this.currentJump = jumpForce;
            this.currentFriction = friction;
            this.currentWaterMult = waterMult;
            
            // Apply physics
            let newVelY = velY;
            
            // Gravity (reduced in water)
            const effectiveGravity = inWater ? gravity * waterMult : gravity;
            newVelY -= effectiveGravity;
            
            // Jump
            if (jumping) {
                if (inWater) {
                    newVelY = 0.07; // Swim up
                } else if (onGround) {
                    newVelY = jumpForce;
                }
            }
            
            // Clamp velocity
            newVelY = Math.max(-1, Math.min(1, newVelY));
            
            return { newVelY, gravity, jumpForce, friction, waterMult };
        }
        
        // Training target from hardcoded physics
        getTargetPhysics(velY, posY, onGround, inWater, jumping, sprinting) {
            // These are the "correct" physics we want the NN to learn
            const targetGravity = inWater ? 0.004 : 0.015;
            const targetJump = 0.26;
            const targetFriction = 0.91;
            const targetWaterMult = 0.27;
            
            let targetVelY = velY;
            targetVelY -= targetGravity;
            
            if (jumping) {
                if (inWater) targetVelY = 0.07;
                else if (onGround) targetVelY = targetJump;
            }
            
            return { targetVelY, targetGravity, targetJump, targetFriction, targetWaterMult };
        }
        
        train(samples) {
            const batch = samples.length;
            const input = new Float32Array(batch * 16);
            const targets = [];
            
            for (let i = 0; i < batch; i++) {
                const [velY, posY, onGround, inWater, jumping, sprinting] = samples[i];
                input.set(this.encodeState(velY, posY, onGround, inWater, jumping, sprinting), i * 16);
                targets.push(this.getTargetPhysics(velY, posY, onGround, inWater, jumping, sprinting));
            }
            
            const { h, out } = this.forward(input, batch);
            let loss = 0;
            const gWout = new Float32Array(this.hiddenDim * 5);
            
            for (let b = 0; b < batch; b++) {
                const t = targets[b];
                
                // Velocity loss
                const predVelY = Math.tanh(out[b * 5]) * 0.5;
                loss += (predVelY - t.targetVelY) ** 2;
                
                // Gravity loss
                const predGrav = Math.abs(Math.tanh(out[b * 5 + 1])) * 0.025 + 0.005;
                loss += (predGrav - t.targetGravity) ** 2 * 100;
                
                // Jump loss
                const predJump = Math.abs(Math.tanh(out[b * 5 + 2])) * 0.2 + 0.15;
                loss += (predJump - t.targetJump) ** 2 * 10;
                
                // Friction loss
                const predFric = Math.tanh(out[b * 5 + 3]) * 0.1 + 0.9;
                loss += (predFric - t.targetFriction) ** 2 * 10;
                
                // Water mult loss
                const predWater = Math.abs(Math.tanh(out[b * 5 + 4])) * 0.4 + 0.2;
                loss += (predWater - t.targetWaterMult) ** 2 * 10;
                
                // Gradients (simplified)
                for (let i = 0; i < this.hiddenDim; i++) {
                    const hVal = h[b * this.hiddenDim + i];
                    gWout[i * 5] += (predVelY - t.targetVelY) * 0.1 * hVal;
                    gWout[i * 5 + 1] += (predGrav - t.targetGravity) * 2 * hVal;
                    gWout[i * 5 + 2] += (predJump - t.targetJump) * 0.5 * hVal;
                    gWout[i * 5 + 3] += (predFric - t.targetFriction) * 0.5 * hVal;
                    gWout[i * 5 + 4] += (predWater - t.targetWaterMult) * 0.5 * hVal;
                }
            }
            
            this.updateWeights({ Wout: gWout }, batch);
            this.epochs++;
            return loss / batch;
        }
        
        // Generate diverse training samples
        generateTrainingSamples(count) {
            const samples = [];
            for (let i = 0; i < count; i++) {
                const velY = (this.rng() - 0.5) * 0.6;
                const posY = this.rng() * 30 + 5;
                const onGround = this.rng() < 0.3;
                const inWater = this.rng() < 0.15;
                const jumping = this.rng() < 0.2;
                const sprinting = this.rng() < 0.3;
                samples.push([velY, posY, onGround, inWater, jumping, sprinting]);
            }
            return samples;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BIOME DATA (16 biomes)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const NUM_BIOMES = 16;
    const BIOME_DATA = [
        { name: 'Plains', surface: 1, treeChance: 0.012, treeTypes: ['oak', 'oak', 'birch'], color: '#5da33a' },
        { name: 'Desert', surface: 6, treeChance: 0.003, treeTypes: ['acacia', 'none'], color: '#E6D69C' },
        { name: 'Forest', surface: 1, treeChance: 0.08, treeTypes: ['oak', 'oak', 'birch', 'oak'], color: '#2d6b27' },
        { name: 'Tundra', surface: 10, treeChance: 0.008, treeTypes: ['spruce', 'pine', 'spruce'], color: '#E8E8E8' },
        { name: 'Ocean', surface: 11, treeChance: 0, treeTypes: ['none'], color: '#2266AA' },
        { name: 'Jungle', surface: 1, treeChance: 0.10, treeTypes: ['jungle', 'jungle', 'bamboo', 'jungle'], color: '#1E5631' },
        { name: 'Swamp', surface: 16, treeChance: 0.04, treeTypes: ['swamp', 'swamp', 'oak'], color: '#4A5D23' },
        { name: 'Mountains', surface: 19, treeChance: 0.006, treeTypes: ['spruce', 'pine', 'spruce'], color: '#6B6B6B' },
        { name: 'Savanna', surface: 20, treeChance: 0.008, treeTypes: ['acacia', 'acacia', 'oak'], color: '#B8A862' },
        { name: 'Taiga', surface: 21, treeChance: 0.06, treeTypes: ['spruce', 'spruce', 'pine', 'spruce'], color: '#4A6B4A' },
        { name: 'Badlands', surface: 22, treeChance: 0.001, treeTypes: ['none', 'oak'], color: '#C45C3E' },
        { name: 'Mushroom', surface: 23, treeChance: 0.05, treeTypes: ['mushroom', 'mushroom', 'mushroom'], color: '#8B5A8B' },
        { name: 'Cherry', surface: 1, treeChance: 0.055, treeTypes: ['cherry', 'cherry', 'oak'], color: '#FFB7C5' },
        { name: 'Volcanic', surface: 24, treeChance: 0, treeTypes: ['none'], color: '#2A2A2A' },
        { name: 'Bamboo', surface: 1, treeChance: 0.12, treeTypes: ['bamboo', 'bamboo', 'jungle', 'bamboo'], color: '#7CCD7C' },
        { name: 'Coral', surface: 6, treeChance: 0.06, treeTypes: ['coral', 'coral', 'coral'], color: '#FF6B9D' }
    ];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WORLD NAR (same as before, abbreviated)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class WorldNAR extends PureNARTransformer {
        constructor(seed) {
            super(16, 48, 17, 1, seed);  // Reduced: 48 hidden, 1 layer
            this.simplex = new SimplexNoise(seed);
            this.cache = new Map();
            this.currentMix = new Float32Array(NUM_BIOMES);
        }
        
        encodePos(x, z) {
            const t = new Float32Array(16);
            t.set(this.logUnaryEncode(Math.floor(x), 8), 0);
            t.set(this.logUnaryEncode(Math.floor(z), 8), 8);
            return t;
        }
        
        softmax(logits) {
            let max = -Infinity;
            for (let i = 0; i < logits.length; i++) max = Math.max(max, logits[i]);
            const exp = logits.map(l => Math.exp(l - max));
            const sum = exp.reduce((a, b) => a + b, 0);
            return exp.map(e => e / (sum + 1e-8));
        }
        
        mixBiomes(weights, x = 0, z = 0) {
            let surface = 0, treeChance = 0;
            let allTreeTypes = [];
            
            for (let i = 0; i < NUM_BIOMES; i++) {
                const w = weights[i];
                if (w < 0.01) continue;
                const b = BIOME_DATA[i];
                surface += b.surface * w;
                treeChance += b.treeChance * w;
                // Add tree types weighted by biome weight
                if (b.treeTypes) {
                    for (const tt of b.treeTypes) {
                        if (tt !== 'none') {
                            for (let j = 0; j < Math.ceil(w * 10); j++) allTreeTypes.push(tt);
                        }
                    }
                }
            }
            
            // Pick tree type based on position for variety (simple hash)
            let treeType = 'none';
            if (allTreeTypes.length > 0) {
                const hash = Math.sin(x * 12.9898 + z * 78.233 + 12345) * 43758.5453;
                const idx = Math.floor((hash - Math.floor(hash)) * allTreeTypes.length);
                treeType = allTreeTypes[idx];
            }
            
            let dominant = 0;
            for (let i = 1; i < NUM_BIOMES; i++) if (weights[i] > weights[dominant]) dominant = i;
            
            return { surface: Math.round(surface), treeChance, treeType, dominant, weights };
        }
        
        generateChunk(cx, cz) {
            const key = `${cx},${cz}`;
            if (this.cache.has(key)) return this.cache.get(key);
            
            const batch = 256;
            const input = new Float32Array(batch * 16);
            const startX = cx * 16, startZ = cz * 16;
            
            for (let i = 0; i < batch; i++) {
                const lx = Math.floor(i / 16), lz = i % 16;
                input.set(this.encodePos(startX + lx, startZ + lz), i * 16);
            }
            
            const { out } = this.forward(input, batch);
            const results = [];
            
            for (let i = 0; i < batch; i++) {
                const lx = Math.floor(i / 16), lz = i % 16;
                const worldX = startX + lx, worldZ = startZ + lz;
                const height = Math.max(3, Math.min(32, Math.round(14 + Math.tanh(out[i * 17]) * 16)));
                const biomeLogits = [];
                for (let b = 0; b < NUM_BIOMES; b++) biomeLogits.push(out[i * 17 + 1 + b]);
                const weights = this.softmax(biomeLogits);
                const mixed = this.mixBiomes(weights, worldX, worldZ);
                results.push({ height, ...mixed });
            }
            
            const data = { results, startX, startZ };
            this.cache.set(key, data);
            return data;
        }
        
        generate(x, z) {
            const cx = Math.floor(x / 16), cz = Math.floor(z / 16);
            const data = this.generateChunk(cx, cz);
            const lx = ((Math.floor(x) % 16) + 16) % 16;
            const lz = ((Math.floor(z) % 16) + 16) % 16;
            const result = data.results[lx * 16 + lz];
            this.currentMix = result.weights;
            return result;
        }
        
        getTargetBiomeWeights(x, z) {
            const cont = this.simplex.noise2D(x * 0.005, z * 0.005);
            const temp = this.simplex.noise2D(x * 0.01 + 500, z * 0.01 + 500);
            const moist = this.simplex.noise2D(x * 0.012 + 1000, z * 0.012 + 1000);
            const weird = this.simplex.noise2D(x * 0.02 + 2000, z * 0.02 + 2000);
            const volcanic = this.simplex.noise2D(x * 0.03 + 3000, z * 0.03 + 3000);
            
            const weights = new Float32Array(NUM_BIOMES);
            weights[0] = Math.max(0, 0.5 - Math.abs(temp) - Math.abs(moist) * 0.5);
            weights[1] = Math.max(0, temp * 0.8 - moist * 0.5);
            weights[2] = Math.max(0, moist * 0.6 + 0.2 - Math.abs(temp) * 0.3);
            weights[3] = Math.max(0, -temp * 0.8 - moist * 0.3);
            weights[4] = Math.max(0, -cont * 1.5 - 0.3);
            weights[5] = Math.max(0, temp * 0.5 + moist * 0.5 - 0.2);
            weights[6] = Math.max(0, moist * 0.7 - Math.abs(temp) * 0.3 - 0.1);
            weights[7] = Math.max(0, weird * 0.8 + cont * 0.3 - 0.2);
            weights[8] = Math.max(0, temp * 0.4 - moist * 0.2 + 0.1);
            weights[9] = Math.max(0, -temp * 0.4 + moist * 0.3);
            weights[10] = Math.max(0, temp * 0.5 + weird * 0.3 - moist * 0.5 - 0.2);
            weights[11] = Math.max(0, weird * 0.6 + moist * 0.3 - Math.abs(temp) * 0.5);
            weights[12] = Math.max(0, temp * 0.3 + moist * 0.2 + weird * 0.2 - 0.3);
            weights[13] = Math.max(0, volcanic - 0.5);
            weights[14] = Math.max(0, temp * 0.4 + moist * 0.6 - weird * 0.2 - 0.3);
            weights[15] = Math.max(0, -cont * 0.8 + temp * 0.3 - 0.4);
            
            let sum = 0;
            for (let i = 0; i < NUM_BIOMES; i++) sum += weights[i];
            if (sum < 0.01) { weights[0] = 1; sum = 1; }
            for (let i = 0; i < NUM_BIOMES; i++) weights[i] /= sum;
            
            let height = 14 + cont * 8 + weights[4] * -8 + weights[7] * 10 + weights[13] * 4;
            height += this.simplex.noise2D(x * 0.05, z * 0.05) * 4;
            
            return { height: Math.max(3, Math.min(32, height)), weights };
        }
        
        train(samples) {
            const batch = samples.length;
            const input = new Float32Array(batch * 16);
            const targets = [];
            
            for (let i = 0; i < batch; i++) {
                input.set(this.encodePos(samples[i][0], samples[i][1]), i * 16);
                targets.push(this.getTargetBiomeWeights(samples[i][0], samples[i][1]));
            }
            
            const { h, out } = this.forward(input, batch);
            let loss = 0;
            const gWout = new Float32Array(this.hiddenDim * 17);
            
            for (let b = 0; b < batch; b++) {
                const t = targets[b];
                const predH = 14 + Math.tanh(out[b * 17]) * 16;
                loss += (predH - t.height) ** 2 * 0.1;
                
                const tg = 1 - Math.tanh(out[b * 17]) ** 2;
                const dH = Math.max(-1, Math.min(1, 2 * (predH - t.height) * 16 * tg * 0.005));
                
                const biomeLogits = [];
                for (let i = 0; i < NUM_BIOMES; i++) biomeLogits.push(out[b * 17 + 1 + i]);
                const predW = this.softmax(biomeLogits);
                
                for (let i = 0; i < NUM_BIOMES; i++) {
                    loss -= t.weights[i] * Math.log(predW[i] + 1e-7) * 0.5;
                }
                
                for (let i = 0; i < this.hiddenDim; i++) {
                    gWout[i * 17] += dH * h[b * this.hiddenDim + i];
                    for (let j = 0; j < NUM_BIOMES; j++) {
                        const dB = (predW[j] - t.weights[j]) * 0.08;
                        gWout[i * 17 + 1 + j] += dB * h[b * this.hiddenDim + i];
                    }
                }
            }
            
            this.updateWeights({ Wout: gWout }, batch);
            this.epochs++;
            return loss / batch;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEXTURE NAR (abbreviated)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class TextureNAR extends PureNARTransformer {
        constructor(seed) {
            super(16, 24, 3, 1, seed);  // Reduced: 24 hidden, 1 layer
            this.texSize = 8;
            this.cache = new Map();
            this.simplex = new SimplexNoise(seed + 100);
        }
        
        encodePixel(blockType, u, v, face) {
            const t = new Float32Array(16);
            t.set(this.logUnaryEncode(blockType, 5), 0);
            t.set(this.logUnaryEncode(u, 4), 5);
            t.set(this.logUnaryEncode(v, 4), 9);
            t.set(this.logUnaryEncode(face, 3), 13);
            return t;
        }
        
        generateTexture(blockType, face) {
            const key = `${blockType}-${face}`;
            if (this.cache.has(key)) return this.cache.get(key);
            
            const size = this.texSize, batch = size * size;
            const input = new Float32Array(batch * 16);
            
            for (let v = 0; v < size; v++)
                for (let u = 0; u < size; u++)
                    input.set(this.encodePixel(blockType, u, v, face), (v * size + u) * 16);
            
            const { out } = this.forward(input, batch);
            
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(size, size);
            
            for (let i = 0; i < batch; i++) {
                imgData.data[i * 4] = Math.max(0, Math.min(255, Math.round((Math.tanh(out[i * 3]) * 0.5 + 0.5) * 255)));
                imgData.data[i * 4 + 1] = Math.max(0, Math.min(255, Math.round((Math.tanh(out[i * 3 + 1]) * 0.5 + 0.5) * 255)));
                imgData.data[i * 4 + 2] = Math.max(0, Math.min(255, Math.round((Math.tanh(out[i * 3 + 2]) * 0.5 + 0.5) * 255)));
                imgData.data[i * 4 + 3] = 255;
            }
            
            ctx.putImageData(imgData, 0, 0);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            
            this.cache.set(key, { canvas, tex });
            return { canvas, tex };
        }
        
        getTargetRGB(bt, u, v, face) {
            const noise = (x, y, sc) => this.simplex.noise2D(x * sc, y * sc) * 0.5 + 0.5;
            const n = noise(u, v, 3);
            const patterns = {
                1: face === 0 ? [0.2 + n*0.1, 0.55 + n*0.15, 0.15] : [0.45, 0.35, 0.2],
                2: [0.45 + n*0.15, 0.35, 0.2], 3: [0.45 + n*0.15, 0.45 + n*0.15, 0.48],
                4: face === 0 ? [0.55, 0.35, 0.18] : [0.4 + n*0.1, 0.25, 0.12],
                5: [0.1, 0.4 + n*0.2, 0.12], 6: [0.85 + n*0.1, 0.78, 0.55],
                7: [0.1, 0.35 + n*0.15, 0.6], 8: [0.65, 0.25, 0.2], 9: [0.7, 0.85, 0.95],
                10: [0.92, 0.94, 0.98], 11: [0.45 + n*0.2, 0.42, 0.4],
                12: [0.5, 0.32, 0.15], 13: [0.5, 0.32, 0.15],
                14: [0.3, 0.22, 0.12], 15: [0.05, 0.32, 0.1], 16: [0.32 + n*0.1, 0.22, 0.12],
                17: [0.2, 0.4, 0.15], 18: [0.6, 0.8, 0.9], 19: [0.35, 0.35, 0.38],
                20: [0.7 + n*0.1, 0.65, 0.35], 21: [0.25, 0.4 + n*0.1, 0.25],
                22: [0.75, 0.45, 0.3], 23: [0.55 + n*0.1, 0.45, 0.55],
                24: [0.15 + n*0.1, 0.12, 0.12], 25: [1.0, 0.7 + n*0.15, 0.75],
                26: [0.4, 0.6 + n*0.1, 0.3], 27: [1.0 * n + 0.4, 0.4 * n + 0.2, 0.6],
                28: [0.55, 0.35, 0.2], 29: [0.7, 0.15, 0.15]
            };
            return patterns[bt] || [0.5, 0.5, 0.5];
        }
        
        train(samples) {
            const batch = samples.length;
            const input = new Float32Array(batch * 16);
            const targets = [];
            
            for (let i = 0; i < batch; i++) {
                const [bt, u, v, face] = samples[i];
                input.set(this.encodePixel(bt, u, v, face), i * 16);
                targets.push(this.getTargetRGB(bt, u, v, face));
            }
            
            const { h, out } = this.forward(input, batch);
            let loss = 0;
            const gWout = new Float32Array(this.hiddenDim * 3);
            
            for (let b = 0; b < batch; b++) {
                for (let c = 0; c < 3; c++) {
                    const pred = Math.tanh(out[b * 3 + c]) * 0.5 + 0.5;
                    const err = pred - targets[b][c];
                    loss += err * err;
                    const tg = 1 - Math.tanh(out[b * 3 + c]) ** 2;
                    for (let i = 0; i < this.hiddenDim; i++)
                        gWout[i * 3 + c] += err * tg * 0.5 * h[b * this.hiddenDim + i];
                }
            }
            
            this.updateWeights({ Wout: gWout }, batch);
            this.epochs++;
            return loss / batch;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MUSIC NAR (abbreviated)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class MusicNAR extends PureNARTransformer {
        constructor(seed) {
            super(16, 20, 12, 1, seed);  // Reduced: 20 hidden, 1 layer
            this.scales = { 
                pentatonic: [0,2,4,7,9], 
                major: [0,2,4,5,7,9,11], 
                minor: [0,2,3,5,7,8,10],
                dorian: [0,2,3,5,7,9,10]
            };
            this.baseFreq = 130.81;
            this.chordProgs = [[0,3,4,0], [0,5,3,4], [0,4,5,3]];
            this.progIdx = 0; this.chordIdx = 0; this.beat = 0;
            this.vizBars = [];
            this.lastNote = 4;
        }
        
        generate(biomeMix) {
            // Pick scale based on dominant biome
            let dominant = 0;
            for (let i = 1; i < biomeMix.length; i++) if (biomeMix[i] > biomeMix[dominant]) dominant = i;
            const scaleNames = ['major', 'dorian', 'pentatonic', 'minor', 'major', 'pentatonic', 'minor', 'dorian'];
            const scale = this.scales[scaleNames[dominant % scaleNames.length]] || this.scales.pentatonic;
            
            // Voice leading - prefer steps
            let noteIdx = this.lastNote + Math.floor(this.rng() * 3) - 1;
            noteIdx = Math.max(0, Math.min(scale.length - 1, noteIdx));
            
            const octave = Math.floor(this.rng() * 2);
            const freq = this.baseFreq * Math.pow(2, (scale[noteIdx] + octave * 12) / 12);
            const duration = 0.15 + this.rng() * 0.25;
            let velocity = 0.35 + this.rng() * 0.15;
            if (this.beat === 0) velocity += 0.12;
            if (this.beat === 2) velocity += 0.06;
            
            this.lastNote = noteIdx;
            return { freq, duration, velocity, noteIdx };
        }
        
        advance() {
            this.beat++;
            if (this.beat >= 4) { 
                this.beat = 0; 
                this.chordIdx = (this.chordIdx + 1) % 4;
                if (this.chordIdx === 0 && this.rng() < 0.2) {
                    this.progIdx = Math.floor(this.rng() * this.chordProgs.length);
                }
            }
            const names = ['I', 'ii', 'iii', 'IV', 'V', 'vi'];
            document.getElementById('current-chord').textContent = names[this.chordProgs[this.progIdx][this.chordIdx]] || 'I';
        }
        
        playNote(freq, dur, vel) {
            if (!audioCtx || !musicEnabled) return;
            
            // Resume audio context if needed
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = this.rng() < 0.7 ? 'sine' : 'triangle';
            osc.frequency.setValueAtTime(freq, now);
            
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(vel * 0.3, now + 0.02);
            gain.gain.setValueAtTime(vel * 0.3, now + dur * 0.6);
            gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
            
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(now);
            osc.stop(now + dur + 0.05);
            
            // Occasional bass on beat 1
            if (this.beat === 0 && this.rng() < 0.35) {
                const bassOsc = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bassOsc.type = 'sine';
                bassOsc.frequency.setValueAtTime(freq / 2, now);
                bassGain.gain.setValueAtTime(0, now);
                bassGain.gain.linearRampToValueAtTime(vel * 0.2, now + 0.03);
                bassGain.gain.exponentialRampToValueAtTime(0.001, now + dur * 1.2);
                bassOsc.connect(bassGain);
                bassGain.connect(masterGain);
                bassOsc.start(now);
                bassOsc.stop(now + dur * 1.2 + 0.05);
            }
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIME NAR - LEARNS DAY/NIGHT CYCLE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class TimeNAR extends PureNARTransformer {
        constructor(seed) {
            // Input: time(8) = 8 bits log-unary for time of day (0-1440 minutes)
            // Output: sunAngle, sunHeight, skyR, skyG, skyB, ambientLight, fogDensity = 7
            super(8, 24, 7, 1, seed);
            this.dayLength = 600; // 10 minutes real time = 1 game day
            this.gameTime = 360; // Start at 6:00 AM (360 minutes)
            this.lastUpdate = performance.now();
        }
        
        encodeTime(minutes) {
            const input = new Float32Array(8);
            const normalized = Math.floor((minutes / 1440) * 255);
            input.set(this.logUnaryEncode(normalized, 8), 0);
            return input;
        }
        
        getTargetEnvironment(minutes) {
            const hour = minutes / 60;
            
            // Sun angle (0 = east, 0.5 = zenith, 1 = west)
            let sunAngle, sunHeight;
            if (hour >= 6 && hour <= 18) {
                sunAngle = (hour - 6) / 12;
                sunHeight = Math.sin(((hour - 6) / 12) * Math.PI);
            } else {
                const nightHour = hour < 6 ? hour + 6 : hour - 18;
                sunAngle = 0.5 + (nightHour / 12) * 0.5;
                sunHeight = -0.3;
            }
            
            // Sky color
            let skyR, skyG, skyB;
            if (hour >= 7 && hour <= 17) {
                skyR = 0.53; skyG = 0.81; skyB = 0.92;
            } else if ((hour >= 5 && hour < 7) || (hour > 17 && hour <= 19)) {
                const t = hour < 12 ? (hour - 5) / 2 : (19 - hour) / 2;
                skyR = 0.9 - t * 0.37; skyG = 0.4 + t * 0.41; skyB = 0.5 + t * 0.42;
            } else {
                skyR = 0.05; skyG = 0.05; skyB = 0.15;
            }
            
            // Ambient light
            let ambientLight;
            if (hour >= 7 && hour <= 17) ambientLight = 1.0;
            else if ((hour >= 5 && hour < 7) || (hour > 17 && hour <= 19)) {
                const t = hour < 12 ? (hour - 5) / 2 : (19 - hour) / 2;
                ambientLight = 0.3 + t * 0.7;
            } else ambientLight = 0.25;
            
            // Fog density
            let fogDensity = hour >= 7 && hour <= 17 ? 0.3 : 0.6;
            
            return { sunAngle, sunHeight, skyR, skyG, skyB, ambientLight, fogDensity };
        }
        
        generateTrainingSamples(n) {
            const samples = [];
            for (let i = 0; i < n; i++) samples.push(Math.floor(this.rng() * 1440));
            return samples;
        }
        
        train(samples) {
            const batch = samples.length;
            const input = new Float32Array(batch * 8);
            const targets = [];
            
            for (let i = 0; i < batch; i++) {
                input.set(this.encodeTime(samples[i]), i * 8);
                targets.push(this.getTargetEnvironment(samples[i]));
            }
            
            const { h, out } = this.forward(input, batch);
            let loss = 0;
            const gWout = new Float32Array(this.hiddenDim * 7);
            
            for (let b = 0; b < batch; b++) {
                const t = targets[b];
                const targetArr = [t.sunAngle, t.sunHeight, t.skyR, t.skyG, t.skyB, t.ambientLight, t.fogDensity];
                
                for (let o = 0; o < 7; o++) {
                    const pred = o === 1 ? Math.tanh(out[b * 7 + o]) : Math.tanh(out[b * 7 + o]) * 0.5 + 0.5;
                    const target = o === 1 ? targetArr[o] : targetArr[o];
                    const err = pred - target;
                    loss += err * err;
                    const tg = 1 - Math.tanh(out[b * 7 + o]) ** 2;
                    for (let i = 0; i < this.hiddenDim; i++) {
                        gWout[i * 7 + o] += err * tg * 0.5 * h[b * this.hiddenDim + i];
                    }
                }
            }
            
            this.updateWeights({ Wout: gWout }, batch);
            this.epochs++;
            return loss / batch;
        }
        
        simulate() {
            const input = this.encodeTime(this.gameTime);
            const { out } = this.forward(input, 1);
            
            return {
                sunAngle: Math.tanh(out[0]) * 0.5 + 0.5,
                sunHeight: Math.tanh(out[1]),
                skyR: Math.max(0, Math.min(1, Math.tanh(out[2]) * 0.5 + 0.5)),
                skyG: Math.max(0, Math.min(1, Math.tanh(out[3]) * 0.5 + 0.5)),
                skyB: Math.max(0, Math.min(1, Math.tanh(out[4]) * 0.5 + 0.5)),
                ambientLight: Math.max(0.2, Math.min(1, Math.tanh(out[5]) * 0.5 + 0.5)),
                fogDensity: Math.max(0.2, Math.min(0.8, Math.tanh(out[6]) * 0.5 + 0.5))
            };
        }
        
        advance() {
            const now = performance.now();
            const deltaMs = now - this.lastUpdate;
            this.lastUpdate = now;
            const gameMinutes = (deltaMs / 1000) * (1440 / this.dayLength);
            this.gameTime = (this.gameTime + gameMinutes) % 1440;
        }
        
        getTimeString() {
            const hours = Math.floor(this.gameTime / 60);
            const mins = Math.floor(this.gameTime % 60);
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
        }
        
        getPeriod() {
            const hour = this.gameTime / 60;
            if (hour >= 5 && hour < 7) return 'ğŸŒ… Dawn';
            if (hour >= 7 && hour < 17) return 'â˜€ï¸ Day';
            if (hour >= 17 && hour < 19) return 'ğŸŒ‡ Dusk';
            return 'ğŸŒ™ Night';
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ADVANCED PERFORMANCE TENSOR TRANSFORMER
    // Multi-head attention, temporal state, predictive modeling
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class PerformanceNAR {
        constructor(seed) {
            // Architecture params
            this.inputDim = 32;      // Expanded input encoding
            this.hiddenDim = 48;     // Larger hidden
            this.numHeads = 4;       // Multi-head attention
            this.headDim = 12;       // Hidden / numHeads
            this.numLayers = 2;      // Deeper network
            this.outputDim = 16;     // 16 control outputs
            this.seqLen = 8;         // Temporal sequence length
            
            this.epochs = 0;
            this.lr = 0.004;
            this.targetFPS = 55;
            
            // Seeded RNG
            this.seed = seed;
            this.rng = () => { this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff; return this.seed / 0x7fffffff; };
            
            // Temporal state buffer (sliding window of past states)
            this.stateBuffer = [];
            this.maxBufferSize = this.seqLen;
            
            // Performance history for training
            this.history = [];
            this.maxHistory = 120;
            
            // FPS tracking with exponential smoothing
            this.smoothedFPS = 60;
            this.fpsVariance = 0;
            this.fpsBuffer = [];
            this.frameCount = 0;
            
            // Metrics
            this.metrics = {
                avgFPS: 60, minFPS: 60, maxFPS: 60,
                smoothness: 1.0, trend: 0, prediction: 60
            };
            
            // Initialize weights
            this.initWeights();
            
            // All controllable settings
            this.settings = {
                renderDistance: 4, chunkRate: 2, trainFrequency: 180,
                skipRender: 0, fogNear: 35, fogFar: 80,
                musicFrequency: 12, physicsRate: 1, meshLOD: 1.0,
                cleanupFrequency: 60, shadowIntensity: 1.0, decorDensity: 1.0,
                batchSize: 12, cameraFar: 100, particleCount: 1.0, audioQuality: 1.0
            };
            
            // Bounds
            this.bounds = {
                renderDistance: [2, 8], chunkRate: [1, 6], trainFrequency: [60, 600],
                skipRender: [0, 4], fogNear: [10, 60], fogFar: [40, 150],
                musicFrequency: [6, 40], physicsRate: [1, 4], meshLOD: [0.3, 1.0],
                cleanupFrequency: [20, 150], shadowIntensity: [0.1, 1.0], decorDensity: [0.2, 1.0],
                batchSize: [4, 20], particleCount: [0.2, 1.0], audioQuality: [0.3, 1.0]
            };
        }
        
        // Log-unary tensor encoding with sign
        logUnaryEncode(val, bits) {
            const t = new Float32Array(bits);
            const v = Math.abs(Math.floor(val));
            const ones = v === 0 ? 0 : Math.min(bits - 1, Math.ceil(Math.log2(v + 1)));
            for (let i = 0; i < ones; i++) t[i] = 1;
            if (val < 0) t[bits - 1] = -1;
            return t;
        }
        
        // Multi-scale encoding for better representation
        multiScaleEncode(val, scales, bitsPerScale) {
            const result = new Float32Array(scales * bitsPerScale);
            for (let s = 0; s < scales; s++) {
                const scaled = val * Math.pow(2, s);
                result.set(this.logUnaryEncode(scaled, bitsPerScale), s * bitsPerScale);
            }
            return result;
        }
        
        initWeights() {
            const he = n => Math.sqrt(2/n);
            
            // Input projection (expanded)
            this.Wemb = this.randMat(this.inputDim, this.hiddenDim, he(this.inputDim));
            this.bemb = new Float32Array(this.hiddenDim);
            
            // Positional encoding for temporal sequence
            this.posEnc = new Float32Array(this.seqLen * this.hiddenDim);
            for (let pos = 0; pos < this.seqLen; pos++) {
                for (let i = 0; i < this.hiddenDim; i++) {
                    const angle = pos / Math.pow(10000, (2 * (i >> 1)) / this.hiddenDim);
                    this.posEnc[pos * this.hiddenDim + i] = (i % 2 === 0) ? Math.sin(angle) : Math.cos(angle);
                }
            }
            
            // Multi-head attention layers
            this.layers = [];
            for (let l = 0; l < this.numLayers; l++) {
                this.layers.push({
                    // Q, K, V projections for multi-head
                    Wq: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    Wk: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    Wv: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    Wo: this.randMat(this.hiddenDim, this.hiddenDim, he(this.hiddenDim)),
                    // FFN
                    W1: this.randMat(this.hiddenDim, this.hiddenDim * 2, he(this.hiddenDim)),
                    b1: new Float32Array(this.hiddenDim * 2),
                    W2: this.randMat(this.hiddenDim * 2, this.hiddenDim, he(this.hiddenDim * 2)),
                    b2: new Float32Array(this.hiddenDim),
                    // Layer norm params
                    gamma1: this.onesArray(this.hiddenDim),
                    beta1: new Float32Array(this.hiddenDim),
                    gamma2: this.onesArray(this.hiddenDim),
                    beta2: new Float32Array(this.hiddenDim)
                });
            }
            
            // Output projection with gating
            this.Wgate = this.randMat(this.hiddenDim, this.outputDim, he(this.hiddenDim));
            this.Wout = this.randMat(this.hiddenDim, this.outputDim, he(this.hiddenDim));
            this.bout = new Float32Array(this.outputDim);
            
            // Prediction head (forecasts future FPS)
            this.Wpred = this.randMat(this.hiddenDim, 4, he(this.hiddenDim)); // Predict next 4 timesteps
        }
        
        onesArray(n) { const a = new Float32Array(n); a.fill(1); return a; }
        
        randMat(rows, cols, scale) {
            const w = new Float32Array(rows * cols);
            for (let i = 0; i < w.length; i++) w[i] = (this.rng() * 2 - 1) * scale;
            return { w, rows, cols };
        }
        
        matMul(input, M, batch) {
            const out = new Float32Array(batch * M.cols);
            const inDim = M.rows, outDim = M.cols;
            for (let b = 0; b < batch; b++) {
                const bIn = b * inDim, bOut = b * outDim;
                for (let j = 0; j < outDim; j++) {
                    let sum = 0;
                    for (let i = 0; i < inDim; i++) sum += input[bIn + i] * M.w[i * outDim + j];
                    out[bOut + j] = Math.max(-8, Math.min(8, sum));
                }
            }
            return out;
        }
        
        addBias(x, bias, dim, batch) {
            for (let i = 0; i < batch * dim; i++) x[i] += bias[i % dim];
        }
        
        layerNorm(x, gamma, beta, dim, batch) {
            for (let b = 0; b < batch; b++) {
                const off = b * dim;
                let mean = 0, vari = 0;
                for (let i = 0; i < dim; i++) mean += x[off + i];
                mean /= dim;
                for (let i = 0; i < dim; i++) { const d = x[off + i] - mean; vari += d * d; }
                const invStd = 1 / Math.sqrt(vari / dim + 1e-5);
                for (let i = 0; i < dim; i++) {
                    x[off + i] = gamma[i] * (x[off + i] - mean) * invStd + beta[i];
                }
            }
        }
        
        gelu(x) {
            for (let i = 0; i < x.length; i++) {
                const v = x[i];
                x[i] = 0.5 * v * (1 + Math.tanh(Math.sqrt(2/Math.PI) * (v + 0.044715 * v * v * v)));
            }
        }
        
        softmax(x, len) {
            let max = -Infinity;
            for (let i = 0; i < len; i++) if (x[i] > max) max = x[i];
            let sum = 0;
            for (let i = 0; i < len; i++) { x[i] = Math.exp(x[i] - max); sum += x[i]; }
            for (let i = 0; i < len; i++) x[i] /= sum + 1e-8;
        }
        
        // Multi-head self-attention
        multiHeadAttention(h, layer, seqLen) {
            const d = this.hiddenDim;
            const heads = this.numHeads;
            const headDim = this.headDim;
            
            // Project Q, K, V
            const Q = this.matMul(h, layer.Wq, seqLen);
            const K = this.matMul(h, layer.Wk, seqLen);
            const V = this.matMul(h, layer.Wv, seqLen);
            
            // Attention output
            const attnOut = new Float32Array(seqLen * d);
            
            // For each head
            for (let head = 0; head < heads; head++) {
                const headOff = head * headDim;
                
                // Compute attention scores
                for (let i = 0; i < seqLen; i++) {
                    const scores = new Float32Array(seqLen);
                    
                    for (let j = 0; j < seqLen; j++) {
                        let score = 0;
                        for (let k = 0; k < headDim; k++) {
                            score += Q[i * d + headOff + k] * K[j * d + headOff + k];
                        }
                        scores[j] = score / Math.sqrt(headDim);
                    }
                    
                    // Softmax
                    this.softmax(scores, seqLen);
                    
                    // Weighted sum of V
                    for (let k = 0; k < headDim; k++) {
                        let sum = 0;
                        for (let j = 0; j < seqLen; j++) {
                            sum += scores[j] * V[j * d + headOff + k];
                        }
                        attnOut[i * d + headOff + k] = sum;
                    }
                }
            }
            
            // Output projection
            const out = this.matMul(attnOut, layer.Wo, seqLen);
            return out;
        }
        
        // Encode current state with multi-scale representation
        encodeState(fps, velocity, chunks, deltaTime, memPressure, timeOfDay, musicActive, trend) {
            const input = new Float32Array(this.inputDim);
            let idx = 0;
            
            // FPS (multi-scale: 0-120 range)
            input.set(this.multiScaleEncode(fps, 2, 4), idx); idx += 8;
            
            // Velocity (0-2 range)
            input.set(this.logUnaryEncode(velocity * 20, 4), idx); idx += 4;
            
            // Chunks visible (0-100)
            input.set(this.logUnaryEncode(chunks, 5), idx); idx += 5;
            
            // Delta time (ms, 0-100)
            input.set(this.logUnaryEncode(deltaTime, 4), idx); idx += 4;
            
            // Memory pressure (0-1)
            input.set(this.logUnaryEncode(memPressure * 15, 3), idx); idx += 3;
            
            // Time of day (0-1)
            input.set(this.logUnaryEncode(timeOfDay * 7, 2), idx); idx += 2;
            
            // Music active
            input[idx++] = musicActive ? 1 : 0;
            
            // FPS trend (-1 to 1)
            input.set(this.logUnaryEncode(trend * 8, 3), idx); idx += 3;
            
            // Smoothness (0-1)
            input.set(this.logUnaryEncode(this.metrics.smoothness * 7, 2), idx);
            
            return input;
        }
        
        forward(stateSequence) {
            const seqLen = stateSequence.length;
            
            // Embed all states
            const embedded = new Float32Array(seqLen * this.hiddenDim);
            for (let t = 0; t < seqLen; t++) {
                const emb = this.matMul(stateSequence[t], this.Wemb, 1);
                this.addBias(emb, this.bemb, this.hiddenDim, 1);
                
                // Add positional encoding
                for (let i = 0; i < this.hiddenDim; i++) {
                    embedded[t * this.hiddenDim + i] = emb[i] + this.posEnc[t * this.hiddenDim + i] * 0.1;
                }
            }
            
            let h = embedded;
            
            // Process through transformer layers
            for (const layer of this.layers) {
                // Pre-norm
                const h1 = new Float32Array(h);
                this.layerNorm(h1, layer.gamma1, layer.beta1, this.hiddenDim, seqLen);
                
                // Multi-head self-attention
                const attn = this.multiHeadAttention(h1, layer, seqLen);
                
                // Residual
                for (let i = 0; i < h.length; i++) h[i] += attn[i] * 0.5;
                
                // Pre-norm for FFN
                const h2 = new Float32Array(h);
                this.layerNorm(h2, layer.gamma2, layer.beta2, this.hiddenDim, seqLen);
                
                // FFN with GELU
                const ff = this.matMul(h2, layer.W1, seqLen);
                this.addBias(ff, layer.b1, this.hiddenDim * 2, seqLen);
                this.gelu(ff);
                const ff2 = this.matMul(ff, layer.W2, seqLen);
                this.addBias(ff2, layer.b2, this.hiddenDim, seqLen);
                
                // Residual
                for (let i = 0; i < h.length; i++) h[i] += ff2[i] * 0.5;
            }
            
            // Use last hidden state for output
            const lastH = h.slice((seqLen - 1) * this.hiddenDim, seqLen * this.hiddenDim);
            
            // Gated output
            const gate = this.matMul(lastH, this.Wgate, 1);
            for (let i = 0; i < gate.length; i++) gate[i] = 1 / (1 + Math.exp(-gate[i])); // Sigmoid
            
            const out = this.matMul(lastH, this.Wout, 1);
            this.addBias(out, this.bout, this.outputDim, 1);
            
            // Apply gate
            for (let i = 0; i < out.length; i++) out[i] *= gate[i];
            
            // Prediction head
            const pred = this.matMul(lastH, this.Wpred, 1);
            
            return { h: lastH, out, pred };
        }
        
        getTargetSettings(fps, velocity, memPressure, musicActive, trend) {
            const ratio = fps / this.targetFPS;
            const isStressed = ratio < 0.75 || trend < -0.2;
            const isComfortable = ratio > 1.2 && trend >= 0;
            const isMovingFast = velocity > 0.9;
            
            let t = {};
            
            // 7 FPS regimes for finer control
            if (ratio < 0.35) {
                // Critical
                t = { rd:0.0, cr:0.0, tf:1.0, sk:0.9, fn:0.1, ff:0.2, mf:1.0, pr:1.0, 
                      lod:0.0, cf:0.0, si:0.0, dd:0.0, bs:0.0, pc:0.0, aq:0.0 };
            } else if (ratio < 0.5) {
                t = { rd:0.1, cr:0.1, tf:0.9, sk:0.7, fn:0.2, ff:0.3, mf:0.9, pr:0.8,
                      lod:0.1, cf:0.1, si:0.1, dd:0.1, bs:0.1, pc:0.1, aq:0.2 };
            } else if (ratio < 0.65) {
                t = { rd:0.2, cr:0.2, tf:0.8, sk:0.5, fn:0.3, ff:0.4, mf:0.7, pr:0.6,
                      lod:0.3, cf:0.2, si:0.3, dd:0.3, bs:0.2, pc:0.3, aq:0.4 };
            } else if (ratio < 0.8) {
                t = { rd:0.35, cr:0.35, tf:0.65, sk:0.25, fn:0.4, ff:0.5, mf:0.5, pr:0.4,
                      lod:0.5, cf:0.35, si:0.5, dd:0.5, bs:0.4, pc:0.5, aq:0.6 };
            } else if (ratio < 1.0) {
                t = { rd:0.5, cr:0.5, tf:0.5, sk:0.1, fn:0.5, ff:0.6, mf:0.35, pr:0.25,
                      lod:0.7, cf:0.5, si:0.7, dd:0.7, bs:0.5, pc:0.7, aq:0.8 };
            } else if (ratio < 1.25) {
                t = { rd:0.65, cr:0.6, tf:0.35, sk:0.0, fn:0.6, ff:0.7, mf:0.25, pr:0.15,
                      lod:0.85, cf:0.6, si:0.85, dd:0.85, bs:0.65, pc:0.85, aq:0.9 };
            } else {
                // Excellent FPS
                t = { rd:0.85, cr:0.8, tf:0.2, sk:0.0, fn:0.7, ff:0.85, mf:0.15, pr:0.0,
                      lod:1.0, cf:0.75, si:1.0, dd:1.0, bs:0.85, pc:1.0, aq:1.0 };
            }
            
            // Trend adjustments
            if (trend < -0.15) {
                // FPS dropping - preemptively reduce
                t.rd *= 0.85; t.lod *= 0.9; t.tf = Math.min(1, t.tf + 0.1);
            } else if (trend > 0.15) {
                // FPS rising - can increase quality
                t.rd = Math.min(1, t.rd * 1.1); t.lod = Math.min(1, t.lod * 1.05);
            }
            
            // Movement adjustments
            if (isMovingFast) {
                t.rd *= 0.85; t.lod *= 0.9; t.dd *= 0.7;
            }
            
            // Memory pressure
            if (memPressure > 0.6) {
                t.rd *= 0.8; t.cf = Math.max(0, t.cf - 0.2); t.bs *= 0.7;
            }
            
            // Music load
            if (musicActive && isStressed) {
                t.mf = Math.min(1, t.mf + 0.15); t.aq *= 0.8;
            }
            
            return t;
        }
        
        train(samples) {
            let totalLoss = 0;
            const targetKeys = ['rd','cr','tf','sk','fn','ff','mf','pr','lod','cf','si','dd','bs','pc','aq'];
            
            for (const sample of samples) {
                const [fps, vel, chunks, dt, mem, tod, music, trend] = sample;
                
                // Build sequence from state buffer or synthetic
                const seq = [];
                for (let t = 0; t < this.seqLen; t++) {
                    const noise = (this.rng() - 0.5) * 5;
                    const fpsT = Math.max(10, fps + noise * (this.seqLen - t) / this.seqLen);
                    seq.push(this.encodeState(fpsT, vel, chunks, dt, mem, tod, music, trend));
                }
                
                const { h, out } = this.forward(seq);
                const target = this.getTargetSettings(fps, vel, mem, music, trend);
                
                // Compute loss and gradients
                let loss = 0;
                const gWout = new Float32Array(this.hiddenDim * this.outputDim);
                
                for (let o = 0; o < targetKeys.length && o < this.outputDim; o++) {
                    const pred = Math.tanh(out[o]) * 0.5 + 0.5;
                    const tgt = target[targetKeys[o]] || 0.5;
                    const err = pred - tgt;
                    loss += err * err;
                    
                    const tg = 1 - Math.tanh(out[o]) ** 2;
                    for (let i = 0; i < this.hiddenDim; i++) {
                        gWout[i * this.outputDim + o] += err * tg * 0.5 * h[i];
                    }
                }
                
                totalLoss += loss;
                
                // Update output weights
                const lr = this.lr / samples.length;
                for (let i = 0; i < this.Wout.w.length; i++) {
                    const grad = Math.max(-1, Math.min(1, gWout[i]));
                    this.Wout.w[i] -= lr * grad;
                    this.Wout.w[i] = Math.max(-3, Math.min(3, this.Wout.w[i]));
                }
            }
            
            this.epochs++;
            return totalLoss / samples.length;
        }
        
        updateMetrics(fps) {
            this.fpsBuffer.push(fps);
            if (this.fpsBuffer.length > 90) this.fpsBuffer.shift();
            
            if (this.fpsBuffer.length >= 15) {
                const recent = this.fpsBuffer.slice(-30);
                const older = this.fpsBuffer.slice(-60, -30);
                
                this.metrics.avgFPS = recent.reduce((a,b) => a+b, 0) / recent.length;
                this.metrics.minFPS = Math.min(...recent);
                this.metrics.maxFPS = Math.max(...recent);
                
                // Trend: positive = improving, negative = degrading
                if (older.length > 10) {
                    const oldAvg = older.reduce((a,b) => a+b, 0) / older.length;
                    this.metrics.trend = (this.metrics.avgFPS - oldAvg) / this.targetFPS;
                }
                
                // Variance and smoothness
                const mean = this.metrics.avgFPS;
                const variance = recent.reduce((s, f) => s + (f - mean) ** 2, 0) / recent.length;
                this.metrics.smoothness = 1 / (1 + variance / 50);
            }
            
            this.frameCount++;
        }
        
        optimize(fps, velocity, chunksVisible, deltaTime, timeOfDay = 0.5, musicActive = false) {
            this.updateMetrics(fps);
            
            // Estimate memory pressure
            const memPressure = Math.min(1, chunksVisible / 80 + (this.frameCount > 5000 ? 0.15 : 0));
            const trend = this.metrics.trend || 0;
            
            // Record state
            const state = this.encodeState(fps, velocity, chunksVisible, deltaTime, memPressure, timeOfDay, musicActive, trend);
            this.stateBuffer.push(state);
            if (this.stateBuffer.length > this.maxBufferSize) this.stateBuffer.shift();
            
            // Add to training history
            this.history.push([fps, velocity, chunksVisible, deltaTime, memPressure, timeOfDay, musicActive, trend]);
            if (this.history.length > this.maxHistory) this.history.shift();
            
            // Smooth FPS
            this.smoothedFPS = this.smoothedFPS * 0.88 + fps * 0.12;
            
            // Build sequence for forward pass
            const seq = [];
            if (this.stateBuffer.length >= this.seqLen) {
                for (let t = this.stateBuffer.length - this.seqLen; t < this.stateBuffer.length; t++) {
                    seq.push(this.stateBuffer[t]);
                }
            } else {
                // Pad with current state
                for (let t = 0; t < this.seqLen; t++) {
                    seq.push(this.stateBuffer[this.stateBuffer.length - 1] || state);
                }
            }
            
            const { out, pred } = this.forward(seq);
            
            // Store prediction for metrics
            this.metrics.prediction = this.targetFPS * (Math.tanh(pred[0]) * 0.5 + 0.5) + 30;
            
            // Decode outputs
            const outputs = [];
            for (let i = 0; i < this.outputDim; i++) {
                outputs.push(Math.tanh(out[i]) * 0.5 + 0.5);
            }
            
            // Map to settings with smoothing
            const s = 0.1; // Smooth factor
            const lerp = (curr, norm, bounds) => {
                const target = bounds[0] + norm * (bounds[1] - bounds[0]);
                return curr * (1 - s) + target * s;
            };
            
            this.settings.renderDistance = Math.round(lerp(this.settings.renderDistance, outputs[0], this.bounds.renderDistance));
            this.settings.chunkRate = Math.round(lerp(this.settings.chunkRate, outputs[1], this.bounds.chunkRate));
            this.settings.trainFrequency = Math.round(lerp(this.settings.trainFrequency, outputs[2], this.bounds.trainFrequency));
            this.settings.skipRender = Math.round(lerp(this.settings.skipRender, outputs[3], this.bounds.skipRender));
            this.settings.fogNear = lerp(this.settings.fogNear, outputs[4], this.bounds.fogNear);
            this.settings.fogFar = lerp(this.settings.fogFar, outputs[5], this.bounds.fogFar);
            this.settings.musicFrequency = Math.round(lerp(this.settings.musicFrequency, outputs[6], this.bounds.musicFrequency));
            this.settings.physicsRate = Math.round(lerp(this.settings.physicsRate, outputs[7], this.bounds.physicsRate));
            this.settings.meshLOD = lerp(this.settings.meshLOD, outputs[8], this.bounds.meshLOD);
            this.settings.cleanupFrequency = Math.round(lerp(this.settings.cleanupFrequency, outputs[9], this.bounds.cleanupFrequency));
            this.settings.shadowIntensity = lerp(this.settings.shadowIntensity, outputs[10], this.bounds.shadowIntensity);
            this.settings.decorDensity = lerp(this.settings.decorDensity, outputs[11], this.bounds.decorDensity);
            this.settings.batchSize = Math.round(lerp(this.settings.batchSize || 12, outputs[12], this.bounds.batchSize));
            this.settings.particleCount = lerp(this.settings.particleCount || 1, outputs[13], this.bounds.particleCount);
            this.settings.audioQuality = lerp(this.settings.audioQuality || 1, outputs[14], this.bounds.audioQuality);
            
            // Ensure fog near < far
            if (this.settings.fogNear >= this.settings.fogFar - 15) {
                this.settings.fogNear = this.settings.fogFar - 20;
            }
            
            // Clamp all
            for (const [key, [min, max]] of Object.entries(this.bounds)) {
                if (this.settings[key] !== undefined) {
                    this.settings[key] = Math.max(min, Math.min(max, this.settings[key]));
                }
            }
            
            this.settings.cameraFar = this.settings.renderDistance * 18 + 50;
            
            return this.settings;
        }
        
        generateTrainingSamples(n) {
            const samples = [];
            for (let i = 0; i < n; i++) {
                if (this.history.length > 15 && this.rng() < 0.8) {
                    samples.push(this.history[Math.floor(this.rng() * this.history.length)]);
                } else {
                    samples.push([
                        15 + this.rng() * 95,        // fps 15-110
                        this.rng() * 1.8,             // velocity 0-1.8
                        5 + this.rng() * 75,          // chunks 5-80
                        8 + this.rng() * 50,          // deltaTime 8-58ms
                        this.rng(),                   // memPressure 0-1
                        this.rng(),                   // timeOfDay 0-1
                        this.rng() < 0.5,             // musicActive
                        (this.rng() - 0.5) * 0.6      // trend -0.3 to 0.3
                    ]);
                }
            }
            return samples;
        }
        
        getStatusString() {
            const s = this.settings;
            return `RD:${s.renderDistance} LOD:${s.meshLOD.toFixed(2)} TF:${s.trainFrequency}`;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CHUNK_SIZE = 16, RENDER_DISTANCE = 4, SEA_LEVEL = 7;
    
    const B = {
        AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, SAND: 6, WATER: 7,
        BRICK: 8, GLASS: 9, SNOW: 10, GRAVEL: 11, DOOR_BOTTOM: 12, DOOR_TOP: 13,
        JUNGLE_WOOD: 14, JUNGLE_LEAVES: 15, MUD: 16, MOSS: 17, ICE: 18, MOUNTAIN_STONE: 19,
        SAVANNA_GRASS: 20, TAIGA_GRASS: 21, TERRACOTTA: 22, MYCELIUM: 23, BASALT: 24,
        CHERRY_LEAVES: 25, BAMBOO: 26, CORAL: 27, ACACIA_WOOD: 28, MUSHROOM_CAP: 29
    };

    let world = new Map(), doorStates = new Map(), chunks = new Map(), chunkMeshes = new Map();
    let selectedBlock = B.GRASS, worldNN, physicsNN, textureNN, musicNN, timeNN, perfNN, inventoryOpen = false;
    const inventory = {};
    const ALL_BLOCKS = [B.GRASS, B.DIRT, B.STONE, B.WOOD, B.LEAVES, B.SAND, B.SNOW, B.BRICK, B.GLASS, 
                       B.DOOR_BOTTOM, B.JUNGLE_WOOD, B.MUD, B.MOSS, B.ICE, B.MOUNTAIN_STONE,
                       B.SAVANNA_GRASS, B.TAIGA_GRASS, B.TERRACOTTA, B.MYCELIUM, B.BASALT,
                       B.CHERRY_LEAVES, B.BAMBOO, B.CORAL, B.ACACIA_WOOD, B.MUSHROOM_CAP];
    ALL_BLOCKS.forEach(b => inventory[b] = 64);

    const canvas = document.getElementById('game');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1);
    renderer.setClearColor(0x87CEEB);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x87CEEB, 35, 80);
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 20, 0);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.75);
    scene.add(ambientLight);
    const sunLight = new THREE.DirectionalLight(0xffffff, 0.65);
    sunLight.position.set(50, 100, 50);
    scene.add(sunLight);

    const player = { velocity: new THREE.Vector3(), onGround: false, height: 1.7 };
    const keys = {};
    let isLocked = false, pitch = 0, yaw = 0;

    const getBlockKey = (x, y, z) => `${x},${y},${z}`;
    const getBlock = (x, y, z) => world.get(getBlockKey(x, y, z)) || B.AIR;
    const setBlock = (x, y, z, type) => { if (type === B.AIR) world.delete(getBlockKey(x, y, z)); else world.set(getBlockKey(x, y, z), type); };
    const getChunkKey = (cx, cz) => `${cx},${cz}`;
    const seededRandom = (x, z, seed = 54321) => { const n = Math.sin(x * 12.9898 + z * 78.233 + seed) * 43758.5453; return n - Math.floor(n); };

    const materialCache = new Map();
    function getMaterial(blockType, faceType) {
        const isT = blockType === B.WATER || blockType === B.GLASS || blockType === B.ICE;
        const key = `${blockType}-${faceType}`;
        if (materialCache.has(key)) return materialCache.get(key);
        const { tex } = textureNN.generateTexture(blockType, faceType);
        const mat = new THREE.MeshLambertMaterial({
            map: tex, transparent: isT,
            opacity: blockType === B.WATER ? 0.6 : blockType === B.GLASS ? 0.4 : blockType === B.ICE ? 0.8 : 1,
            side: isT ? THREE.DoubleSide : THREE.FrontSide
        });
        materialCache.set(key, mat);
        return mat;
    }

    function generateTree(x, y, z, type) {
        if (type === 'none') return;
        
        const rand = seededRandom(x, z, 999);
        const rand2 = seededRandom(x + 1, z + 1, 888);
        const rand3 = seededRandom(x * 3, z * 2, 777);
        
        // Tree type definitions with variants
        const types = {
            oak: { wood: B.WOOD, leaf: B.LEAVES, h: [4, 6], variants: ['normal', 'tall', 'bushy', 'large'] },
            jungle: { wood: B.JUNGLE_WOOD, leaf: B.JUNGLE_LEAVES, h: [8, 12], variants: ['normal', 'mega', 'vine', 'emergent'] },
            spruce: { wood: B.WOOD, leaf: B.LEAVES, h: [6, 10], variants: ['normal', 'tall', 'small', 'dense'] },
            swamp: { wood: B.WOOD, leaf: B.MOSS, h: [3, 5], variants: ['normal', 'hanging', 'dead', 'bent'] },
            acacia: { wood: B.ACACIA_WOOD, leaf: B.LEAVES, h: [4, 6], variants: ['normal', 'flat', 'leaning', 'multi'] },
            cherry: { wood: B.WOOD, leaf: B.CHERRY_LEAVES, h: [4, 6], variants: ['normal', 'weeping', 'round', 'umbrella'] },
            bamboo: { wood: B.BAMBOO, leaf: B.BAMBOO, h: [6, 12], variants: ['single', 'cluster', 'tall', 'short'] },
            mushroom: { wood: B.WOOD, leaf: B.MUSHROOM_CAP, h: [4, 8], variants: ['normal', 'flat', 'tall', 'cluster'] },
            coral: { wood: B.CORAL, leaf: B.CORAL, h: [2, 5], variants: ['fan', 'brain', 'tube', 'branch'] },
            birch: { wood: B.WOOD, leaf: B.LEAVES, h: [5, 7], variants: ['normal', 'tall', 'cluster'] },
            pine: { wood: B.WOOD, leaf: B.LEAVES, h: [8, 12], variants: ['normal', 'tall', 'ancient'] }
        };
        
        const t = types[type]; if (!t) return;
        const variant = t.variants[Math.floor(rand2 * t.variants.length)];
        const th = t.h[0] + Math.floor(rand * t.h[1]);
        
        // Generate different shapes based on type and variant
        switch (type) {
            case 'oak':
                generateOakTree(x, y, z, t, th, variant, rand3);
                break;
            case 'jungle':
                generateJungleTree(x, y, z, t, th, variant, rand3);
                break;
            case 'spruce':
                generateSpruceTree(x, y, z, t, th, variant, rand3);
                break;
            case 'swamp':
                generateSwampTree(x, y, z, t, th, variant, rand3);
                break;
            case 'acacia':
                generateAcaciaTree(x, y, z, t, th, variant, rand3);
                break;
            case 'cherry':
                generateCherryTree(x, y, z, t, th, variant, rand3);
                break;
            case 'bamboo':
                generateBamboo(x, y, z, t, th, variant, rand3);
                break;
            case 'mushroom':
                generateMushroomTree(x, y, z, t, th, variant, rand3);
                break;
            case 'coral':
                generateCoral(x, y, z, t, th, variant, rand3);
                break;
            default:
                generateOakTree(x, y, z, t, th, 'normal', rand3);
        }
    }
    
    function generateOakTree(x, y, z, t, th, variant, rand) {
        // Trunk
        for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
        
        if (variant === 'tall') {
            // Tall oak with small canopy at top
            for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++) 
                for (let dy = th; dy <= th + 2; dy++)
                    if ((Math.abs(dx) + Math.abs(dz) <= 1 || dy === th + 1) && getBlock(x + dx, y + dy, z + dz) === B.AIR) 
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
        } else if (variant === 'bushy') {
            // Low bushy oak
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                for (let dy = th - 2; dy <= th + 1; dy++)
                    if (Math.abs(dx) + Math.abs(dz) <= 3 && rand > 0.2 && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
        } else if (variant === 'large') {
            // Large spreading oak
            for (let dx = -3; dx <= 3; dx++) for (let dz = -3; dz <= 3; dz++) 
                for (let dy = th - 1; dy <= th + 3; dy++) {
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist <= 3.5 && (dist <= 2 || dy <= th + 1) && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
                }
            // Branch stubs
            if (rand > 0.5) setBlock(x + 2, y + th - 2, z, t.wood);
            if (rand < 0.5) setBlock(x - 2, y + th - 2, z, t.wood);
        } else {
            // Normal oak
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                for (let dy = th - 1; dy <= th + 2; dy++)
                    if (Math.abs(dx) + Math.abs(dz) <= 3 && (dx !== 0 || dz !== 0 || dy > th))
                        if (getBlock(x + dx, y + dy, z + dz) === B.AIR) setBlock(x + dx, y + dy, z + dz, t.leaf);
        }
    }
    
    function generateJungleTree(x, y, z, t, th, variant, rand) {
        if (variant === 'mega') {
            // 2x2 trunk mega jungle tree
            const height = th + 8;
            for (let ty = 1; ty <= height; ty++) {
                setBlock(x, y + ty, z, t.wood);
                setBlock(x + 1, y + ty, z, t.wood);
                setBlock(x, y + ty, z + 1, t.wood);
                setBlock(x + 1, y + ty, z + 1, t.wood);
            }
            // Massive canopy
            for (let dx = -4; dx <= 5; dx++) for (let dz = -4; dz <= 5; dz++) 
                for (let dy = height - 2; dy <= height + 3; dy++) {
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist <= 5 && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
                }
        } else if (variant === 'emergent') {
            // Super tall emergent
            const height = th + 12;
            for (let ty = 1; ty <= height; ty++) setBlock(x, y + ty, z, t.wood);
            // Small canopy at very top
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                for (let dy = height - 1; dy <= height + 2; dy++)
                    if (Math.abs(dx) + Math.abs(dz) <= 2 && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
        } else if (variant === 'vine') {
            // Normal with vines (represented by moss)
            for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                for (let dy = th - 1; dy <= th + 2; dy++)
                    if (Math.abs(dx) + Math.abs(dz) <= 3 && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
            // Add hanging vines
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++)
                if (rand * (Math.abs(dx) + Math.abs(dz)) > 0.3)
                    for (let vy = 0; vy < 3 + Math.floor(rand * 3); vy++)
                        if (getBlock(x + dx, y + th - 2 - vy, z + dz) === B.AIR)
                            setBlock(x + dx, y + th - 2 - vy, z + dz, B.MOSS);
        } else {
            // Normal jungle
            for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                for (let dy = th - 1; dy <= th + 2; dy++)
                    if (Math.abs(dx) + Math.abs(dz) <= 3 && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
        }
    }
    
    function generateSpruceTree(x, y, z, t, th, variant, rand) {
        for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
        
        const layers = variant === 'dense' ? 6 : variant === 'tall' ? 5 : variant === 'small' ? 3 : 4;
        const spacing = variant === 'dense' ? 1 : 2;
        
        for (let layer = 0; layer < layers; layer++) {
            const ly = y + th - layer * spacing;
            const radius = variant === 'small' ? layer : Math.min(layer + 1, 3);
            for (let dx = -radius; dx <= radius; dx++) for (let dz = -radius; dz <= radius; dz++)
                if (Math.abs(dx) + Math.abs(dz) <= radius + 1 && (dx !== 0 || dz !== 0))
                    if (getBlock(x + dx, ly, z + dz) === B.AIR) setBlock(x + dx, ly, z + dz, t.leaf);
        }
        setBlock(x, y + th + 1, z, t.leaf);
        if (variant === 'tall') setBlock(x, y + th + 2, z, t.leaf);
    }
    
    function generateSwampTree(x, y, z, t, th, variant, rand) {
        if (variant === 'dead') {
            // Dead/bare tree
            for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
            // Just branches, no leaves
            if (rand > 0.3) setBlock(x + 1, y + th - 1, z, t.wood);
            if (rand < 0.7) setBlock(x - 1, y + th - 1, z, t.wood);
            return;
        }
        if (variant === 'bent') {
            // Bent trunk
            for (let ty = 1; ty <= th - 2; ty++) setBlock(x, y + ty, z, t.wood);
            setBlock(x + 1, y + th - 1, z, t.wood);
            setBlock(x + 1, y + th, z, t.wood);
            for (let dx = -1; dx <= 2; dx++) for (let dz = -1; dz <= 1; dz++)
                if (getBlock(x + dx, y + th + 1, z + dz) === B.AIR) setBlock(x + dx, y + th + 1, z + dz, t.leaf);
            return;
        }
        
        // Normal or hanging
        for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
        for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
            for (let dy = th - 1; dy <= th + 1; dy++)
                if (Math.abs(dx) + Math.abs(dz) <= 2 && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                    setBlock(x + dx, y + dy, z + dz, t.leaf);
        
        if (variant === 'hanging') {
            // Hanging moss
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++)
                if (Math.abs(dx) + Math.abs(dz) === 2)
                    for (let vy = 0; vy < 2 + Math.floor(rand * 2); vy++)
                        if (getBlock(x + dx, y + th - 2 - vy, z + dz) === B.AIR)
                            setBlock(x + dx, y + th - 2 - vy, z + dz, B.MOSS);
        }
    }
    
    function generateAcaciaTree(x, y, z, t, th, variant, rand) {
        // Trunk (often diagonal)
        const lean = variant === 'leaning' ? 1 : 0;
        for (let ty = 1; ty <= th; ty++) {
            const offset = ty > th / 2 ? lean : 0;
            setBlock(x + offset, y + ty, z, t.wood);
        }
        
        if (variant === 'flat') {
            // Very flat canopy
            const cx = x + lean;
            for (let dx = -3; dx <= 3; dx++) for (let dz = -3; dz <= 3; dz++)
                if (Math.abs(dx) + Math.abs(dz) <= 4 && getBlock(cx + dx, y + th + 1, z + dz) === B.AIR)
                    setBlock(cx + dx, y + th + 1, z + dz, t.leaf);
        } else if (variant === 'multi') {
            // Multiple small canopies
            const cx = x + lean;
            // Main
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++)
                if (Math.abs(dx) + Math.abs(dz) <= 2 && getBlock(cx + dx, y + th + 1, z + dz) === B.AIR)
                    setBlock(cx + dx, y + th + 1, z + dz, t.leaf);
            // Branch canopy
            setBlock(cx + 2, y + th - 1, z, t.wood);
            for (let dx = 1; dx <= 3; dx++) for (let dz = -1; dz <= 1; dz++)
                if (getBlock(cx + dx, y + th, z + dz) === B.AIR) setBlock(cx + dx, y + th, z + dz, t.leaf);
        } else {
            // Normal acacia
            const cx = x + lean;
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++)
                for (let dy = 0; dy <= 1; dy++)
                    if (Math.abs(dx) + Math.abs(dz) <= 3 - dy && getBlock(cx + dx, y + th + dy, z + dz) === B.AIR)
                        setBlock(cx + dx, y + th + dy, z + dz, t.leaf);
        }
    }
    
    function generateCherryTree(x, y, z, t, th, variant, rand) {
        for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
        
        if (variant === 'weeping') {
            // Weeping branches
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                if (Math.abs(dx) + Math.abs(dz) <= 2 && getBlock(x + dx, y + th + 1, z + dz) === B.AIR)
                    setBlock(x + dx, y + th + 1, z + dz, t.leaf);
            // Hanging petals
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++)
                if (Math.abs(dx) + Math.abs(dz) >= 1)
                    for (let vy = 0; vy < 2 + Math.floor(rand * 2); vy++)
                        if (getBlock(x + dx, y + th - vy, z + dz) === B.AIR)
                            setBlock(x + dx, y + th - vy, z + dz, t.leaf);
        } else if (variant === 'round') {
            // Spherical canopy
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                for (let dy = -1; dy <= 2; dy++) {
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist <= 2.5 && getBlock(x + dx, y + th + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + th + dy, z + dz, t.leaf);
                }
        } else if (variant === 'umbrella') {
            // Umbrella shape
            for (let dx = -3; dx <= 3; dx++) for (let dz = -3; dz <= 3; dz++) {
                const dist = Math.sqrt(dx*dx + dz*dz);
                if (dist <= 3 && getBlock(x + dx, y + th + 1, z + dz) === B.AIR)
                    setBlock(x + dx, y + th + 1, z + dz, t.leaf);
                if (dist <= 2 && getBlock(x + dx, y + th + 2, z + dz) === B.AIR)
                    setBlock(x + dx, y + th + 2, z + dz, t.leaf);
            }
        } else {
            // Normal
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) 
                for (let dy = th - 1; dy <= th + 2; dy++)
                    if (Math.abs(dx) + Math.abs(dz) <= 3 && getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
        }
    }
    
    function generateBamboo(x, y, z, t, th, variant, rand) {
        if (variant === 'cluster') {
            // Cluster of bamboo
            for (let i = 0; i < 4 + Math.floor(rand * 4); i++) {
                const ox = Math.floor(rand * 3) - 1;
                const oz = Math.floor(seededRandom(x + i, z + i) * 3) - 1;
                const h = th - 2 + Math.floor(seededRandom(x * i, z * i) * 4);
                for (let ty = 1; ty <= h; ty++) 
                    if (getBlock(x + ox, y + ty, z + oz) === B.AIR)
                        setBlock(x + ox, y + ty, z + oz, t.wood);
                setBlock(x + ox, y + h + 1, z + oz, t.leaf);
            }
        } else {
            // Single or few stalks
            const stalks = variant === 'single' ? 1 : 2;
            for (let s = 0; s < stalks; s++) {
                const ox = s === 0 ? 0 : (rand > 0.5 ? 1 : -1);
                const h = variant === 'tall' ? th + 4 : variant === 'short' ? th - 2 : th;
                for (let ty = 1; ty <= h; ty++) setBlock(x + ox, y + ty, z, t.wood);
                setBlock(x + ox, y + h + 1, z, t.leaf);
            }
        }
    }
    
    function generateMushroomTree(x, y, z, t, th, variant, rand) {
        for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.wood);
        
        if (variant === 'flat') {
            // Flat cap
            for (let dx = -3; dx <= 3; dx++) for (let dz = -3; dz <= 3; dz++)
                if (Math.abs(dx) + Math.abs(dz) <= 4 && getBlock(x + dx, y + th + 1, z + dz) === B.AIR)
                    setBlock(x + dx, y + th + 1, z + dz, t.leaf);
        } else if (variant === 'tall') {
            // Tall narrow cap
            for (let dy = 0; dy < 3; dy++) {
                const r = 2 - dy;
                for (let dx = -r; dx <= r; dx++) for (let dz = -r; dz <= r; dz++)
                    if (Math.abs(dx) + Math.abs(dz) <= r && getBlock(x + dx, y + th + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + th + dy, z + dz, t.leaf);
            }
        } else if (variant === 'cluster') {
            // Multiple small mushrooms
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++)
                if (Math.abs(dx) + Math.abs(dz) <= 2 && getBlock(x + dx, y + th + 1, z + dz) === B.AIR)
                    setBlock(x + dx, y + th + 1, z + dz, t.leaf);
            // Small mushroom nearby
            const smH = Math.floor(th / 2);
            setBlock(x + 2, y + smH, z, t.wood);
            for (let dx = 1; dx <= 3; dx++) for (let dz = -1; dz <= 1; dz++)
                if (getBlock(x + dx, y + smH + 1, z + dz) === B.AIR)
                    setBlock(x + dx, y + smH + 1, z + dz, t.leaf);
        } else {
            // Normal rounded cap
            for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) {
                if (Math.abs(dx) + Math.abs(dz) <= 3 && getBlock(x + dx, y + th + 1, z + dz) === B.AIR)
                    setBlock(x + dx, y + th + 1, z + dz, t.leaf);
                if (Math.abs(dx) + Math.abs(dz) <= 2 && getBlock(x + dx, y + th + 2, z + dz) === B.AIR)
                    setBlock(x + dx, y + th + 2, z + dz, t.leaf);
            }
        }
    }
    
    function generateCoral(x, y, z, t, th, variant, rand) {
        if (variant === 'fan') {
            // Fan coral
            for (let ty = 1; ty <= th; ty++)
                for (let dx = -ty; dx <= ty; dx++)
                    if (Math.abs(dx) <= ty && getBlock(x + dx, y + ty, z) === B.AIR)
                        setBlock(x + dx, y + ty, z, t.leaf);
        } else if (variant === 'brain') {
            // Rounded brain coral
            for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++) 
                for (let dy = 1; dy <= 2; dy++)
                    if (getBlock(x + dx, y + dy, z + dz) === B.AIR)
                        setBlock(x + dx, y + dy, z + dz, t.leaf);
        } else if (variant === 'tube') {
            // Tube coral
            for (let i = 0; i < 3; i++) {
                const ox = Math.floor(seededRandom(x + i, z) * 2) - 1;
                const oz = Math.floor(seededRandom(x, z + i) * 2) - 1;
                const h = 2 + Math.floor(rand * 3);
                for (let ty = 1; ty <= h; ty++)
                    if (getBlock(x + ox, y + ty, z + oz) === B.AIR)
                        setBlock(x + ox, y + ty, z + oz, t.leaf);
            }
        } else {
            // Branching
            for (let ty = 1; ty <= th; ty++) setBlock(x, y + ty, z, t.leaf);
            if (th > 2) {
                setBlock(x + 1, y + th - 1, z, t.leaf);
                setBlock(x - 1, y + th - 1, z, t.leaf);
                setBlock(x, y + th - 1, z + 1, t.leaf);
            }
        }
    }

    function generateChunk(cx, cz) {
        const key = getChunkKey(cx, cz);
        if (chunks.has(key)) return;
        chunks.set(key, true);
        
        const chunkData = worldNN.generateChunk(cx, cz);
        
        for (let i = 0; i < chunkData.results.length; i++) {
            const lx = Math.floor(i / 16), lz = i % 16;
            const x = chunkData.startX + lx, z = chunkData.startZ + lz;
            const { height, surface, treeChance, treeType, dominant } = chunkData.results[i];
            
            const isOcean = dominant === 4 || dominant === 15;
            const groundH = isOcean ? Math.min(height, SEA_LEVEL - 2) : height;
            
            for (let y = 0; y <= groundH; y++) {
                let block;
                if (y === groundH) block = surface || B.GRASS;
                else if (y > groundH - 3) block = isOcean ? B.SAND : B.DIRT;
                else block = dominant === 7 ? B.MOUNTAIN_STONE : dominant === 13 ? B.BASALT : B.STONE;
                setBlock(x, y, z, block);
            }
            
            if (isOcean) for (let y = groundH + 1; y <= SEA_LEVEL; y++) setBlock(x, y, z, dominant === 3 ? B.ICE : B.WATER);
            
            // Tree generation with diversity
            if (!isOcean && seededRandom(x, z) < treeChance && height > SEA_LEVEL + 1) {
                generateTree(x, height, z, treeType);
            }
            
            // Add occasional rocks/boulders
            if (!isOcean && seededRandom(x * 2, z * 2, 555) < 0.008 && height > SEA_LEVEL) {
                const rockSize = 1 + Math.floor(seededRandom(x, z, 666) * 2);
                for (let rx = 0; rx < rockSize; rx++) for (let rz = 0; rz < rockSize; rz++)
                    for (let ry = 0; ry < rockSize; ry++)
                        if (seededRandom(rx + x, rz + z, 777) > 0.3)
                            setBlock(x + rx, height + 1 + ry, z + rz, dominant === 7 ? B.MOUNTAIN_STONE : B.STONE);
            }
            
            // Fallen logs (rare)
            if (!isOcean && seededRandom(x * 3, z * 3, 444) < 0.003 && height > SEA_LEVEL && (dominant === 2 || dominant === 5 || dominant === 9)) {
                const logLen = 3 + Math.floor(seededRandom(x, z, 333) * 4);
                const dir = seededRandom(x, z, 222) > 0.5;
                for (let l = 0; l < logLen; l++) {
                    if (dir) setBlock(x + l, height + 1, z, B.WOOD);
                    else setBlock(x, height + 1, z + l, B.WOOD);
                }
            }
        }
    }

    function buildChunkMesh(cx, cz) {
        const key = getChunkKey(cx, cz);
        if (chunkMeshes.has(key)) chunkMeshes.get(key).forEach(m => scene.remove(m));
        
        const geoData = new Map();
        const startX = cx * CHUNK_SIZE, startZ = cz * CHUNK_SIZE;
        
        for (let lx = 0; lx < CHUNK_SIZE; lx++) {
            for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                const x = startX + lx, z = startZ + lz;
                for (let y = 0; y < 50; y++) {
                    const bt = getBlock(x, y, z);
                    if (bt === B.AIR || bt === B.DOOR_TOP) continue;
                    
                    const isDoor = bt === B.DOOR_BOTTOM;
                    const doorOpen = isDoor && doorStates.get(getBlockKey(x, y, z));
                    
                    const checkFace = (nx, ny, nz) => {
                        const nb = getBlock(x + nx, y + ny, z + nz);
                        return nb === B.AIR || (bt !== B.WATER && nb === B.WATER) || nb === B.DOOR_TOP || nb === B.GLASS;
                    };
                    
                    const faces = [];
                    if (checkFace(0, 1, 0)) faces.push({ dir: 'top', type: 0 });
                    if (checkFace(0, -1, 0)) faces.push({ dir: 'bottom', type: 1 });
                    if (checkFace(1, 0, 0)) faces.push({ dir: 'right', type: 2 });
                    if (checkFace(-1, 0, 0)) faces.push({ dir: 'left', type: 2 });
                    if (checkFace(0, 0, 1)) faces.push({ dir: 'front', type: 2 });
                    if (checkFace(0, 0, -1)) faces.push({ dir: 'back', type: 2 });
                    
                    faces.forEach(({ dir, type }) => {
                        const matKey = `${bt}-${type}`;
                        if (!geoData.has(matKey)) geoData.set(matKey, { pos: [], norm: [], uv: [], bt, faceType: type });
                        const g = geoData.get(matKey);
                        if (isDoor) addDoorFace(g, x, y, z, dir, doorOpen);
                        else addFace(g, x, y, z, dir);
                    });
                    
                    if (isDoor) {
                        const matKey = `${B.DOOR_TOP}-2`;
                        if (!geoData.has(matKey)) geoData.set(matKey, { pos: [], norm: [], uv: [], bt: B.DOOR_TOP, faceType: 2 });
                        ['front', 'back', 'left', 'right', 'top'].forEach(dir => addDoorFace(geoData.get(matKey), x, y + 1, z, dir, doorOpen));
                    }
                }
            }
        }
        
        const meshes = [];
        geoData.forEach((g) => {
            if (g.pos.length === 0) return;
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(g.pos, 3));
            geo.setAttribute('normal', new THREE.Float32BufferAttribute(g.norm, 3));
            geo.setAttribute('uv', new THREE.Float32BufferAttribute(g.uv, 2));
            const mat = getMaterial(g.bt, g.faceType);
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            meshes.push(mesh);
        });
        
        chunkMeshes.set(key, meshes);
    }

    function addFace(g, x, y, z, face) {
        const s = 0.5;
        const fd = {
            top:    { v: [[x-s,y+s,z+s], [x+s,y+s,z+s], [x+s,y+s,z-s], [x-s,y+s,z-s]], n: [0,1,0] },
            bottom: { v: [[x-s,y-s,z-s], [x+s,y-s,z-s], [x+s,y-s,z+s], [x-s,y-s,z+s]], n: [0,-1,0] },
            front:  { v: [[x-s,y-s,z+s], [x+s,y-s,z+s], [x+s,y+s,z+s], [x-s,y+s,z+s]], n: [0,0,1] },
            back:   { v: [[x+s,y-s,z-s], [x-s,y-s,z-s], [x-s,y+s,z-s], [x+s,y+s,z-s]], n: [0,0,-1] },
            right:  { v: [[x+s,y-s,z+s], [x+s,y-s,z-s], [x+s,y+s,z-s], [x+s,y+s,z+s]], n: [1,0,0] },
            left:   { v: [[x-s,y-s,z-s], [x-s,y-s,z+s], [x-s,y+s,z+s], [x-s,y+s,z-s]], n: [-1,0,0] }
        };
        const uvs = [[0,0], [1,0], [1,1], [0,1]];
        const f = fd[face];
        [0,1,2,0,2,3].forEach(i => { g.pos.push(...f.v[i]); g.norm.push(...f.n); g.uv.push(...uvs[i]); });
    }
    
    function addDoorFace(g, x, y, z, face, isOpen) {
        const s = 0.5, t = 0.1;
        const ox = isOpen ? 0.4 : 0, oz = isOpen ? -0.4 : 0;
        const fd = {
            top:    { v: [[x-s+ox,y+s,z+t+oz], [x+s+ox,y+s,z+t+oz], [x+s+ox,y+s,z-t+oz], [x-s+ox,y+s,z-t+oz]], n: [0,1,0] },
            bottom: { v: [[x-s+ox,y-s,z-t+oz], [x+s+ox,y-s,z-t+oz], [x+s+ox,y-s,z+t+oz], [x-s+ox,y-s,z+t+oz]], n: [0,-1,0] },
            front:  { v: [[x-s+ox,y-s,z+t+oz], [x+s+ox,y-s,z+t+oz], [x+s+ox,y+s,z+t+oz], [x-s+ox,y+s,z+t+oz]], n: [0,0,1] },
            back:   { v: [[x+s+ox,y-s,z-t+oz], [x-s+ox,y-s,z-t+oz], [x-s+ox,y+s,z-t+oz], [x+s+ox,y+s,z-t+oz]], n: [0,0,-1] },
            right:  { v: [[x+s+ox,y-s,z+t+oz], [x+s+ox,y-s,z-t+oz], [x+s+ox,y+s,z-t+oz], [x+s+ox,y+s,z+t+oz]], n: [1,0,0] },
            left:   { v: [[x-s+ox,y-s,z-t+oz], [x-s+ox,y-s,z+t+oz], [x-s+ox,y+s,z+t+oz], [x-s+ox,y+s,z-t+oz]], n: [-1,0,0] }
        };
        const uvs = [[0,0], [1,0], [1,1], [0,1]];
        const f = fd[face];
        [0,1,2,0,2,3].forEach(i => { g.pos.push(...f.v[i]); g.norm.push(...f.n); g.uv.push(...uvs[i]); });
    }

    function updateChunks() {
        const pcx = Math.floor(camera.position.x / CHUNK_SIZE);
        const pcz = Math.floor(camera.position.z / CHUNK_SIZE);
        
        let generated = 0;
        for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE && generated < 2; dx++) {
            for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE && generated < 2; dz++) {
                if (dx*dx + dz*dz > RENDER_DISTANCE * RENDER_DISTANCE) continue;
                const cx = pcx + dx, cz = pcz + dz;
                const key = getChunkKey(cx, cz);
                if (!chunks.has(key)) { 
                    generateChunk(cx, cz); 
                    buildChunkMesh(cx, cz); 
                    generated++; 
                } else if (!chunkMeshes.has(key)) { 
                    buildChunkMesh(cx, cz); 
                    generated++; 
                }
            }
        }
        
        // Clean up distant chunks less frequently
        if (frames % 60 === 0) {
            chunkMeshes.forEach((meshes, key) => {
                const [cx, cz] = key.split(',').map(Number);
                if ((cx - pcx) ** 2 + (cz - pcz) ** 2 > (RENDER_DISTANCE + 2) ** 2) {
                    meshes.forEach(m => scene.remove(m));
                    chunkMeshes.delete(key);
                }
            });
        }
    }

    function rebuildNearbyChunks(wx, wz) {
        const cx = Math.floor(wx / CHUNK_SIZE), cz = Math.floor(wz / CHUNK_SIZE);
        for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++)
            if (chunks.has(getChunkKey(cx + dx, cz + dz))) buildChunkMesh(cx + dx, cz + dz);
    }

    function getTargetBlock() {
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        
        let x = camera.position.x, y = camera.position.y, z = camera.position.z;
        let vx = Math.floor(x), vy = Math.floor(y), vz = Math.floor(z);
        
        const stepX = dir.x >= 0 ? 1 : -1, stepY = dir.y >= 0 ? 1 : -1, stepZ = dir.z >= 0 ? 1 : -1;
        const tDeltaX = dir.x !== 0 ? Math.abs(1 / dir.x) : 1e10;
        const tDeltaY = dir.y !== 0 ? Math.abs(1 / dir.y) : 1e10;
        const tDeltaZ = dir.z !== 0 ? Math.abs(1 / dir.z) : 1e10;
        
        let tMaxX = dir.x !== 0 ? ((stepX > 0 ? vx + 1 - x : x - vx) / Math.abs(dir.x)) : 1e10;
        let tMaxY = dir.y !== 0 ? ((stepY > 0 ? vy + 1 - y : y - vy) / Math.abs(dir.y)) : 1e10;
        let tMaxZ = dir.z !== 0 ? ((stepZ > 0 ? vz + 1 - z : z - vz) / Math.abs(dir.z)) : 1e10;
        
        let lastVx = vx, lastVy = vy, lastVz = vz;
        
        for (let i = 0; i < 50; i++) {
            const b = getBlock(vx, vy, vz);
            if (b !== B.AIR && b !== B.WATER && b !== B.DOOR_TOP) {
                const dist = Math.sqrt((vx - camera.position.x) ** 2 + (vy - camera.position.y) ** 2 + (vz - camera.position.z) ** 2);
                if (dist > 5) return { hit: null, place: null };
                return { hit: { x: vx, y: vy, z: vz }, place: { x: lastVx, y: lastVy, z: lastVz } };
            }
            lastVx = vx; lastVy = vy; lastVz = vz;
            if (tMaxX < tMaxY) {
                if (tMaxX < tMaxZ) { vx += stepX; tMaxX += tDeltaX; }
                else { vz += stepZ; tMaxZ += tDeltaZ; }
            } else {
                if (tMaxY < tMaxZ) { vy += stepY; tMaxY += tDeltaY; }
                else { vz += stepZ; tMaxZ += tDeltaZ; }
            }
            if (Math.sqrt((vx - camera.position.x) ** 2 + (vy - camera.position.y) ** 2 + (vz - camera.position.z) ** 2) > 5.5) break;
        }
        return { hit: null, place: null };
    }

    const highlight = new THREE.Mesh(new THREE.BoxGeometry(1.02, 1.02, 1.02), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 }));
    highlight.visible = false;
    scene.add(highlight);

    // FIXED: Only check collision at specific point, not entire body for block placement
    function checkCollision(x, y, z) {
        for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++) for (let dy = 0; dy <= 2; dy++) {
            const bx = Math.floor(x + dx * 0.3), by = Math.floor(y + dy), bz = Math.floor(z + dz * 0.3);
            const b = getBlock(bx, by, bz);
            if (b !== B.AIR && b !== B.WATER && b !== B.DOOR_TOP) {
                if (b === B.DOOR_BOTTOM && doorStates.get(getBlockKey(bx, by, bz))) continue;
                return true;
            }
        }
        return false;
    }
    
    // Check if placing a block would be inside player's CURRENT position
    function wouldBlockPlayer(bx, by, bz) {
        const px = camera.position.x, py = camera.position.y - player.height, pz = camera.position.z;
        const playerMinX = px - 0.3, playerMaxX = px + 0.3;
        const playerMinY = py, playerMaxY = py + player.height;
        const playerMinZ = pz - 0.3, playerMaxZ = pz + 0.3;
        
        const blockMinX = bx - 0.5, blockMaxX = bx + 0.5;
        const blockMinY = by - 0.5, blockMaxY = by + 0.5;
        const blockMinZ = bz - 0.5, blockMaxZ = bz + 0.5;
        
        return !(playerMaxX < blockMinX || playerMinX > blockMaxX ||
                 playerMaxY < blockMinY || playerMinY > blockMaxY ||
                 playerMaxZ < blockMinZ || playerMinZ > blockMaxZ);
    }

    let currentBiomeMix = new Float32Array(NUM_BIOMES);

    function updatePlayer() {
        if (inventoryOpen) return;
        camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
        const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
        const right = new THREE.Vector3(); right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
        const speed = keys['ShiftLeft'] ? 0.26 : 0.14;
        const move = new THREE.Vector3();
        if (keys['KeyW']) move.add(forward); if (keys['KeyS']) move.sub(forward);
        if (keys['KeyD']) move.add(right); if (keys['KeyA']) move.sub(right);
        if (move.length() > 0) move.normalize().multiplyScalar(speed);
        
        const newX = camera.position.x + move.x, newZ = camera.position.z + move.z;
        if (!checkCollision(newX, camera.position.y - player.height + 0.1, camera.position.z)) camera.position.x = newX;
        if (!checkCollision(camera.position.x, camera.position.y - player.height + 0.1, newZ)) camera.position.z = newZ;
        
        const inWater = getBlock(Math.floor(camera.position.x), Math.floor(camera.position.y), Math.floor(camera.position.z)) === B.WATER;
        const jumping = keys['Space'];
        
        // USE PHYSICS NN!
        const physResult = physicsNN.simulate(
            player.velocity.y,
            camera.position.y,
            player.onGround,
            inWater,
            jumping,
            keys['ShiftLeft']
        );
        
        player.velocity.y = physResult.newVelY;
        
        // Update physics display
        document.getElementById('phys-gravity').textContent = physResult.gravity.toFixed(4);
        document.getElementById('phys-jump').textContent = physResult.jumpForce.toFixed(3);
        document.getElementById('phys-friction').textContent = physResult.friction.toFixed(3);
        document.getElementById('phys-vely').textContent = player.velocity.y.toFixed(3);
        
        const newY = camera.position.y + player.velocity.y, feetY = newY - player.height;
        if (player.velocity.y < 0) {
            if (checkCollision(camera.position.x, feetY, camera.position.z)) {
                camera.position.y = Math.floor(feetY) + 1 + player.height;
                player.velocity.y = 0; player.onGround = true;
            } else { camera.position.y = newY; player.onGround = false; }
        } else {
            if (checkCollision(camera.position.x, newY + 0.1, camera.position.z)) player.velocity.y = 0;
            else camera.position.y = newY;
            player.onGround = false;
        }
        
        if (camera.position.y < -20) { camera.position.y = 30; player.velocity.y = 0; }
        
        const result = worldNN.generate(camera.position.x, camera.position.z);
        currentBiomeMix = result.weights;
        updateBiomeMixDisplay(result.weights, result.dominant);
        
        document.getElementById('biome').textContent = BIOME_DATA[result.dominant].name;
        document.getElementById('pos').textContent = `${camera.position.x.toFixed(0)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(0)}`;
    }

    function updateBiomeMixDisplay(weights, dominant) {
        const sorted = [...weights].map((w, i) => ({w, i, name: BIOME_DATA[i].name, color: BIOME_DATA[i].color}))
            .sort((a, b) => b.w - a.w).slice(0, 4);
        
        const container = document.getElementById('mix-bars');
        container.innerHTML = '';
        sorted.forEach(({w, name, color}) => {
            if (w < 0.02) return;
            const bar = document.createElement('div');
            bar.className = 'mix-bar';
            bar.innerHTML = `<span class="name">${name}</span><div class="bar"><div class="fill" style="width:${w*100}%;background:${color}"></div></div>`;
            container.appendChild(bar);
        });
    }

    function craftDoor() {
        if ((inventory[B.WOOD] || 0) >= 6) {
            inventory[B.WOOD] -= 6;
            inventory[B.DOOR_BOTTOM] = (inventory[B.DOOR_BOTTOM] || 0) + 1;
            updateHotbar();
            return true;
        }
        return false;
    }

    function setupMusicViz() {
        const viz = document.getElementById('music-viz');
        for (let i = 0; i < 10; i++) {
            const bar = document.createElement('div');
            bar.className = 'viz-bar';
            bar.style.height = '3px';
            viz.appendChild(bar);
            musicNN.vizBars.push(bar);
        }
    }

    function renderBlockIcon(blockType) { return textureNN.generateTexture(blockType, 0).canvas; }

    function setupInventory() {
        const invBlocks = document.getElementById('inv-blocks');
        ALL_BLOCKS.forEach(bt => {
            const slot = document.createElement('div'); slot.className = 'inv-slot';
            slot.appendChild(renderBlockIcon(bt).cloneNode(true));
            const count = document.createElement('span'); count.className = 'item-count'; count.textContent = inventory[bt];
            slot.appendChild(count);
            slot.dataset.block = bt;
            slot.onclick = () => { selectedBlock = bt; updateHotbar(); };
            invBlocks.appendChild(slot);
        });
    }

    function setupHotbar() {
        const hotbar = document.getElementById('hotbar');
        const hbBlocks = [B.GRASS, B.DIRT, B.STONE, B.WOOD, B.BRICK, B.GLASS, B.DOOR_BOTTOM, B.SAND, B.SNOW];
        hbBlocks.forEach((bt, i) => {
            const slot = document.createElement('div');
            slot.className = 'hotbar-slot' + (bt === selectedBlock ? ' selected' : '');
            slot.appendChild(renderBlockIcon(bt).cloneNode(true));
            slot.innerHTML += `<span class="key-hint">${i + 1}</span><span class="count">${inventory[bt]}</span>`;
            slot.onclick = () => { selectedBlock = bt; updateHotbar(); };
            hotbar.appendChild(slot);
        });
    }

    function updateHotbar() {
        const hbBlocks = [B.GRASS, B.DIRT, B.STONE, B.WOOD, B.BRICK, B.GLASS, B.DOOR_BOTTOM, B.SAND, B.SNOW];
        document.querySelectorAll('#hotbar .hotbar-slot').forEach((slot, i) => {
            slot.classList.toggle('selected', hbBlocks[i] === selectedBlock);
            slot.querySelector('.count').textContent = inventory[hbBlocks[i]];
        });
    }

    function toggleInventory() {
        inventoryOpen = !inventoryOpen;
        document.getElementById('inventory-overlay').classList.toggle('open', inventoryOpen);
        document.getElementById('crosshair').style.display = inventoryOpen ? 'none' : 'block';
        if (inventoryOpen) {
            document.exitPointerLock();
            pauseOverlay.classList.remove('visible'); // Don't show pause when inventory open
        } else {
            canvas.requestPointerLock();
        }
    }

    document.addEventListener('keydown', e => {
        keys[e.code] = true;
        if (e.code === 'KeyE') { toggleInventory(); return; }
        if (e.code === 'KeyC' && !inventoryOpen) { craftDoor(); return; }
        if (e.code === 'Escape' && inventoryOpen) { toggleInventory(); return; }
        if (e.code === 'KeyM') {
            initAudio();
            musicEnabled = !musicEnabled;
            if (musicEnabled && audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            document.getElementById('music-status').textContent = musicEnabled ? 'Playing' : 'Off [M]';
        }
        const n = parseInt(e.key);
        if (n >= 1 && n <= 9) {
            const hbBlocks = [B.GRASS, B.DIRT, B.STONE, B.WOOD, B.BRICK, B.GLASS, B.DOOR_BOTTOM, B.SAND, B.SNOW];
            selectedBlock = hbBlocks[n - 1]; updateHotbar();
        }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => {
        if (!isLocked || inventoryOpen) return;
        yaw -= e.movementX * 0.002; pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
    });

    canvas.addEventListener('mousedown', e => {
        if (!isLocked || inventoryOpen) return;
        const target = getTargetBlock();
        
        if (e.button === 0 && target.hit) {
            const bt = getBlock(target.hit.x, target.hit.y, target.hit.z);
            if (bt !== B.AIR) inventory[bt] = (inventory[bt] || 0) + 1;
            setBlock(target.hit.x, target.hit.y, target.hit.z, B.AIR);
            if (bt === B.DOOR_BOTTOM) {
                setBlock(target.hit.x, target.hit.y + 1, target.hit.z, B.AIR);
                doorStates.delete(getBlockKey(target.hit.x, target.hit.y, target.hit.z));
            }
            rebuildNearbyChunks(target.hit.x, target.hit.z);
            updateHotbar();
        } else if (e.button === 2 && target.hit) {
            const hitBlock = getBlock(target.hit.x, target.hit.y, target.hit.z);
            if (hitBlock === B.DOOR_BOTTOM) {
                const doorKey = getBlockKey(target.hit.x, target.hit.y, target.hit.z);
                doorStates.set(doorKey, !doorStates.get(doorKey));
                rebuildNearbyChunks(target.hit.x, target.hit.z);
                return;
            }
            if (target.place && (inventory[selectedBlock] || 0) > 0) {
                const { x, y, z } = target.place;
                // FIXED: Only prevent placement if block would be INSIDE player right now
                if (!wouldBlockPlayer(x, y, z)) {
                    setBlock(x, y, z, selectedBlock);
                    inventory[selectedBlock]--;
                    if (selectedBlock === B.DOOR_BOTTOM) {
                        setBlock(x, y + 1, z, B.DOOR_TOP);
                        doorStates.set(getBlockKey(x, y, z), false);
                    }
                    rebuildNearbyChunks(x, z);
                    updateHotbar();
                }
            }
        }
    });
    
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    canvas.addEventListener('wheel', e => {
        if (inventoryOpen) return;
        const hbBlocks = [B.GRASS, B.DIRT, B.STONE, B.WOOD, B.BRICK, B.GLASS, B.DOOR_BOTTOM, B.SAND, B.SNOW];
        let idx = hbBlocks.indexOf(selectedBlock);
        idx = (idx + Math.sign(e.deltaY) + hbBlocks.length) % hbBlocks.length;
        selectedBlock = hbBlocks[idx]; updateHotbar();
    });
    
    let gameStarted = false;
    const pauseOverlay = document.getElementById('pause-overlay');
    
    document.addEventListener('pointerlockchange', () => {
        isLocked = document.pointerLockElement === canvas;
        const crosshair = document.getElementById('crosshair');
        if (gameStarted && !isLocked && !inventoryOpen) {
            // Show pause overlay when pointer lock is lost
            pauseOverlay.classList.add('visible');
            crosshair.style.display = 'none';
        } else {
            pauseOverlay.classList.remove('visible');
            crosshair.style.display = 'block';
        }
    });
    
    document.addEventListener('pointerlockerror', () => {
        console.log('Pointer lock failed, will retry on click');
        if (gameStarted) pauseOverlay.classList.add('visible');
    });
    
    // Click on pause overlay to resume
    pauseOverlay.addEventListener('click', () => {
        initAudio();
        canvas.requestPointerLock();
    });
    
    // Click on canvas to request pointer lock (backup)
    canvas.addEventListener('click', () => {
        if (gameStarted && !isLocked && !inventoryOpen) {
            canvas.requestPointerLock();
        }
    });
    
    document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('start-screen').style.display = 'none';
        gameStarted = true;
        initAudio();
        canvas.requestPointerLock();
    });
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    async function initialTraining() {
        const loadingText = document.getElementById('loading-text');
        const progressFill = document.getElementById('progress-fill');
        
        // Train World NN - 640 epochs (doubled)
        for (let epoch = 0; epoch < 640; epoch++) {
            const samples = [];
            for (let i = 0; i < 48; i++) samples.push([(worldNN.rng() - 0.5) * 300, (worldNN.rng() - 0.5) * 300]);
            const loss = worldNN.train(samples);
            
            progressFill.style.width = (epoch / 640 * 20) + '%';
            loadingText.textContent = `Training World NAR: ${epoch + 1}/640`;
            document.querySelector('.loss-world').textContent = `World: ${loss.toFixed(3)}`;
            document.getElementById('world-epochs').textContent = worldNN.epochs;
            
            if (epoch % 40 === 0) await new Promise(r => setTimeout(r, 0));
        }
        
        // Train Physics NN - 480 epochs (doubled)
        for (let epoch = 0; epoch < 480; epoch++) {
            const samples = physicsNN.generateTrainingSamples(32);
            const loss = physicsNN.train(samples);
            
            progressFill.style.width = (20 + epoch / 480 * 15) + '%';
            loadingText.textContent = `Training Physics NAR: ${epoch + 1}/480`;
            document.querySelector('.loss-phys').textContent = `Physics: ${loss.toFixed(3)}`;
            document.getElementById('phys-epochs').textContent = physicsNN.epochs;
            
            if (epoch % 30 === 0) await new Promise(r => setTimeout(r, 0));
        }
        
        // Train Time NN - 400 epochs (doubled)
        for (let epoch = 0; epoch < 400; epoch++) {
            const samples = timeNN.generateTrainingSamples(32);
            const loss = timeNN.train(samples);
            
            progressFill.style.width = (35 + epoch / 400 * 15) + '%';
            loadingText.textContent = `Training Time NAR: ${epoch + 1}/400`;
            document.querySelector('.loss-time').textContent = `Time: ${loss.toFixed(3)}`;
            document.getElementById('time-epochs').textContent = timeNN.epochs;
            
            if (epoch % 25 === 0) await new Promise(r => setTimeout(r, 0));
        }
        
        // Train Texture NN - 400 epochs (doubled)
        for (let epoch = 0; epoch < 400; epoch++) {
            const samples = [];
            for (let i = 0; i < 32; i++) {
                samples.push([
                    Math.floor(textureNN.rng() * 29) + 1,
                    Math.floor(textureNN.rng() * 8),
                    Math.floor(textureNN.rng() * 8),
                    Math.floor(textureNN.rng() * 3)
                ]);
            }
            const loss = textureNN.train(samples);
            
            progressFill.style.width = (50 + epoch / 400 * 15) + '%';
            loadingText.textContent = `Training Texture NAR: ${epoch + 1}/400`;
            document.querySelector('.loss-tex').textContent = `Texture: ${loss.toFixed(3)}`;
            
            if (epoch % 25 === 0) await new Promise(r => setTimeout(r, 0));
        }
        
        // Train Advanced Performance Tensor Transformer - 300 epochs (doubled)
        for (let epoch = 0; epoch < 300; epoch++) {
            const samples = perfNN.generateTrainingSamples(40);
            const loss = perfNN.train(samples);
            
            progressFill.style.width = (65 + epoch / 300 * 15) + '%';
            loadingText.textContent = `Training Perf Tensor Transformer (4-head, 2-layer): ${epoch + 1}/300`;
            document.querySelector('.loss-perf').textContent = `Perf: ${loss.toFixed(3)}`;
            document.getElementById('perf-epochs').textContent = perfNN.epochs;
            
            if (epoch % 20 === 0) await new Promise(r => setTimeout(r, 0));
        }
        
        loadingText.textContent = 'Generating world...';
        for (let cx = -2; cx <= 2; cx++) {
            for (let cz = -2; cz <= 2; cz++) { generateChunk(cx, cz); buildChunkMesh(cx, cz); }
            progressFill.style.width = (80 + (cx + 2) / 5 * 20) + '%';
            await new Promise(r => setTimeout(r, 0));
        }
        
        // Find safe spawn point
        loadingText.textContent = 'Finding safe spawn...';
        let spawnY = 30;
        for (let checkY = 40; checkY > 0; checkY--) {
            const blockBelow = getBlock(0, checkY - 1, 0);
            const blockAt = getBlock(0, checkY, 0);
            const blockAbove = getBlock(0, checkY + 1, 0);
            if (blockBelow !== B.AIR && blockBelow !== B.WATER && 
                blockAt === B.AIR && blockAbove === B.AIR) {
                spawnY = checkY + player.height + 0.1;
                break;
            }
        }
        camera.position.set(0.5, spawnY, 0.5);
    }

    let frames = 0, lastTime = performance.now(), learnCounter = 0, physLearnCounter = 0, musicCounter = 0, timeCounter = 0, perfCounter = 0;
    let currentFPS = 60, frameTime = 16;
    
    // All adaptive settings controlled by Performance NN
    let perfSettings = {
        renderDistance: 4,
        chunkRate: 2,
        trainFrequency: 180,
        skipRender: 0,
        fogNear: 35,
        fogFar: 80,
        musicFrequency: 12,
        physicsRate: 1,
        meshLOD: 1.0,
        cleanupFrequency: 60,
        shadowIntensity: 1.0,
        decorDensity: 1.0,
        cameraFar: 100
    };
    let physicsSkipCounter = 0;

    function animate() {
        requestAnimationFrame(animate);
        
        const now = performance.now();
        const dt = now - lastTime;
        
        // Track FPS every second
        frames++;
        if (dt >= 1000) {
            currentFPS = frames;
            frameTime = dt / frames;
            document.getElementById('fps').textContent = frames;
            
            // Update performance display with all stats
            if (perfNN) {
                const s = perfSettings;
                document.getElementById('perf-rd').textContent = s.renderDistance;
                document.getElementById('perf-tf').textContent = s.trainFrequency;
                document.getElementById('perf-fps').textContent = currentFPS;
                
                // Update extended perf display with trend and prediction
                const perfExt = document.getElementById('perf-extended');
                if (perfExt && perfNN.metrics) {
                    const trend = perfNN.metrics.trend || 0;
                    const trendIcon = trend > 0.1 ? 'ğŸ“ˆ' : trend < -0.1 ? 'ğŸ“‰' : 'â¡ï¸';
                    const pred = perfNN.metrics.prediction ? perfNN.metrics.prediction.toFixed(0) : '--';
                    const smooth = (perfNN.metrics.smoothness * 100).toFixed(0);
                    perfExt.innerHTML = `LOD:${s.meshLOD.toFixed(2)} Fog:${s.fogNear.toFixed(0)}-${s.fogFar.toFixed(0)} ${trendIcon}${trend >= 0 ? '+' : ''}${(trend*100).toFixed(0)}% Pred:${pred} Smooth:${smooth}%`;
                }
            }
            
            frames = 0;
            lastTime = now;
        }
        
        // Performance NN optimization every 15 frames
        if (perfNN && frames % 15 === 0) {
            const velocity = player.velocity.length();
            const chunksVisible = chunkMeshes.size;
            const timeOfDay = timeNN ? timeNN.gameTime / 1440 : 0.5;
            
            perfSettings = perfNN.optimize(
                currentFPS, 
                velocity, 
                chunksVisible, 
                frameTime,
                timeOfDay,
                musicEnabled
            );
            
            // Apply camera far plane from perf NN
            camera.far = perfSettings.cameraFar;
            camera.updateProjectionMatrix();
            
            // Apply shadow intensity
            if (sunLight) {
                sunLight.intensity = Math.max(0.1, sunLight.intensity) * perfSettings.shadowIntensity;
            }
        }
        
        // Skip rendering on low FPS (as determined by NN)
        if (perfSettings.skipRender > 0 && frames % (perfSettings.skipRender + 1) !== 0) {
            return; // Skip this frame's rendering
        }
        
        // Always update time and lighting
        if (timeNN) {
            timeNN.advance();
            const lighting = timeNN.simulate();
            
            const skyColor = new THREE.Color(lighting.skyR, lighting.skyG, lighting.skyB);
            scene.background = skyColor;
            scene.fog.color.copy(skyColor);
            
            // Fog controlled by both Time NN and Performance NN
            scene.fog.near = perfSettings.fogNear * lighting.fogDensity;
            scene.fog.far = perfSettings.fogFar / lighting.fogDensity;
            renderer.setClearColor(skyColor);
            
            if (ambientLight) ambientLight.intensity = lighting.ambientLight;
            if (sunLight) {
                sunLight.intensity = Math.max(0.1, lighting.sunHeight) * perfSettings.shadowIntensity;
                const sunX = Math.cos(lighting.sunAngle * Math.PI * 2) * 50;
                const sunY = Math.max(5, lighting.sunHeight * 50);
                const sunZ = Math.sin(lighting.sunAngle * Math.PI * 2) * 50;
                sunLight.position.set(sunX, sunY, sunZ);
            }
            
            if (frames % 30 === 0) {
                document.getElementById('game-time').textContent = timeNN.getTimeString();
                document.getElementById('time-period').textContent = timeNN.getPeriod();
            }
        }
        
        if (isLocked && !inventoryOpen) {
            // Physics update rate controlled by Performance NN
            physicsSkipCounter++;
            if (physicsSkipCounter >= perfSettings.physicsRate) {
                physicsSkipCounter = 0;
                updatePlayer();
            } else if (perfSettings.physicsRate === 1) {
                updatePlayer();
            }
            
            updateChunksAdaptive(); // Use adaptive chunk loading
            
            // Adaptive training frequency (controlled by perf NN)
            learnCounter++;
            if (learnCounter >= perfSettings.trainFrequency) {
                learnCounter = 0;
                const batchSize = Math.max(8, Math.floor(12 * perfSettings.meshLOD));
                const samples = [];
                for (let i = 0; i < batchSize; i++) samples.push([camera.position.x + (worldNN.rng() - 0.5) * 150, camera.position.z + (worldNN.rng() - 0.5) * 150]);
                worldNN.train(samples);
                document.getElementById('world-epochs').textContent = worldNN.epochs;
            }
            
            physLearnCounter++;
            if (physLearnCounter >= perfSettings.trainFrequency + 30) {
                physLearnCounter = 0;
                const samples = physicsNN.generateTrainingSamples(Math.floor(12 * perfSettings.meshLOD));
                physicsNN.train(samples);
                document.getElementById('phys-epochs').textContent = physicsNN.epochs;
            }
            
            timeCounter++;
            if (timeCounter >= perfSettings.trainFrequency + 50) {
                timeCounter = 0;
                const samples = timeNN.generateTrainingSamples(Math.floor(12 * perfSettings.meshLOD));
                timeNN.train(samples);
                document.getElementById('time-epochs').textContent = timeNN.epochs;
            }
            
            // Performance NN background learning
            perfCounter++;
            if (perfCounter >= 250) {
                perfCounter = 0;
                const samples = perfNN.generateTrainingSamples(16);
                perfNN.train(samples);
                document.getElementById('perf-epochs').textContent = perfNN.epochs;
            }
            
            musicCounter++;
            if (musicCounter >= perfSettings.musicFrequency && musicEnabled && audioCtx) {
                musicCounter = 0;
                if (audioCtx.state === 'suspended') audioCtx.resume();
                document.getElementById('music-epochs').textContent = musicNN.epochs;
                const { freq, duration, velocity, noteIdx } = musicNN.generate(currentBiomeMix);
                musicNN.playNote(freq, duration, velocity);
                musicNN.advance();
                musicNN.vizBars.forEach((bar, i) => {
                    bar.style.height = (i === noteIdx ? velocity * 24 : Math.max(3, parseFloat(bar.style.height) * 0.7)) + 'px';
                });
            }
            
            const target = getTargetBlock();
            if (target.hit) { highlight.position.set(target.hit.x, target.hit.y, target.hit.z); highlight.visible = true; }
            else highlight.visible = false;
        }
        
        renderer.render(scene, camera);
    }
    
    // Adaptive chunk loading using Performance NN settings
    function updateChunksAdaptive() {
        const pcx = Math.floor(camera.position.x / CHUNK_SIZE);
        const pcz = Math.floor(camera.position.z / CHUNK_SIZE);
        const rd = perfSettings.renderDistance;
        const maxGen = perfSettings.chunkRate;
        const cleanupFreq = perfSettings.cleanupFrequency;
        
        let generated = 0;
        for (let dx = -rd; dx <= rd && generated < maxGen; dx++) {
            for (let dz = -rd; dz <= rd && generated < maxGen; dz++) {
                if (dx*dx + dz*dz > rd * rd) continue;
                const cx = pcx + dx, cz = pcz + dz;
                const key = getChunkKey(cx, cz);
                if (!chunks.has(key)) { 
                    generateChunk(cx, cz); 
                    buildChunkMesh(cx, cz); 
                    generated++; 
                } else if (!chunkMeshes.has(key)) { 
                    buildChunkMesh(cx, cz); 
                    generated++; 
                }
            }
        }
        
        // Clean up distant chunks - frequency controlled by Performance NN
        if (frames % cleanupFreq === 0) {
            chunkMeshes.forEach((meshes, key) => {
                const [cx, cz] = key.split(',').map(Number);
                if ((cx - pcx) ** 2 + (cz - pcz) ** 2 > (rd + 2) ** 2) {
                    meshes.forEach(m => scene.remove(m));
                    chunkMeshes.delete(key);
                }
            });
            
            // Also cleanup old chunk data when memory pressure is high
            if (perfNN && perfNN.metrics && perfNN.metrics.smoothness < 0.7) {
                const maxChunks = rd * rd * 4;
                if (chunks.size > maxChunks * 2) {
                    let removed = 0;
                    chunks.forEach((_, key) => {
                        if (removed > chunks.size - maxChunks) return;
                        const [cx, cz] = key.split(',').map(Number);
                        if ((cx - pcx) ** 2 + (cz - pcz) ** 2 > (rd + 4) ** 2) {
                            chunks.delete(key);
                            removed++;
                        }
                    });
                }
            }
        }
    }

    async function init() {
        document.getElementById('loading-text').textContent = 'Initializing 6 NAR transformers...';
        const seed = Date.now() % 100000;
        worldNN = new WorldNAR(seed);
        physicsNN = new PhysicsNAR(seed + 1);
        textureNN = new TextureNAR(seed + 2);
        musicNN = new MusicNAR(seed + 3);
        timeNN = new TimeNAR(seed + 4);
        perfNN = new PerformanceNAR(seed + 5);
        
        await initialTraining();
        setupHotbar();
        setupInventory();
        setupMusicViz();
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
        animate();
    }

    init();
    </script>
</body>
</html>
