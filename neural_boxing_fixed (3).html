<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL BOXING ULTIMATE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(180deg, #1a0505 0%, #0a0a12 50%, #050510 100%);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            padding: 8px;
            overflow-x: hidden;
        }
        .header { text-align: center; margin-bottom: 6px; }
        h1 {
            font-size: 1.6rem;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
        }
        .subtitle { color: #666; font-size: 0.65rem; }
        
        .ring-container {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        
        .corner-panel {
            background: linear-gradient(145deg, #1a1215, #0a0808);
            border: 2px solid #2a1a1a;
            border-radius: 8px;
            padding: 8px;
            width: 185px;
            font-size: 0.65rem;
        }
        .corner-panel.red { border-color: #ff4444; }
        .corner-panel.blue { border-color: #4444ff; }
        
        .fighter-header { display: flex; align-items: center; gap: 5px; margin-bottom: 6px; }
        .fighter-icon {
            width: 26px; height: 26px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 0.9rem;
        }
        .corner-panel.red .fighter-icon { background: #ff4444; }
        .corner-panel.blue .fighter-icon { background: #4444ff; }
        .fighter-name { font-size: 0.8rem; font-weight: bold; }
        .corner-panel.red .fighter-name { color: #ff6666; }
        .corner-panel.blue .fighter-name { color: #6666ff; }
        .fighter-style { font-size: 0.5rem; color: #888; }
        
        .fighter-select {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2px;
            margin-bottom: 6px;
        }
        .fighter-option {
            padding: 3px;
            background: #1a1a1a;
            border: 1px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.55rem;
            text-align: center;
        }
        .fighter-option:hover { border-color: #444; }
        .fighter-option.selected { border-color: #00ffaa; background: #1a2a2a; }
        .fighter-option .icon { font-size: 0.8rem; }
        .fighter-option .name { font-weight: bold; color: #fff; font-size: 0.5rem; }
        
        .status-row { display: flex; gap: 3px; flex-wrap: wrap; margin-bottom: 4px; min-height: 16px; }
        .status-badge {
            padding: 1px 4px; border-radius: 3px; font-size: 0.45rem; font-weight: bold;
        }
        .status-badge.rage { background: #ff0000; color: #fff; animation: pulse 0.4s infinite; }
        .status-badge.super { background: #ff00ff; color: #fff; }
        .status-badge.stunned { background: #ffff00; color: #000; }
        .status-badge.bleeding { background: #880000; color: #fff; }
        .status-badge.tired { background: #444; color: #fff; }
        .status-badge.combo { background: #00aaff; color: #fff; }
        @keyframes pulse { 0%,100%{opacity:1;}50%{opacity:0.5;} }
        
        .stat-bars { margin-bottom: 5px; }
        .stat-bar { margin-bottom: 3px; }
        .stat-bar .label { display: flex; justify-content: space-between; font-size: 0.5rem; color: #666; }
        .bar-bg { height: 8px; background: #1a1a1a; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.15s; border-radius: 4px; }
        .bar-fill.hp { background: linear-gradient(90deg, #44ff44, #22aa22); }
        .bar-fill.stamina { background: linear-gradient(90deg, #ffaa00, #aa7700); }
        .bar-fill.super { background: linear-gradient(90deg, #ff00ff, #aa00aa); }
        .bar-fill.rage { background: linear-gradient(90deg, #ff0000, #ff4400); }
        .bar-fill.hp.low { background: linear-gradient(90deg, #ff4444, #aa2222); }
        
        .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; font-size: 0.55rem; margin-bottom: 5px; }
        .stat-item { background: #0a0a0a; padding: 2px; border-radius: 2px; text-align: center; }
        .stat-item .val { font-size: 0.7rem; font-weight: bold; color: #ffaa00; }
        
        .brain-panel { background: #0a0808; border-radius: 4px; padding: 4px; margin-bottom: 4px; }
        .brain-panel h4 { font-size: 0.45rem; color: #555; margin-bottom: 2px; text-transform: uppercase; }
        .brain-viz { min-height: 30px; }
        .memory-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 1px; }
        .mem-cell { width: 10px; height: 10px; border-radius: 1px; background: #1a1a1a; }
        .hidden-neurons { display: flex; flex-wrap: wrap; gap: 1px; }
        .neuron { width: 7px; height: 7px; border-radius: 50%; background: #1a1a1a; }
        
        .corner-advice { background: #0a0a0a; padding: 3px; border-radius: 2px; font-size: 0.5rem; color: #888; }
        .corner-advice .label { color: #ffaa00; }
        
        .ring {
            position: relative;
            width: 480px;
            height: 340px;
            background: linear-gradient(180deg, #2a2a35 0%, #1a1a22 100%);
            border: 6px solid #8B4513;
            border-radius: 4px;
            overflow: hidden;
        }
        .ring-floor {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 140px;
            background: linear-gradient(180deg, #3a3a45 0%, #2a2a35 100%);
        }
        .ropes { position: absolute; inset: 0; pointer-events: none; }
        .rope { position: absolute; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, #aa2222, #ff4444, #aa2222); }
        .rope:nth-child(1) { top: 12%; }
        .rope:nth-child(2) { top: 28%; }
        .rope:nth-child(3) { bottom: 40%; }
        .rope:nth-child(4) { bottom: 25%; }
        .corner-post { position: absolute; width: 10px; height: 100%; background: linear-gradient(90deg, #555, #888, #555); }
        .corner-post.left { left: 0; }
        .corner-post.right { right: 0; }
        
        .crowd {
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            opacity: 0.6;
            transition: all 0.3s;
            pointer-events: none;
        }
        .crowd.hyped { font-size: 1.3rem; opacity: 0.9; animation: crowd-wave 0.3s; }
        @keyframes crowd-wave { 0%,100%{transform:translateY(0);}50%{transform:translateY(-4px);} }
        
        .scoreboard {
            position: absolute;
            top: 40px; left: 50%; transform: translateX(-50%);
            background: #000000dd;
            padding: 4px 12px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            font-weight: bold;
            z-index: 10;
        }
        .scoreboard .red { color: #ff4444; }
        .scoreboard .blue { color: #4444ff; }
        .scoreboard .round { color: #ffaa00; font-size: 0.6rem; }
        .scoreboard .timer { color: #aaa; font-size: 0.55rem; }
        
        .boxer {
            position: absolute;
            width: 70px;
            height: 110px;
            transition: left 0.05s, bottom 0.05s, transform 0.05s, filter 0.2s;
        }
        .boxer-body {
            position: absolute;
            bottom: 16px; left: 10px;
            width: 45px; height: 65px;
            border-radius: 22px 22px 14px 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.06s, box-shadow 0.2s;
        }
        .boxer.red .boxer-body { background: linear-gradient(180deg, #ff6666, #cc3333); }
        .boxer.blue .boxer-body { background: linear-gradient(180deg, #6666ff, #3333cc); }
        
        .boxer-head {
            width: 30px; height: 30px;
            border-radius: 50%;
            background: #ffcc99;
            margin-top: -10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            border: 2px solid;
            position: relative;
            z-index: 2;
            transition: transform 0.06s;
        }
        .boxer.red .boxer-head { border-color: #ff4444; }
        .boxer.blue .boxer-head { border-color: #4444ff; }
        
        .injury { position: absolute; font-size: 0.5rem; top: -3px; right: -3px; }
        
        .glove {
            position: absolute;
            width: 18px; height: 18px;
            border-radius: 50%;
            top: 38px;
            transition: all 0.05s;
            z-index: 3;
        }
        .boxer.red .glove { background: radial-gradient(circle at 30% 30%, #ff6666, #cc2222); }
        .boxer.blue .glove { background: radial-gradient(circle at 30% 30%, #6666ff, #2222cc); }
        .glove.left { left: -2px; }
        .glove.right { right: -2px; }
        
        .leg {
            position: absolute;
            width: 12px; height: 28px;
            bottom: 0; left: 8px;
            border-radius: 6px;
            transition: transform 0.06s;
        }
        .leg.right { left: 25px; }
        .boxer.red .leg { background: #b03030; }
        .boxer.blue .leg { background: #3030b0; }
        
        /* States */
        .boxer.rage { filter: brightness(1.2) saturate(1.4); }
        .boxer.rage .boxer-body { box-shadow: 0 0 15px #ff0000; animation: rage-glow 0.3s infinite; }
        @keyframes rage-glow { 0%,100%{box-shadow:0 0 12px #ff0000;}50%{box-shadow:0 0 20px #ff4400;} }
        
        .boxer.super-ready .boxer-body { box-shadow: 0 0 12px #ff00ff; }
        
        .boxer.blocking .glove { top: 18px !important; }
        .boxer.blocking .glove.left { left: 4px !important; }
        .boxer.blocking .glove.right { right: 4px !important; }
        
        .boxer.parrying .glove.left { left: -10px !important; top: 16px !important; }
        .boxer.parrying .glove.right { right: -10px !important; top: 16px !important; }
        .boxer.parrying { filter: drop-shadow(0 0 5px #ffaa00); }
        
        .boxer.jabbing .glove.right { right: -35px !important; top: 30px !important; }
        .boxer.crossing .glove.right { right: -38px !important; top: 28px !important; }
        .boxer.hooking .glove.right { right: -30px !important; top: 24px !important; transform: rotate(-25deg); }
        .boxer.uppercutting .glove.right { right: -20px !important; top: 8px !important; }
        .boxer.body-shotting .glove.right { right: -30px !important; top: 45px !important; }
        .boxer.elbowing .glove.right { right: -18px !important; top: 20px !important; transform: rotate(40deg); }
        
        .boxer.kicking .leg.right { transform: rotate(-25deg) translate(6px, -8px); }
        .boxer.high-kicking .leg.right { transform: rotate(-50deg) translate(12px, -14px); }
        .boxer.spin-kicking .leg.right { transform: rotate(-45deg) translate(10px, -12px); }
        .boxer.sweeping .leg.right { transform: rotate(-30deg) translate(8px, -4px); }
        .boxer.kneeing .leg.right { transform: rotate(-60deg) translate(4px, -12px); }
        .boxer.flying-knee { transform: translateY(-12px); }
        .boxer.flying-knee .leg.right { transform: rotate(-70deg) translate(4px, -16px); }
        
        .boxer.clinching .glove.left { left: 12px !important; top: 12px !important; }
        .boxer.clinching .glove.right { right: 12px !important; top: 12px !important; }
        
        .boxer.taunting .glove.left { left: 0 !important; top: 4px !important; transform: rotate(-15deg); }
        .boxer.taunting .boxer-head { animation: taunt-bob 0.3s infinite; }
        @keyframes taunt-bob { 0%,100%{transform:rotate(0);}50%{transform:rotate(8deg) scale(1.05);} }
        
        .boxer.super-attacking { animation: super-flash 0.3s; }
        .boxer.super-attacking .boxer-body { box-shadow: 0 0 25px #ff00ff; }
        .boxer.super-attacking .glove.right { right: -45px !important; top: 22px !important; transform: scale(1.3); }
        @keyframes super-flash { 0%{filter:brightness(1);}50%{filter:brightness(2) hue-rotate(60deg);}100%{filter:brightness(1);} }
        
        .boxer.combo-1 .glove.left { left: -30px !important; top: 30px !important; }
        .boxer.combo-2 .glove.right { right: -35px !important; top: 26px !important; }
        .boxer.combo-3 .glove.right { right: -25px !important; top: 12px !important; }
        
        .boxer.hit { animation: hit-shake 0.12s; }
        @keyframes hit-shake { 0%,100%{transform:translateX(0);}25%{transform:translateX(-6px) rotate(-3deg);}75%{transform:translateX(6px) rotate(3deg);} }
        
        .boxer.knocked-down .boxer-body { transform: rotate(80deg) translateY(25px); }
        .boxer.knocked-down .boxer-head { transform: rotate(-80deg); }
        
        .boxer.stunned .boxer-head { animation: stun-spin 0.35s linear infinite; }
        @keyframes stun-spin { 0%{transform:rotate(0);}100%{transform:rotate(360deg);} }
        
        .boxer.dodging { transform: translateY(-8px); opacity: 0.85; }
        .boxer.weaving .boxer-body { animation: weave 0.25s ease-in-out; }
        @keyframes weave { 0%,100%{transform:translateX(0);}50%{transform:translateX(8px) rotate(4deg);} }
        
        /* Effects */
        .effect { position: absolute; pointer-events: none; z-index: 100; }
        
        .punch-effect {
            font-size: 1.5rem;
            animation: punch-pop 0.3s ease-out forwards;
            text-shadow: 1px 1px 0 #000;
        }
        @keyframes punch-pop { 0%{transform:scale(0.5);opacity:1;}100%{transform:scale(1.3) translateY(-20px);opacity:0;} }
        
        .damage-text {
            font-size: 1rem;
            font-weight: bold;
            color: #ff4444;
            animation: damage-float 0.6s ease-out forwards;
            text-shadow: 1px 1px 0 #000;
        }
        .damage-text.crit { color: #ff00ff; font-size: 1.3rem; }
        @keyframes damage-float { 0%{transform:translateY(0);opacity:1;}100%{transform:translateY(-35px);opacity:0;} }
        
        .combo-text {
            font-size: 1.4rem;
            font-weight: bold;
            color: #ffaa00;
            animation: combo-pop 0.7s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }
        @keyframes combo-pop { 0%{transform:scale(0.3) rotate(-8deg);opacity:1;}50%{transform:scale(1.15) rotate(3deg);}100%{transform:scale(1) translateY(-20px);opacity:0;} }
        
        .taunt-bubble {
            background: #000000ee;
            color: #fff;
            padding: 3px 6px;
            border-radius: 6px;
            font-size: 0.6rem;
            animation: taunt-float 1.8s ease-out forwards;
            white-space: nowrap;
            max-width: 130px;
            text-align: center;
        }
        @keyframes taunt-float { 0%{opacity:1;transform:translateY(0);}100%{opacity:0;transform:translateY(-35px);} }
        
        .super-effect {
            font-size: 2rem;
            animation: super-explode 0.4s ease-out forwards;
        }
        @keyframes super-explode { 0%{transform:scale(0);opacity:1;filter:hue-rotate(0deg);}50%{transform:scale(1.8);filter:hue-rotate(180deg);}100%{transform:scale(2.2);opacity:0;filter:hue-rotate(360deg);} }
        
        .thought-bubble {
            position: absolute;
            background: #000000dd;
            color: #fff;
            padding: 2px 5px;
            border-radius: 5px;
            font-size: 0.5rem;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 100px;
            text-align: center;
        }
        .thought-bubble.visible { opacity: 1; }
        
        .round-banner {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 2px 2px 0 #000;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        .round-banner.visible { animation: round-announce 1.6s ease-out forwards; }
        @keyframes round-announce { 0%{opacity:0;transform:translate(-50%,-50%) scale(0.5);}15%{opacity:1;transform:translate(-50%,-50%) scale(1.1);}80%{opacity:1;}100%{opacity:0;} }
        
        .ko-banner {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.5rem;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 3px 3px 0 #000, 0 0 20px #ff0000;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        .ko-banner.visible { opacity: 1; animation: ko-shake 0.4s ease-out; }
        @keyframes ko-shake { 0%,100%{transform:translate(-50%,-50%) rotate(0);}25%{transform:translate(-50%,-50%) rotate(-4deg) scale(1.08);}75%{transform:translate(-50%,-50%) rotate(4deg) scale(1.08);} }
        
        .controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin: 6px 0;
            flex-wrap: wrap;
        }
        button {
            background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
            border: 1px solid #3a3a4e;
            padding: 5px 10px;
            font-family: inherit;
            font-size: 0.7rem;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { border-color: #00ffaa; color: #00ffaa; }
        button.active { background: #00aa7733; border-color: #00ffaa; color: #00ffaa; }
        
        .commentary {
            max-width: 860px;
            margin: 6px auto;
            background: linear-gradient(145deg, #1a1215, #0a0808);
            border: 1px solid #2a1a1a;
            border-radius: 6px;
            padding: 6px;
        }
        .commentary h3 { color: #ffaa00; font-size: 0.65rem; margin-bottom: 3px; }
        #commentary-text { color: #aaa; font-size: 0.7rem; line-height: 1.3; min-height: 25px; }
        .fight-log {
            max-height: 45px;
            overflow-y: auto;
            font-size: 0.5rem;
            color: #444;
            margin-top: 3px;
            padding-top: 3px;
            border-top: 1px solid #222;
        }
        .fight-log div { padding: 1px 0; }
        .fight-log .red { color: #ff6666; }
        .fight-log .blue { color: #6666ff; }
        .fight-log .crit { color: #ff00ff; }
        .fight-log .ko { color: #ff0000; font-weight: bold; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü•ä NEURAL BOXING ULTIMATE ü•ä</h1>
        <div class="subtitle">8 Architectures ‚Ä¢ 25+ Moves ‚Ä¢ Combos ‚Ä¢ Supers ‚Ä¢ Rage Mode ‚Ä¢ Injuries</div>
    </div>
    
    <div class="controls">
        <button id="btn-fight" onclick="toggleFight()">üîî FIGHT</button>
        <button onclick="resetFight()">‚Ü∫ RESET</button>
        <button onclick="setSpeed(0.5)">0.5x</button>
        <button onclick="setSpeed(1)" class="active">1x</button>
        <button onclick="setSpeed(2)">2x</button>
        <button onclick="setSpeed(3)">3x</button>
    </div>
    
    <div class="ring-container">
        <div class="corner-panel red">
            <div class="fighter-header">
                <div class="fighter-icon" id="icon1">üß†</div>
                <div>
                    <div class="fighter-name" id="name1">TNTM</div>
                    <div class="fighter-style" id="style1">Technical Outboxer</div>
                </div>
            </div>
            <div class="fighter-select" id="select1"></div>
            <div class="status-row" id="status1"></div>
            <div class="stat-bars">
                <div class="stat-bar">
                    <div class="label"><span>‚ù§Ô∏è HP</span><span id="hp1-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill hp" id="hp1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>‚ö° STAM</span><span id="stam1-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill stamina" id="stam1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üíú SUPER</span><span id="super1-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill super" id="super1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üî• RAGE</span><span id="rage1-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill rage" id="rage1"></div></div>
                </div>
            </div>
            <div class="stats-grid">
                <div class="stat-item"><div class="val" id="hits1">0</div>Hits</div>
                <div class="stat-item"><div class="val" id="combo1">0</div>Combo</div>
                <div class="stat-item"><div class="val" id="kd1">0</div>KDs</div>
            </div>
            <div class="brain-panel">
                <h4 id="brain1-title">External Memory</h4>
                <div class="brain-viz" id="brain1"></div>
            </div>
            <div class="corner-advice"><span class="label">CORNER:</span> <span id="advice1">Fight smart!</span></div>
        </div>
        
        <div class="ring" id="ring">
            <div class="ring-floor"></div>
            <div class="ropes"><div class="rope"></div><div class="rope"></div><div class="rope"></div><div class="rope"></div></div>
            <div class="corner-post left"></div>
            <div class="corner-post right"></div>
            <div class="crowd" id="crowd">üë•üë•üë•üë•üë•üë•üë•üë•</div>
            
            <div class="scoreboard">
                <span class="red" id="score1">0</span>
                <span class="round" id="round-display">R1</span>
                <span class="timer" id="timer">3:00</span>
                <span class="blue" id="score2">0</span>
            </div>
            
            <div class="boxer red" id="boxer1">
                <div class="thought-bubble" id="thought1"></div>
                <div class="boxer-body">
                    <div class="boxer-head">üß†<span class="injury" id="inj1"></span></div>
                </div>
                <div class="glove left"></div>
                <div class="glove right"></div>
                <div class="leg left"></div>
                <div class="leg right"></div>
            </div>
            
            <div class="boxer blue" id="boxer2">
                <div class="thought-bubble" id="thought2"></div>
                <div class="boxer-body">
                    <div class="boxer-head">‚ö°<span class="injury" id="inj2"></span></div>
                </div>
                <div class="glove left"></div>
                <div class="glove right"></div>
                <div class="leg left"></div>
                <div class="leg right"></div>
            </div>
            
            <div class="round-banner" id="round-banner">ROUND 1</div>
            <div class="ko-banner" id="ko-banner">K.O.!</div>
        </div>
        
        <div class="corner-panel blue">
            <div class="fighter-header">
                <div class="fighter-icon" id="icon2">‚ö°</div>
                <div>
                    <div class="fighter-name" id="name2">Transformer</div>
                    <div class="fighter-style" id="style2">Aggressive Brawler</div>
                </div>
            </div>
            <div class="fighter-select" id="select2"></div>
            <div class="status-row" id="status2"></div>
            <div class="stat-bars">
                <div class="stat-bar">
                    <div class="label"><span>‚ù§Ô∏è HP</span><span id="hp2-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill hp" id="hp2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>‚ö° STAM</span><span id="stam2-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill stamina" id="stam2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üíú SUPER</span><span id="super2-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill super" id="super2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>üî• RAGE</span><span id="rage2-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill rage" id="rage2"></div></div>
                </div>
            </div>
            <div class="stats-grid">
                <div class="stat-item"><div class="val" id="hits2">0</div>Hits</div>
                <div class="stat-item"><div class="val" id="combo2">0</div>Combo</div>
                <div class="stat-item"><div class="val" id="kd2">0</div>KDs</div>
            </div>
            <div class="brain-panel">
                <h4 id="brain2-title">Attention Heads</h4>
                <div class="brain-viz" id="brain2"></div>
            </div>
            <div class="corner-advice"><span class="label">CORNER:</span> <span id="advice2">Fight smart!</span></div>
        </div>
    </div>
    
    <div class="commentary">
        <h3>üì¢ COMMENTARY</h3>
        <div id="commentary-text">Select fighters and ring the bell!</div>
        <div class="fight-log" id="fight-log"></div>
    </div>

<script>
// =============================================
// FIGHTER DATA
// =============================================
const FIGHTERS = {
    tntm: { name:'TNTM', icon:'üß†', style:'Technical Outboxer', superName:'MEMORY OVERLOAD', brainTitle:'External Memory' },
    transformer: { name:'Transformer', icon:'‚ö°', style:'Aggressive Brawler', superName:'ATTENTION STORM', brainTitle:'Attention Heads' },
    lstm: { name:'LSTM', icon:'üîÑ', style:'Patient Counter', superName:'GATE OVERFLOW', brainTitle:'Cell State' },
    mlp: { name:'MLP', icon:'üìä', style:'Simple Striker', superName:'GRADIENT BOMB', brainTitle:'ReLU Layer' },
    cnn: { name:'CNN', icon:'üëÅÔ∏è', style:'Pattern Reader', superName:'KERNEL CRUSH', brainTitle:'Feature Maps' },
    gan: { name:'GAN', icon:'üé≠', style:'Deceptive Trickster', superName:'MODE COLLAPSE', brainTitle:'Gen/Disc' },
    mamba: { name:'Mamba', icon:'üêç', style:'State Space Striker', superName:'SELECTIVE SCAN', brainTitle:'SSM State' },
    rwkv: { name:'RWKV', icon:'üåä', style:'Linear Fighter', superName:'RECEPTANCE WAVE', brainTitle:'WKV State' }
};

const MOVES = {
    jab: { dmg:[3,5], stam:5, range:95, speed:12, type:'punch' },
    cross: { dmg:[5,8], stam:10, range:100, speed:18, type:'punch' },
    hook: { dmg:[7,11], stam:14, range:85, speed:22, type:'punch' },
    uppercut: { dmg:[9,14], stam:18, range:75, speed:26, type:'punch' },
    body_shot: { dmg:[4,7], stam:10, range:80, speed:16, type:'punch', drainStam:8 },
    overhand: { dmg:[8,13], stam:16, range:90, speed:24, type:'punch', kdBonus:0.06 },
    elbow: { dmg:[6,10], stam:12, range:60, speed:16, type:'elbow', cutChance:0.15 },
    spinning_elbow: { dmg:[10,15], stam:20, range:70, speed:28, type:'elbow', cutChance:0.25 },
    knee: { dmg:[7,11], stam:14, range:65, speed:20, type:'knee' },
    flying_knee: { dmg:[12,18], stam:24, range:80, speed:30, type:'knee', kdBonus:0.12 },
    kick: { dmg:[7,11], stam:14, range:120, speed:22, type:'kick' },
    body_kick: { dmg:[6,9], stam:12, range:115, speed:20, type:'kick', drainStam:10 },
    high_kick: { dmg:[11,17], stam:20, range:125, speed:28, type:'kick', kdBonus:0.10 },
    spin_kick: { dmg:[10,15], stam:18, range:130, speed:26, type:'kick' },
    sweep: { dmg:[4,7], stam:12, range:110, speed:24, type:'kick', kdBonus:0.15 },
    one_two: { dmg:[7,11], stam:12, range:95, speed:20, type:'combo', hits:2 },
    three_piece: { dmg:[11,17], stam:20, range:90, speed:28, type:'combo', hits:3 },
    blitz: { dmg:[15,22], stam:28, range:85, speed:35, type:'combo', hits:4 },
    block: { stam:8, speed:8 },
    parry: { stam:8, speed:10 },
    slip: { stam:8, speed:10 },
    weave: { stam:10, speed:12 },
    dodge: { stam:12, speed:14 },
    clinch: { stam:-20, speed:25, range:55 },
    taunt: { stam:6, speed:30, superGain:15, rageGain:10 },
    super: { dmg:[20,30], stam:35, range:110, speed:45, type:'super', kdBonus:0.25 }
};

const TAUNTS = {
    tntm: ["Pattern: LOSER!", "Memory says you suck!", "Content-addressing YOUR FACE!"],
    transformer: ["All heads say: ATTACK!", "Attention to YOUR DEFEAT!", "Self-attention > you!"],
    lstm: ["Forget gate: YOUR WIN!", "Cell state = CHAMPION!", "Gated recurrence FTW!"],
    mlp: ["ReLU(your chances) = 0!", "Feedforward THESE HANDS!", "16 neurons of PAIN!"],
    cnn: ["Feature detected: LOSER!", "Convolved your face!", "Pooling your tears!"],
    gan: ["Generator: YOUR LOSS!", "Mode collapse incoming!", "Adversarially trained!"],
    mamba: ["Selective scan: WEAKNESS!", "State space = doom!", "Ssslithering to WIN!"],
    rwkv: ["WKV = Win KO Victory!", "Linear DESTRUCTION!", "Receptance WAVE!"]
};

// =============================================
// BRAIN IMPLEMENTATIONS - MORE AGGRESSIVE AI
// =============================================
class BaseBrain {
    constructor(type) { this.type = type; this.info = FIGHTERS[type]; }
    renderBrain(c) { c.innerHTML = ''; }
    
    // Base decision helper - ALWAYS be aggressive, only defend when attacked
    baseDecision(me, enemy, dist) {
        // Super ready - USE IT
        if (me.superMeter >= 100 && dist < 110) {
            return { type:'super', move:1, thought:this.info.superName + '!' };
        }
        
        // Rage mode - GO HAM
        if (me.inRage && dist < 90) {
            const moves = ['blitz','flying_knee','three_piece','spinning_elbow'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:1.5, thought:'RAGE MODE!' };
        }
        
        // Stunned enemy - PUNISH
        if (enemy.isStunned && dist < 90) {
            return { type:'three_piece', move:1, thought:'STUNNED! ATTACK!' };
        }
        
        // Low HP enemy - FINISH (below 50 out of 200)
        if (enemy.hp < 50 && dist < 100) {
            const finishers = ['hook','uppercut','high_kick','flying_knee'];
            return { type:finishers[Math.floor(Math.random()*finishers.length)], move:1, thought:'FINISH THEM!' };
        }
        
        // Enemy is blocking - use guard breakers!
        if (enemy.action === 'block' && dist < 90) {
            const breakers = ['body_shot', 'uppercut', 'knee', 'clinch'];
            return { type:breakers[Math.floor(Math.random()*breakers.length)], move:0.5, thought:'Break their guard!' };
        }
        
        return null; // Let specific brain decide
    }
}

class TNTMBrain extends BaseBrain {
    constructor() {
        super('tntm');
        this.memory = Array(32).fill(null).map(() => Array(8).fill(0));
        this.readWeights = Array(32).fill(1/32);
        this.writeHead = 0;
        this.patternBuffer = [];
        this.patterns = {};
    }
    
    write(vec) {
        this.writeHead = (this.writeHead + 1) % 32;
        for (let i = 0; i < Math.min(vec.length, 8); i++) {
            this.memory[this.writeHead][i] = this.memory[this.writeHead][i] * 0.3 + vec[i] * 0.7;
        }
    }
    
    read(query) {
        const sims = this.memory.map(mem => {
            let dot = 0, nQ = 0, nM = 0;
            for (let j = 0; j < 8; j++) { dot += (query[j]||0) * mem[j]; nQ += (query[j]||0)**2; nM += mem[j]**2; }
            return dot / (Math.sqrt(nQ) * Math.sqrt(nM) + 1e-8);
        });
        const max = Math.max(...sims);
        const exps = sims.map(s => Math.exp((s - max) * 2.5));
        const sum = exps.reduce((a, b) => a + b);
        this.readWeights = exps.map(e => e / sum);
        return Math.max(...this.readWeights);
    }
    
    recordPattern(action) {
        if (!action) return;
        this.patternBuffer.push(action);
        if (this.patternBuffer.length > 15) this.patternBuffer.shift();
        if (this.patternBuffer.length >= 3) {
            const key = this.patternBuffer.slice(-3, -1).join('-');
            const next = this.patternBuffer[this.patternBuffer.length - 1];
            if (!this.patterns[key]) this.patterns[key] = {};
            this.patterns[key][next] = (this.patterns[key][next] || 0) + 1;
        }
    }
    
    predict() {
        if (this.patternBuffer.length < 2) return null;
        const key = this.patternBuffer.slice(-2).join('-');
        const p = this.patterns[key];
        if (!p) return null;
        const entries = Object.entries(p).sort((a,b) => b[1] - a[1]);
        return entries[0]?.[0];
    }
    
    decide(me, enemy, dist) {
        const state = [me.hp/100, me.stamina/100, me.superMeter/100, enemy.hp/100, dist/200, enemy.isStunned?1:0, me.inRage?1:0, me.comboCount/5];
        this.recordPattern(enemy.lastAction);
        this.write(state);
        const conf = this.read(state);
        const predicted = this.predict();
        
        // Check base priorities first
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        // Counter predictions - ONLY if enemy is actively attacking
        if (predicted && conf > 0.3 && dist < 100 && enemy.actionTimer > 0) {
            if (['jab','cross'].includes(predicted)) {
                return { type:Math.random()<0.5?'parry':'hook', move:0.5, thought:`Predicted ${predicted}!` };
            }
            if (['hook','overhand'].includes(predicted)) {
                return { type:'slip', move:0.5, thought:'Slip incoming!' };
            }
        }
        
        // Low stamina - clinch to recover, but only if very low
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Clinching...' };
        }
        
        // In range - FIGHT
        if (dist < 85) {
            const moves = ['jab','hook','body_shot','one_two','elbow','knee','cross'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:0.3, thought:`Conf: ${(conf*100).toFixed(0)}%` };
        }
        
        // Mid range - attack with reach
        if (dist < 125) {
            const moves = ['kick','body_kick','jab','cross'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:1, thought:'Attacking!' };
        }
        
        // Far - ALWAYS close distance aggressively
        return { type:Math.random()<0.3?'jab':'idle', move:2, thought:'Closing!' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const g = document.createElement('div');
        g.className = 'memory-grid';
        for (let i = 0; i < 32; i++) {
            const cell = document.createElement('div');
            cell.className = 'mem-cell';
            const w = this.readWeights[i];
            const content = Math.sqrt(this.memory[i].reduce((a, b) => a + b*b, 0));
            cell.style.background = `rgb(${Math.floor(255*w)},${Math.floor(100*content)},${Math.floor(50*w)})`;
            if (i === this.writeHead) cell.style.boxShadow = '0 0 2px #fff';
            g.appendChild(cell);
        }
        c.appendChild(g);
    }
}

class TransformerBrain extends BaseBrain {
    constructor() { super('transformer'); this.context = []; this.attnWeights = Array(4).fill([]); }
    
    decide(me, enemy, dist) {
        const state = [me.hp/100, me.stamina/100, enemy.hp/100, dist/200, Math.random()];
        this.context.push(state);
        if (this.context.length > 8) this.context.shift();
        
        for (let h = 0; h < 4; h++) {
            this.attnWeights[h] = this.context.map(ctx => Math.exp(state.reduce((s, v, j) => s + v * ctx[j] * Math.sin(h + j), 0)));
            const sum = this.attnWeights[h].reduce((a, b) => a + b);
            this.attnWeights[h] = this.attnWeights[h].map(w => w / sum);
        }
        
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        // React to attacks - ONLY if enemy is mid-attack
        if (enemy.actionTimer > 5 && ['jab','hook','kick','cross','uppercut'].includes(enemy.lastAction) && dist < 100) {
            return { type:Math.random()<0.4?'parry':'weave', move:0.5, thought:'Reacting!' };
        }
        
        // Low stamina - clinch only if desperate
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Clinch!' };
        }
        
        // Transformer is AGGRESSIVE - always move forward
        if (dist < 90) {
            const moves = ['hook','one_two','three_piece','elbow','knee','uppercut','body_shot','jab'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:0.5, thought:'ALL HEADS: ATTACK!' };
        }
        
        if (dist < 130) {
            const moves = ['kick','spin_kick','high_kick','jab','cross'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:1.2, thought:'Closing!' };
        }
        
        // Rush in!
        return { type:'jab', move:2.5, thought:'RUSHING!' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const d = document.createElement('div');
        d.style.cssText = 'display:flex;gap:2px;';
        for (let h = 0; h < 4; h++) {
            const head = document.createElement('div');
            head.style.cssText = 'flex:1;height:28px;background:#1a1a2e;border-radius:2px;position:relative;overflow:hidden;';
            const maxW = this.attnWeights[h]?.length > 0 ? Math.max(...this.attnWeights[h]) : 0;
            const bar = document.createElement('div');
            bar.style.cssText = `position:absolute;bottom:0;left:0;right:0;height:${maxW*100}%;background:hsl(${200+h*40},80%,50%);`;
            head.appendChild(bar);
            d.appendChild(head);
        }
        c.appendChild(d);
    }
}

class LSTMBrain extends BaseBrain {
    constructor() {
        super('lstm');
        this.hidden = Array(16).fill(0);
        this.cell = Array(16).fill(0);
        this.forgetGate = Array(16).fill(0.5);
    }
    
    step(input) {
        const sig = x => 1 / (1 + Math.exp(-Math.max(-10, Math.min(10, x))));
        for (let i = 0; i < 16; i++) {
            let f = 0, inp = 0, o = 0, cand = 0;
            input.forEach((v, j) => {
                f += v * Math.sin(i * 7 + j * 3);
                inp += v * Math.cos(i * 11 + j * 5);
                o += v * Math.sin(i * 13 + j * 7);
                cand += v * Math.cos(i * 17 + j * 11);
            });
            this.forgetGate[i] = sig(f);
            this.cell[i] = this.forgetGate[i] * this.cell[i] + sig(inp) * Math.tanh(cand);
            this.hidden[i] = sig(o) * Math.tanh(this.cell[i]);
        }
    }
    
    decide(me, enemy, dist) {
        this.step([me.hp/100, me.stamina/100, enemy.hp/100, enemy.stamina/100, dist/200, me.superMeter/100]);
        
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        // LSTM counter-punches - wait for enemy to attack then counter (only when mid-attack)
        if (enemy.actionTimer > 5 && ['jab','hook','cross'].includes(enemy.lastAction) && dist < 100) {
            return { type:enemy.lastAction === 'jab' ? 'cross' : 'uppercut', move:0.5, thought:'Counter!' };
        }
        
        // Low stamina enemy - body shots
        if (enemy.stamina < 40 && dist < 90) {
            return { type:'body_shot', move:0.5, thought:'Body work!' };
        }
        
        // Low stamina - clinch only if desperate
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Recover!' };
        }
        
        // In range - ATTACK, don't wait around
        if (dist < 90) {
            const moves = ['jab','hook','body_shot','cross','knee','one_two'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:0.3, thought:'Attacking!' };
        }
        
        // Always close
        return { type:Math.random()<0.3?'kick':'idle', move:1.5, thought:'Closing...' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        const sig = x => 1 / (1 + Math.exp(-x));
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const act = sig(this.hidden[i]);
            n.style.background = `rgb(${Math.floor(100+155*this.forgetGate[i])},${Math.floor(200*act)},${Math.floor(100*(1-this.forgetGate[i]))})`;
            neurons.appendChild(n);
        }
        c.appendChild(neurons);
    }
}

class MLPBrain extends BaseBrain {
    constructor() { super('mlp'); this.activations = Array(16).fill(0); }
    
    forward(input) {
        for (let i = 0; i < 16; i++) {
            let sum = input.reduce((s, v, j) => s + v * Math.sin(i * 17 + j * 31), 0);
            this.activations[i] = Math.max(0, sum);
        }
    }
    
    decide(me, enemy, dist) {
        this.forward([me.hp/100, me.stamina/100, enemy.hp/100, dist/200, me.superMeter/100]);
        
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        const active = this.activations.filter(a => a > 0).length;
        
        // Low stamina - clinch only if desperate
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Clinch!' };
        }
        
        // In range - ALWAYS attack
        if (dist < 85) {
            const sum = this.activations.reduce((a, b) => a + b, 0);
            let move;
            if (sum > 3) move = 'hook';
            else if (sum > 2) move = 'one_two';
            else if (sum > 1) move = 'body_shot';
            else move = 'cross';
            return { type:move, move:0.3, thought:`${active}/16 ReLU` };
        }
        
        if (dist < 125) {
            return { type:Math.random()<0.5?'kick':'jab', move:1, thought:'Feedforward!' };
        }
        
        return { type:'jab', move:2, thought:'Approaching!' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const act = Math.min(1, this.activations[i] / 2);
            n.style.background = act > 0 ? `rgb(${Math.floor(255*act)},${Math.floor(170*act)},0)` : '#1a1a1a';
            neurons.appendChild(n);
        }
        c.appendChild(neurons);
    }
}

class CNNBrain extends BaseBrain {
    constructor() { super('cnn'); this.features = Array(16).fill(0); this.posHistory = []; }
    
    decide(me, enemy, dist) {
        this.posHistory.push(enemy.x || 250);
        if (this.posHistory.length > 8) this.posHistory.shift();
        
        // Simple convolution
        if (this.posHistory.length >= 2) {
            this.features[0] = (this.posHistory[this.posHistory.length-1] - this.posHistory[this.posHistory.length-2]) / 50;
        }
        
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        const movingLeft = this.features[0] < -0.2;
        const movingRight = this.features[0] > 0.2;
        
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Clinch!' };
        }
        
        if (dist < 85) {
            if (movingLeft) return { type:'hook', move:0.5, thought:'Cutting off!' };
            if (movingRight) return { type:'cross', move:0.5, thought:'Intercepting!' };
            return { type:['jab','body_shot','knee','one_two'][Math.floor(Math.random()*4)], move:0.3, thought:'Attacking!' };
        }
        
        return { type:Math.random()<0.4?'kick':'jab', move:1.8, thought:'Closing!' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const grid = document.createElement('div');
        grid.style.cssText = 'display:grid;grid-template-columns:repeat(4,1fr);gap:1px;';
        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            const v = Math.abs(this.features[i] || 0);
            cell.style.cssText = `width:10px;height:10px;border-radius:1px;background:rgb(0,${Math.floor(200*Math.min(1,v))},${Math.floor(150*Math.min(1,v))});`;
            grid.appendChild(cell);
        }
        c.appendChild(grid);
    }
}

class GANBrain extends BaseBrain {
    constructor() { super('gan'); this.genState = Array(8).fill(0); this.fakeout = false; }
    
    decide(me, enemy, dist) {
        this.genState = this.genState.map(() => Math.random());
        
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        // GAN is deceptive - feints and surprises
        if (Math.random() < 0.1 && dist < 120) {
            this.fakeout = true;
            return { type:'taunt', move:0.5, thought:'Faking...' };
        }
        
        if (this.fakeout && dist < 90) {
            this.fakeout = false;
            return { type:Math.random()<0.5?'spinning_elbow':'flying_knee', move:1, thought:'SURPRISE!' };
        }
        
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Clinch!' };
        }
        
        if (dist < 85) {
            const moves = ['jab','hook','body_shot','elbow','one_two','cross'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:0.3, thought:'Attacking!' };
        }
        
        return { type:Math.random()<0.3?'kick':'jab', move:1.5, thought:'Closing!' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const div = document.createElement('div');
        div.style.cssText = 'display:flex;gap:2px;';
        for (let i = 0; i < 8; i++) {
            const n = document.createElement('div');
            n.style.cssText = `width:8px;height:8px;border-radius:50%;background:rgb(${Math.floor(255*this.genState[i])},50,${Math.floor(200*this.genState[i])});`;
            div.appendChild(n);
        }
        c.appendChild(div);
    }
}

class MambaBrain extends BaseBrain {
    constructor() { super('mamba'); this.state = Array(16).fill(0); }
    
    decide(me, enemy, dist) {
        // Update state
        const input = [me.hp/100, me.stamina/100, enemy.hp/100, dist/200];
        for (let i = 0; i < 16; i++) {
            const sel = 1 / (1 + Math.exp(-input[i % input.length] * Math.sin(i * 7)));
            this.state[i] = this.state[i] * (1 - sel) + input[i % input.length] * sel;
        }
        
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Clinch!' };
        }
        
        if (dist < 85) {
            const moves = ['jab','hook','one_two','elbow','knee','body_shot','cross'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:0.3, thought:'Sssstriking!' };
        }
        
        return { type:Math.random()<0.4?'kick':'jab', move:1.8, thought:'Ssslithering!' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const s = Math.abs(this.state[i]);
            n.style.background = `rgb(${Math.floor(100*s)},${Math.floor(255*s)},${Math.floor(100*s)})`;
            neurons.appendChild(n);
        }
        c.appendChild(neurons);
    }
}

class RWKVBrain extends BaseBrain {
    constructor() { super('rwkv'); this.wkv = Array(16).fill(0); }
    
    decide(me, enemy, dist) {
        const input = [me.hp/100, me.stamina/100, enemy.hp/100, dist/200];
        for (let i = 0; i < 16; i++) {
            const w = Math.exp(-Math.abs(input[i % input.length] - 0.5));
            const k = input[i % input.length] * Math.sin(i);
            const v = input[(i + 1) % input.length];
            this.wkv[i] = this.wkv[i] * 0.9 + w * k * v;
        }
        
        const base = this.baseDecision(me, enemy, dist);
        if (base) return base;
        
        if (me.stamina < 15 && dist < 60) {
            return { type:'clinch', move:0.5, thought:'Clinch!' };
        }
        
        if (dist < 85) {
            const moves = ['jab','cross','hook','one_two','body_shot','elbow'];
            return { type:moves[Math.floor(Math.random()*moves.length)], move:0.3, thought:'Attacking!' };
        }
        
        return { type:Math.random()<0.4?'kick':'jab', move:1.6, thought:'Closing!' };
    }
    
    renderBrain(c) {
        c.innerHTML = '';
        const neurons = document.createElement('div');
        neurons.className = 'hidden-neurons';
        for (let i = 0; i < 16; i++) {
            const n = document.createElement('div');
            n.className = 'neuron';
            const s = (Math.tanh(this.wkv[i]) + 1) / 2;
            n.style.background = `rgb(${Math.floor(100*s)},${Math.floor(200*s)},${Math.floor(255*s)})`;
            neurons.appendChild(n);
        }
        c.appendChild(neurons);
    }
}

const BRAINS = { tntm: TNTMBrain, transformer: TransformerBrain, lstm: LSTMBrain, mlp: MLPBrain, cnn: CNNBrain, gan: GANBrain, mamba: MambaBrain, rwkv: RWKVBrain };

// =============================================
// GAME ENGINE
// =============================================
let boxers = [];
let running = false;
let speed = 1;
let round = 1;
let roundTime = 0;
let maxRoundTime = 180;
let scores = [0, 0];
let fightLog = [];

function log(msg, type = '') {
    fightLog.unshift({ msg, type });
    if (fightLog.length > 30) fightLog.pop();
    document.getElementById('fight-log').innerHTML = fightLog.slice(0, 8).map(l => `<div class="${l.type}">${l.msg}</div>`).join('');
}

function comment(text) {
    document.getElementById('commentary-text').textContent = text;
}

function showEffect(x, y, type, text, extra = '') {
    const el = document.createElement('div');
    el.className = `effect ${type} ${extra}`;
    el.textContent = text;
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
    document.getElementById('ring').appendChild(el);
    setTimeout(() => el.remove(), type === 'taunt-bubble' ? 1800 : 600);
}

function createBoxer(id, type) {
    const info = FIGHTERS[type];
    const BrainClass = BRAINS[type];
    return {
        id, type,
        brain: new BrainClass(),
        info,
        hp: 200, maxHp: 200,
        stamina: 100, maxStamina: 100,
        superMeter: 0,
        rageMeter: 0,
        inRage: false,
        x: id === 1 ? 120 : 360,
        action: 'idle',
        lastAction: null,
        actionTimer: 0,
        comboCount: 0,
        comboTimer: 0,
        hits: 0,
        knockdowns: 0,
        isDown: false,
        downTimer: 0,
        isStunned: false,
        stunTimer: 0,
        isBleeding: false,
        bleedTimer: 0
    };
}

function initFighterSelects() {
    [1, 2].forEach(slot => {
        const container = document.getElementById(`select${slot}`);
        container.innerHTML = '';
        Object.entries(FIGHTERS).forEach(([type, info]) => {
            const opt = document.createElement('div');
            opt.className = 'fighter-option' + ((slot === 1 && type === 'tntm') || (slot === 2 && type === 'transformer') ? ' selected' : '');
            opt.dataset.type = type;
            opt.innerHTML = `<div class="icon">${info.icon}</div><div class="name">${info.name}</div>`;
            opt.onclick = () => selectFighter(slot, type);
            container.appendChild(opt);
        });
    });
}

function selectFighter(slot, type) {
    document.querySelectorAll(`#select${slot} .fighter-option`).forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.type === type);
    });
    
    boxers[slot - 1] = createBoxer(slot, type);
    const b = boxers[slot - 1];
    const info = b.info;
    
    document.getElementById(`name${slot}`).textContent = info.name;
    document.getElementById(`style${slot}`).textContent = info.style;
    document.getElementById(`icon${slot}`).textContent = info.icon;
    document.getElementById(`brain${slot}-title`).textContent = info.brainTitle;
    document.getElementById(`boxer${slot}`).querySelector('.boxer-head').innerHTML = info.icon + `<span class="injury" id="inj${slot}"></span>`;
    
    updateUI();
    renderBrains();
}

function processAction(attacker, defender) {
    if (attacker.isDown || (attacker.isStunned && attacker.stunTimer > 0) || attacker.actionTimer > 0) return;
    
    const dist = Math.abs(attacker.x - defender.x);
    const decision = attacker.brain.decide(attacker, defender, dist);
    
    // Thought bubble
    const thought = document.getElementById(`thought${attacker.id}`);
    thought.textContent = decision.thought || '';
    thought.classList.toggle('visible', !!decision.thought);
    
    // Movement - ALWAYS apply, direction based on fighter position
    let moveDir = decision.move || 0;
    if (attacker.id === 2) moveDir = -moveDir; // Blue fighter faces left
    
    // Force fighters toward center if too far apart
    const center = 240;
    if (dist > 200) {
        if (attacker.x < center) moveDir = Math.max(moveDir, 1.5);
        else moveDir = Math.min(moveDir, -1.5);
    }
    
    attacker.x = Math.max(50, Math.min(430, attacker.x + moveDir * speed * 1.5));
    
    const actionType = decision.type || 'idle';
    if (actionType === 'idle') return;
    
    const moveData = MOVES[actionType];
    if (!moveData) return;
    
    // Stamina check
    const stamCost = moveData.stam || 0;
    if (stamCost > 0 && attacker.stamina < stamCost) return;
    
    attacker.stamina = Math.max(0, Math.min(attacker.maxStamina, attacker.stamina - stamCost));
    attacker.action = actionType;
    attacker.lastAction = actionType;
    attacker.actionTimer = (moveData.speed || 15) / speed;
    
    // Super/rage gains
    if (moveData.superGain) attacker.superMeter = Math.min(100, attacker.superMeter + moveData.superGain);
    if (moveData.rageGain) attacker.rageMeter = Math.min(100, attacker.rageMeter + moveData.rageGain);
    
    // Taunt
    if (actionType === 'taunt') {
        const tauntList = TAUNTS[attacker.type] || TAUNTS.mlp;
        const taunt = tauntList[Math.floor(Math.random() * tauntList.length)];
        showEffect(attacker.x, 70, 'taunt-bubble', taunt);
        comment(`${attacker.info.name}: "${taunt}"`);
        log(`${attacker.info.name} taunts!`, attacker.id === 1 ? 'red' : 'blue');
        return;
    }
    
    // Clinch - recover stamina
    if (actionType === 'clinch' && dist < (moveData.range || 60)) {
        attacker.stamina = Math.min(attacker.maxStamina, attacker.stamina + 25);
        defender.actionTimer = Math.max(defender.actionTimer, 25);
        log(`${attacker.info.name} clinches!`, attacker.id === 1 ? 'red' : 'blue');
        return;
    }
    
    // Attack
    if (!moveData.dmg) return;
    if (dist > (moveData.range || 85)) return;
    
    // Defense check
    let damage = moveData.dmg[0] + Math.random() * (moveData.dmg[1] - moveData.dmg[0]);
    let blocked = false, parried = false, dodged = false;
    
    if (defender.action === 'block' && defender.actionTimer > 0) {
        damage *= 0.45; // Blocking only reduces 55% of damage
        blocked = true;
        defender.stamina -= 5; // Blocking drains stamina too
        showEffect(defender.x, 85, 'punch-effect', 'üõ°Ô∏è');
    } else if (defender.action === 'parry' && defender.actionTimer > 0 && Math.random() < 0.7) {
        damage = 0;
        parried = true;
        showEffect(defender.x, 75, 'punch-effect', '‚ú®');
        attacker.isStunned = true;
        attacker.stunTimer = 30;
        defender.superMeter = Math.min(100, defender.superMeter + 20);
        comment(`PARRY by ${defender.info.name}!`);
        log(`${defender.info.name} PARRIES!`, 'crit');
    } else if (['slip', 'weave', 'dodge'].includes(defender.action) && defender.actionTimer > 0) {
        if (Math.random() < 0.6) {
            damage = 0;
            dodged = true;
            showEffect(defender.x, 75, 'punch-effect', 'üí®');
        }
    }
    
    if (parried || dodged) {
        attacker.comboCount = 0;
        return;
    }
    
    // Rage bonus
    if (attacker.inRage) damage *= 1.35;
    
    // Combo bonus
    if (attacker.comboTimer > 0) {
        attacker.comboCount++;
        damage *= (1 + attacker.comboCount * 0.1);
    } else {
        attacker.comboCount = 1;
    }
    attacker.comboTimer = 80;
    
    // Apply damage
    defender.hp -= damage;
    attacker.hits++;
    attacker.superMeter = Math.min(100, attacker.superMeter + damage * 1.2); // More super gain
    defender.rageMeter = Math.min(100, defender.rageMeter + damage * 1.5);   // More rage when hit
    
    // Stamina drain
    if (moveData.drainStam) defender.stamina = Math.max(0, defender.stamina - moveData.drainStam);
    
    // Effects
    const effects = { jab:'üí•', cross:'‚ú®', hook:'üí´', uppercut:'‚≠ê', body_shot:'üí®', overhand:'üí¢', elbow:'üî•', spinning_elbow:'üåÄ', knee:'ü¶µ', flying_knee:'üöÄ', kick:'ü¶∂', body_kick:'üí®', high_kick:'üíÄ', spin_kick:'üå™Ô∏è', sweep:'üåä', one_two:'üí•üí•', three_piece:'üí•üí•üí•', blitz:'üî•üî•üî•', super:'üíÄ' };
    showEffect(defender.x, 70, 'punch-effect', effects[actionType] || 'üí•');
    showEffect(defender.x + 15, 50, 'damage-text', `-${Math.floor(damage)}`, damage > 25 ? 'crit' : '');
    
    if (attacker.comboCount >= 3) {
        showEffect(240, 110, 'combo-text', `${attacker.comboCount}x COMBO!`);
    }
    
    // Hit animation
    document.getElementById(`boxer${defender.id}`).classList.add('hit');
    setTimeout(() => document.getElementById(`boxer${defender.id}`).classList.remove('hit'), 120);
    
    // Super attack
    if (actionType === 'super') {
        attacker.superMeter = 0;
        defender.isStunned = true;
        defender.stunTimer = 50;
        showEffect(defender.x, 55, 'super-effect', 'üíÄ');
        comment(`${attacker.info.name}'s ${attacker.info.superName}! DEVASTATING!`);
        log(`${attacker.info.name}'s ${attacker.info.superName}!`, 'crit');
    }
    
    // Cut chance
    if (moveData.cutChance && Math.random() < moveData.cutChance) {
        defender.isBleeding = true;
        defender.bleedTimer = 200;
        comment(`${defender.info.name} is CUT!`);
        log(`${defender.info.name} is bleeding!`, 'ko');
    }
    
    // Knockdown check - harder to knock down
    let kdChance = (moveData.kdBonus || 0);
    if (defender.hp < 40) kdChance += 0.08;  // Only bonus when very hurt
    if (defender.hp < 20) kdChance += 0.15;  // Big bonus when nearly KO'd
    if (damage > 18) kdChance += 0.05;       // Big hits have small KD chance
    
    if (Math.random() < kdChance && !blocked) {
        defender.isDown = true;
        defender.downTimer = 120;
        defender.knockdowns++;
        attacker.comboCount = 0;
        comment(`${defender.info.name} IS DOWN!`);
        log(`${defender.info.name} KNOCKED DOWN!`, 'ko');
    }
    
    log(`${attacker.info.name} ${actionType} (-${Math.floor(damage)})`, attacker.id === 1 ? 'red' : 'blue');
}

function updateBoxer(b) {
    if (b.actionTimer > 0) b.actionTimer -= speed;
    if (b.actionTimer <= 0 && b.action !== 'idle') b.action = 'idle';
    
    if (b.isDown) {
        b.downTimer -= speed;
        if (b.downTimer <= 0) {
            b.isDown = false;
            b.hp = Math.max(b.hp, 25); // Get up with at least 25 HP
            b.isStunned = true;
            b.stunTimer = 30;
        }
    }
    
    if (b.isStunned) {
        b.stunTimer -= speed;
        if (b.stunTimer <= 0) b.isStunned = false;
    }
    
    if (b.isBleeding) {
        b.bleedTimer -= speed;
        b.hp -= 0.015 * speed;
        if (b.bleedTimer <= 0) b.isBleeding = false;
    }
    
    // FIXED: Much faster stamina recovery
    if (!b.isDown) {
        // Always recover some stamina
        b.stamina = Math.min(b.maxStamina, b.stamina + 0.5 * speed);
        // Extra recovery when idle
        if (b.action === 'idle') {
            b.stamina = Math.min(b.maxStamina, b.stamina + 0.3 * speed);
        }
    }
    
    // Combo decay
    if (b.comboTimer > 0) {
        b.comboTimer -= speed;
        if (b.comboTimer <= 0) b.comboCount = 0;
    }
    
    // Rage activation (below 80 HP out of 200)
    if (!b.inRage && b.rageMeter >= 100 && b.hp < 80) {
        b.inRage = true;
        comment(`${b.info.name} enters RAGE MODE!`);
        log(`${b.info.name} RAGE MODE!`, 'crit');
    }
    if (b.inRage) {
        b.rageMeter -= 0.2 * speed;
        if (b.rageMeter <= 0) {
            b.inRage = false;
            b.rageMeter = 0;
        }
    }
}

function renderBoxers() {
    boxers.forEach((b, i) => {
        const el = document.getElementById(`boxer${i + 1}`);
        el.style.left = `${b.x - 35}px`;
        el.style.bottom = '120px';
        
        el.className = `boxer ${i === 0 ? 'red' : 'blue'}`;
        
        if (b.inRage) el.classList.add('rage');
        if (b.superMeter >= 100) el.classList.add('super-ready');
        
        if (b.isDown) el.classList.add('knocked-down');
        else if (b.isStunned) el.classList.add('stunned');
        else {
            const map = {
                'jab':'jabbing', 'cross':'crossing', 'hook':'hooking', 'uppercut':'uppercutting',
                'body_shot':'body-shotting', 'overhand':'hooking', 'elbow':'elbowing',
                'spinning_elbow':'elbowing', 'knee':'kneeing', 'flying_knee':'flying-knee',
                'kick':'kicking', 'body_kick':'kicking', 'high_kick':'high-kicking',
                'spin_kick':'spin-kicking', 'sweep':'sweeping',
                'one_two':'jabbing', 'three_piece':'hooking', 'blitz':'hooking',
                'block':'blocking', 'parry':'parrying', 'slip':'weaving', 'weave':'weaving', 'dodge':'dodging',
                'clinch':'clinching', 'taunt':'taunting', 'super':'super-attacking'
            };
            if (map[b.action]) el.classList.add(map[b.action]);
        }
        
        if (i === 1) el.style.transform = 'scaleX(-1)';
        
        document.getElementById(`inj${i + 1}`).textContent = b.isBleeding ? 'ü©∏' : '';
    });
}

function renderBrains() {
    boxers.forEach((b, i) => b.brain.renderBrain(document.getElementById(`brain${i + 1}`)));
}

function updateUI() {
    boxers.forEach((b, i) => {
        const n = i + 1;
        const hpPct = Math.max(0, b.hp) / b.maxHp * 100;
        
        document.getElementById(`hp${n}`).style.width = `${hpPct}%`;
        document.getElementById(`hp${n}`).classList.toggle('low', hpPct < 35);
        document.getElementById(`hp${n}-text`).textContent = Math.floor(Math.max(0, b.hp));
        
        document.getElementById(`stam${n}`).style.width = `${Math.max(0, b.stamina)}%`;
        document.getElementById(`stam${n}-text`).textContent = Math.floor(Math.max(0, b.stamina));
        
        document.getElementById(`super${n}`).style.width = `${b.superMeter}%`;
        document.getElementById(`super${n}-text`).textContent = `${Math.floor(b.superMeter)}%`;
        
        document.getElementById(`rage${n}`).style.width = `${b.rageMeter}%`;
        document.getElementById(`rage${n}-text`).textContent = `${Math.floor(b.rageMeter)}%`;
        
        document.getElementById(`hits${n}`).textContent = b.hits;
        document.getElementById(`combo${n}`).textContent = b.comboCount;
        document.getElementById(`kd${n}`).textContent = b.knockdowns;
        
        // Status badges
        const status = document.getElementById(`status${n}`);
        status.innerHTML = '';
        if (b.inRage) status.innerHTML += '<span class="status-badge rage">üî• RAGE</span>';
        if (b.superMeter >= 100) status.innerHTML += '<span class="status-badge super">üíú SUPER</span>';
        if (b.isStunned) status.innerHTML += '<span class="status-badge stunned">üí´ STUNNED</span>';
        if (b.isBleeding) status.innerHTML += '<span class="status-badge bleeding">ü©∏ CUT</span>';
        if (b.stamina < 25) status.innerHTML += '<span class="status-badge tired">üòÆ‚Äçüí® TIRED</span>';
        if (b.comboCount >= 3) status.innerHTML += `<span class="status-badge combo">${b.comboCount}x</span>`;
        
        // Corner advice
        let advice = 'Fight smart!';
        if (b.hp < 60) advice = "You're hurt, be careful!";
        else if (b.stamina < 30) advice = "Clinch to recover!";
        else if (b.superMeter >= 100) advice = "SUPER READY! USE IT!";
        else if (b.inRage) advice = "RAGE MODE! GO HAM!";
        else if (boxers[1-i].hp < 60) advice = "They're hurt! FINISH!";
        document.getElementById(`advice${n}`).textContent = advice;
    });
    
    // FIXED: Properly update scores
    document.getElementById('score1').textContent = scores[0];
    document.getElementById('score2').textContent = scores[1];
    document.getElementById('round-display').textContent = `R${round}`;
    
    const timeLeft = Math.max(0, maxRoundTime - roundTime);
    const mins = Math.floor(timeLeft / 60);
    const secs = Math.floor(timeLeft % 60);
    document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
}

function checkRoundEnd() {
    // KO check
    for (let i = 0; i < 2; i++) {
        if (boxers[i].hp <= 0) {
            running = false;
            scores[1 - i]++; // Winner gets a point
            updateUI(); // Update UI to show new score
            document.getElementById('ko-banner').classList.add('visible');
            comment(`K.O.! ${boxers[1 - i].info.name} WINS!`);
            log(`${boxers[1 - i].info.name} WINS BY KO!`, 'ko');
            document.getElementById('btn-fight').textContent = 'üîî NEW';
            return true;
        }
    }
    
    // Round time - 0.016 seconds per frame at 60fps
    roundTime += 0.016 * speed;
    if (roundTime >= maxRoundTime) {
        // Score round based on HITS LANDED (aggression) not just damage avoided
        const score0 = boxers[0].hits + boxers[0].knockdowns * 5;
        const score1 = boxers[1].hits + boxers[1].knockdowns * 5;
        
        if (score0 > score1) {
            scores[0]++;
            comment(`Round ${round} to ${boxers[0].info.name}! (${score0} vs ${score1} effective strikes)`);
        } else if (score1 > score0) {
            scores[1]++;
            comment(`Round ${round} to ${boxers[1].info.name}! (${score1} vs ${score0} effective strikes)`);
        } else {
            comment(`Round ${round} is a DRAW!`);
        }
        
        // Reset hit counters for next round
        boxers[0].roundHits = 0;
        boxers[1].roundHits = 0;
        
        round++;
        roundTime = 0;
        
        if (round > 12) {
            running = false;
            const winner = scores[0] > scores[1] ? boxers[0] : scores[1] > scores[0] ? boxers[1] : null;
            comment(winner ? `DECISION! ${winner.info.name} wins ${Math.max(scores[0], scores[1])}-${Math.min(scores[0], scores[1])}!` : 'DRAW!');
            document.getElementById('btn-fight').textContent = 'üîî NEW';
            return true;
        }
        
        // Reset for new round
        boxers.forEach(b => {
            b.hp = Math.min(b.maxHp, b.hp + 30); // Recover 30 HP between rounds
            b.stamina = b.maxStamina;
            b.x = b.id === 1 ? 120 : 360;
            b.action = 'idle';
            b.actionTimer = 0;
            b.isDown = false;
            b.isStunned = false;
            b.comboCount = 0;
        });
        
        document.getElementById('round-banner').textContent = `ROUND ${round}`;
        document.getElementById('round-banner').classList.add('visible');
        setTimeout(() => document.getElementById('round-banner').classList.remove('visible'), 1600);
        
        updateUI();
    }
    
    return false;
}

function gameLoop() {
    if (!running) return;
    
    processAction(boxers[0], boxers[1]);
    processAction(boxers[1], boxers[0]);
    
    boxers.forEach(updateBoxer);
    
    renderBoxers();
    renderBrains();
    updateUI();
    
    if (!checkRoundEnd()) requestAnimationFrame(gameLoop);
}

function toggleFight() {
    if (boxers.some(b => b.hp <= 0) || round > 12) {
        resetFight();
        return;
    }
    
    running = !running;
    document.getElementById('btn-fight').textContent = running ? '‚è∏ PAUSE' : 'üîî FIGHT';
    
    if (running) {
        if (roundTime === 0 && round === 1) {
            document.getElementById('round-banner').textContent = 'ROUND 1';
            document.getElementById('round-banner').classList.add('visible');
            setTimeout(() => document.getElementById('round-banner').classList.remove('visible'), 1600);
            comment(`${boxers[0].info.name} vs ${boxers[1].info.name}! FIGHT!`);
        }
        requestAnimationFrame(gameLoop);
    }
}

function resetFight() {
    running = false;
    round = 1;
    roundTime = 0;
    scores = [0, 0];
    fightLog = [];
    
    document.getElementById('ko-banner').classList.remove('visible');
    document.getElementById('btn-fight').textContent = 'üîî FIGHT';
    document.getElementById('fight-log').innerHTML = '';
    
    const type1 = document.querySelector('#select1 .selected')?.dataset.type || 'tntm';
    const type2 = document.querySelector('#select2 .selected')?.dataset.type || 'transformer';
    
    boxers = [createBoxer(1, type1), createBoxer(2, type2)];
    
    renderBoxers();
    renderBrains();
    updateUI();
    
    comment(`${boxers[0].info.name} vs ${boxers[1].info.name}! Select and FIGHT!`);
}

function setSpeed(s) {
    speed = s;
    document.querySelectorAll('.controls button').forEach(btn => {
        if (btn.textContent.includes('x')) btn.classList.toggle('active', btn.textContent === `${s}x`);
    });
}

// Init
initFighterSelects();
boxers = [createBoxer(1, 'tntm'), createBoxer(2, 'transformer')];
renderBoxers();
renderBrains();
updateUI();
</script>
</body>
</html>
