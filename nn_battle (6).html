<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Battle Arena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #container {
            display: flex;
            height: 100vh;
        }
        #arena {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%);
            border-right: 2px solid #333;
        }
        canvas {
            display: block;
        }
        #sidebar {
            width: 360px;
            padding: 10px;
            background: #111118;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        h1 {
            font-size: 1.2em;
            color: #00ffaa;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ffaa55;
        }
        .nn-card {
            background: #1a1a25;
            border-radius: 6px;
            padding: 8px;
            border: 1px solid #333;
        }
        .nn-card h3 {
            font-size: 0.8em;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .nn-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .transformer .nn-icon { background: #ff6b6b; box-shadow: 0 0 8px #ff6b6b; }
        .mamba .nn-icon { background: #4ecdc4; box-shadow: 0 0 8px #4ecdc4; }
        .moe .nn-icon { background: #ffe66d; box-shadow: 0 0 8px #ffe66d; }
        .ntm .nn-icon { background: #a855f7; box-shadow: 0 0 8px #a855f7; }
        .rwkv .nn-icon { background: #22c55e; box-shadow: 0 0 8px #22c55e; }
        .xlstm .nn-icon { background: #f97316; box-shadow: 0 0 8px #f97316; }
        .hyena .nn-icon { background: #06b6d4; box-shadow: 0 0 8px #06b6d4; }
        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.7em;
            margin: 2px 0;
            color: #888;
        }
        .stat-value { color: #fff; }
        .health-bar {
            height: 5px;
            background: #333;
            border-radius: 3px;
            margin: 4px 0;
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            transition: width 0.3s;
            border-radius: 3px;
        }
        .transformer .health-fill { background: linear-gradient(90deg, #ff6b6b, #ff8e8e); }
        .mamba .health-fill { background: linear-gradient(90deg, #4ecdc4, #7eddd6); }
        .moe .health-fill { background: linear-gradient(90deg, #ffe66d, #fff09a); }
        .ntm .health-fill { background: linear-gradient(90deg, #a855f7, #c084fc); }
        .rwkv .health-fill { background: linear-gradient(90deg, #22c55e, #4ade80); }
        .xlstm .health-fill { background: linear-gradient(90deg, #f97316, #fb923c); }
        .hyena .health-fill { background: linear-gradient(90deg, #06b6d4, #22d3ee); }
        .learning-indicator {
            font-size: 0.65em;
            color: #00ff88;
            margin-top: 2px;
        }
        .brain-vis {
            display: flex;
            gap: 2px;
            margin-top: 4px;
            flex-wrap: wrap;
        }
        .neuron {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: #333;
            transition: background 0.2s;
        }
        .neuron.active { background: #00ffaa; }
        #controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        button {
            flex: 1;
            padding: 10px;
            background: #00ffaa22;
            border: 1px solid #00ffaa;
            color: #00ffaa;
            cursor: pointer;
            border-radius: 5px;
            font-family: inherit;
            transition: all 0.2s;
        }
        button:hover {
            background: #00ffaa44;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #log {
            flex: 1;
            background: #0a0a10;
            border-radius: 5px;
            padding: 8px;
            font-size: 0.65em;
            overflow-y: auto;
            max-height: 120px;
            border: 1px solid #222;
        }
        .log-entry {
            margin: 3px 0;
            padding: 2px 0;
            border-bottom: 1px solid #1a1a1a;
        }
        .log-entry.kill { color: #ff6b6b; }
        .log-entry.learn { color: #00ffaa; }
        .log-entry.respawn { color: #888; }
        #generation {
            text-align: center;
            font-size: 0.9em;
            color: #666;
            padding: 8px;
            background: #0a0a10;
            border-radius: 5px;
        }
        #generation span { color: #00ffaa; font-weight: bold; }
        .weights-display {
            font-size: 0.6em;
            color: #555;
            margin-top: 2px;
            word-break: break-all;
        }
        #speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #0a0a10;
            border-radius: 5px;
        }
        #speed-control label { font-size: 0.8em; color: #666; }
        #speed-slider { flex: 1; }
    </style>
</head>
<body>
    <div id="container">
        <div id="arena">
            <canvas id="canvas"></canvas>
        </div>
        <div id="sidebar">
            <h1>‚öîÔ∏è Neural Network Battle Arena</h1>
            
            <div id="generation">Gen: <span id="gen-num">1</span> | Round: <span id="round-num">1</span> | Hits: <span id="fight-num">0</span></div>
            
            <div id="controls">
                <button id="pauseBtn">‚è∏Ô∏è Pause</button>
                <button id="resetBtn">üîÑ Reset</button>
            </div>
            
            <div id="speed-control">
                <label>Speed:</label>
                <input type="range" id="speed-slider" min="0.5" max="3" step="0.25" value="1">
                <span id="speed-value">1x</span>
            </div>
            
            <div class="nn-card transformer">
                <h3><span class="nn-icon"></span>TRANSFORMER</h3>
                <div class="stat-row">Attention Heads: <span class="stat-value" id="t-heads">8</span></div>
                <div class="health-bar"><div class="health-fill" id="t-health" style="width:100%"></div></div>
                <div class="stat-row">Kills: <span class="stat-value" id="t-kills">0</span> | Deaths: <span class="stat-value" id="t-deaths">0</span> | Wins: <span class="stat-value" id="t-wins">0</span></div>
                <div class="stat-row">Accuracy: <span class="stat-value" id="t-accuracy">0%</span></div>
                <div class="learning-indicator" id="t-learning"></div>
                <div class="brain-vis" id="t-brain"></div>
                <div class="weights-display" id="t-weights"></div>
            </div>
            
            <div class="nn-card mamba">
                <h3><span class="nn-icon"></span>MAMBA (SSM)</h3>
                <div class="stat-row">State Dim: <span class="stat-value" id="m-state">16</span></div>
                <div class="health-bar"><div class="health-fill" id="m-health" style="width:100%"></div></div>
                <div class="stat-row">Kills: <span class="stat-value" id="m-kills">0</span> | Deaths: <span class="stat-value" id="m-deaths">0</span> | Wins: <span class="stat-value" id="m-wins">0</span></div>
                <div class="stat-row">Accuracy: <span class="stat-value" id="m-accuracy">0%</span></div>
                <div class="learning-indicator" id="m-learning"></div>
                <div class="brain-vis" id="m-brain"></div>
                <div class="weights-display" id="m-weights"></div>
            </div>
            
            <div class="nn-card moe">
                <h3><span class="nn-icon"></span>MIXTURE OF EXPERTS</h3>
                <div class="stat-row">Active Experts: <span class="stat-value" id="e-experts">2/8</span></div>
                <div class="health-bar"><div class="health-fill" id="e-health" style="width:100%"></div></div>
                <div class="stat-row">Kills: <span class="stat-value" id="e-kills">0</span> | Deaths: <span class="stat-value" id="e-deaths">0</span> | Wins: <span class="stat-value" id="e-wins">0</span></div>
                <div class="stat-row">Accuracy: <span class="stat-value" id="e-accuracy">0%</span></div>
                <div class="learning-indicator" id="e-learning"></div>
                <div class="brain-vis" id="e-brain"></div>
                <div class="weights-display" id="e-weights"></div>
            </div>
            
            <div class="nn-card ntm">
                <h3><span class="nn-icon"></span>NEURAL TURING MACHINE</h3>
                <div class="stat-row">Memory Slots: <span class="stat-value" id="n-memory">32</span></div>
                <div class="health-bar"><div class="health-fill" id="n-health" style="width:100%"></div></div>
                <div class="stat-row">Kills: <span class="stat-value" id="n-kills">0</span> | Deaths: <span class="stat-value" id="n-deaths">0</span> | Wins: <span class="stat-value" id="n-wins">0</span></div>
                <div class="stat-row">Accuracy: <span class="stat-value" id="n-accuracy">0%</span></div>
                <div class="learning-indicator" id="n-learning"></div>
                <div class="brain-vis" id="n-brain"></div>
                <div class="weights-display" id="n-weights"></div>
            </div>
            
            <div class="nn-card rwkv">
                <h3><span class="nn-icon"></span>RWKV (Linear RNN)</h3>
                <div class="stat-row">Channels: <span class="stat-value" id="r-channels">16</span></div>
                <div class="health-bar"><div class="health-fill" id="r-health" style="width:100%"></div></div>
                <div class="stat-row">Kills: <span class="stat-value" id="r-kills">0</span> | Deaths: <span class="stat-value" id="r-deaths">0</span> | Wins: <span class="stat-value" id="r-wins">0</span></div>
                <div class="stat-row">Accuracy: <span class="stat-value" id="r-accuracy">0%</span></div>
                <div class="learning-indicator" id="r-learning"></div>
                <div class="brain-vis" id="r-brain"></div>
                <div class="weights-display" id="r-weights"></div>
            </div>
            
            <div class="nn-card xlstm">
                <h3><span class="nn-icon"></span>xLSTM (Exp Gates)</h3>
                <div class="stat-row">Hidden: <span class="stat-value" id="x-hidden">16</span> | Matrix: <span class="stat-value">8x8</span></div>
                <div class="health-bar"><div class="health-fill" id="x-health" style="width:100%"></div></div>
                <div class="stat-row">Kills: <span class="stat-value" id="x-kills">0</span> | Deaths: <span class="stat-value" id="x-deaths">0</span> | Wins: <span class="stat-value" id="x-wins">0</span></div>
                <div class="stat-row">Accuracy: <span class="stat-value" id="x-accuracy">0%</span></div>
                <div class="learning-indicator" id="x-learning"></div>
                <div class="brain-vis" id="x-brain"></div>
                <div class="weights-display" id="x-weights"></div>
            </div>
            
            <div class="nn-card hyena">
                <h3><span class="nn-icon"></span>HYENA (Long Conv)</h3>
                <div class="stat-row">Filters: <span class="stat-value" id="h-filters">3</span> | Seq: <span class="stat-value">16</span></div>
                <div class="health-bar"><div class="health-fill" id="h-health" style="width:100%"></div></div>
                <div class="stat-row">Kills: <span class="stat-value" id="h-kills">0</span> | Deaths: <span class="stat-value" id="h-deaths">0</span> | Wins: <span class="stat-value" id="h-wins">0</span></div>
                <div class="stat-row">Accuracy: <span class="stat-value" id="h-accuracy">0%</span></div>
                <div class="learning-indicator" id="h-learning"></div>
                <div class="brain-vis" id="h-brain"></div>
                <div class="weights-display" id="h-weights"></div>
            </div>
            
            <div id="log"></div>
        </div>
    </div>

<script>
// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game state
let paused = false;
let gameSpeed = 1;
let generation = 1;
let totalFights = 0;
let roundNumber = 1;
let roundWins = [0, 0, 0, 0, 0, 0, 0]; // Track wins per agent
let roundInProgress = true;
let roundEndTimer = 0;

// Neural Network base class with actual learning
class NeuralAgent {
    constructor(type, color, x, y) {
        this.type = type;
        this.color = color;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.health = 100;
        this.maxHealth = 100;
        this.radius = 20;
        this.angle = Math.random() * Math.PI * 2;
        this.kills = 0;
        this.deaths = 0;
        this.shotsFired = 0;
        this.shotsHit = 0;
        this.lastShot = 0;
        this.shootCooldown = 500;
        this.respawnTimer = 0;
        this.alive = true;
        
        // Neural network weights - these actually evolve!
        this.weights = {
            aggression: 0.5 + Math.random() * 0.3,
            evasion: 0.5 + Math.random() * 0.3,
            accuracy: 0.3 + Math.random() * 0.2,
            prediction: 0.2 + Math.random() * 0.2,
            teamwork: 0.1 + Math.random() * 0.1,
            memory: [],
            learningRate: 0.05 + Math.random() * 0.05,
            railgunPreference: 0.3 + Math.random() * 0.4 // Learned weapon preference
        };
        
        // Dual weapon system
        this.weapons = {
            bullet: {
                cooldown: 500,
                lastShot: 0,
                damage: 12 + Math.random() * 8,
                speed: 400,
                color: this.color,
                ready: true
            },
            railgun: {
                cooldown: 2000,
                lastShot: 0,
                damage: 35 + Math.random() * 15,
                speed: 800,
                color: '#ffffff',
                ready: true
            },
            laser: {
                cooldown: 800,
                lastShot: 0,
                damage: 8 + Math.random() * 4,
                range: 250,
                color: '#ff00ff',
                ready: true,
                duration: 150 // How long beam is visible
            }
        };
        this.railgunHits = 0;
        this.bulletHits = 0;
        this.laserHits = 0;
        this.activeLaser = null; // For drawing the beam
        
        // Architecture-specific properties
        this.initArchitecture();
        
        // Experience buffer for learning
        this.experienceBuffer = [];
        this.recentDamageFrom = {};
    }
    
    // Safe distance calculation to prevent NaN
    safeDist(dx, dy) {
        const dist = Math.sqrt(dx * dx + dy * dy);
        return dist < 0.001 ? 0.001 : dist; // Prevent division by zero
    }
    
    initArchitecture() {
        // Override in subclasses
    }
    
    think(enemies, bullets, dt) {
        // Override in subclasses - returns {moveX, moveY, shoot, targetAngle}
        return { moveX: 0, moveY: 0, shoot: false, targetAngle: this.angle };
    }
    
    learn(event, data) {
        // Base learning - override in subclasses for specialized learning
        const lr = this.weights.learningRate;
        
        if (event === 'hit_enemy') {
            this.weights.accuracy = Math.min(0.95, this.weights.accuracy + lr * 0.8);
            this.weights.aggression = Math.min(0.95, this.weights.aggression + lr * 0.3);
            this.weights.prediction = Math.min(0.9, this.weights.prediction + lr * 0.4);
            
            // Learn weapon preference based on what hit
            if (data.weaponType === 'railgun') {
                this.railgunHits++;
                this.weights.railgunPreference = Math.min(0.9, this.weights.railgunPreference + lr * 0.2);
            } else {
                this.bulletHits++;
                this.weights.railgunPreference = Math.max(0.1, this.weights.railgunPreference - lr * 0.1);
            }
        } else if (event === 'missed') {
            this.weights.accuracy = Math.max(0.1, this.weights.accuracy - lr * 0.15);
        } else if (event === 'took_damage') {
            this.weights.evasion = Math.min(0.95, this.weights.evasion + lr * 0.5);
            if (data.from) {
                this.recentDamageFrom[data.from] = (this.recentDamageFrom[data.from] || 0) + 1;
            }
        } else if (event === 'killed') {
            this.weights.aggression = Math.min(0.98, this.weights.aggression + lr * 1.5);
            this.weights.prediction = Math.min(0.9, this.weights.prediction + lr * 0.8);
            this.weights.accuracy = Math.min(0.95, this.weights.accuracy + lr * 0.5);
        } else if (event === 'died') {
            this.weights.evasion = Math.min(0.95, this.weights.evasion + lr * 0.8);
            this.weights.aggression = Math.max(0.15, this.weights.aggression - lr * 0.4);
        }
    }
    
    update(enemies, bullets, dt) {
        if (!this.alive) {
            this.respawnTimer -= dt;
            if (this.respawnTimer <= 0) {
                this.respawn();
            }
            return null;
        }
        
        // Update weapon cooldowns
        const now = Date.now();
        this.weapons.bullet.ready = (now - this.weapons.bullet.lastShot) > this.weapons.bullet.cooldown / gameSpeed;
        this.weapons.railgun.ready = (now - this.weapons.railgun.lastShot) > this.weapons.railgun.cooldown / gameSpeed;
        this.weapons.laser.ready = (now - this.weapons.laser.lastShot) > this.weapons.laser.cooldown / gameSpeed;
        
        // Clear old laser beam
        if (this.activeLaser && now - this.activeLaser.startTime > this.weapons.laser.duration) {
            this.activeLaser = null;
        }
        
        const decision = this.think(enemies, bullets, dt);
        
        // Apply movement
        const speed = 150 * gameSpeed;
        this.vx = decision.moveX * speed;
        this.vy = decision.moveY * speed;
        
        // NaN protection - reset to safe values if calculations went bad
        if (isNaN(this.vx) || !isFinite(this.vx)) this.vx = 0;
        if (isNaN(this.vy) || !isFinite(this.vy)) this.vy = 0;
        if (isNaN(this.x) || !isFinite(this.x)) this.x = canvas.width / 2;
        if (isNaN(this.y) || !isFinite(this.y)) this.y = canvas.height / 2;
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // Screen wrapping instead of clamping
        const margin = this.radius;
        if (this.x < -margin) this.x = canvas.width + margin;
        if (this.x > canvas.width + margin) this.x = -margin;
        if (this.y < -margin) this.y = canvas.height + margin;
        if (this.y > canvas.height + margin) this.y = -margin;
        
        // Smooth angle transition
        if (decision.targetAngle !== undefined) {
            let diff = decision.targetAngle - this.angle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            this.angle += diff * 0.15;
        }
        
        // Shooting - check for laser first (hitscan)
        if (decision.shootLaser && this.weapons.laser.ready) {
            this.weapons.laser.lastShot = now;
            this.shotsFired++;
            this.fireLaser(enemies);
            return null; // Laser doesn't create a bullet
        }
        
        // Then railgun
        if (decision.shootAlt && this.weapons.railgun.ready) {
            this.weapons.railgun.lastShot = now;
            this.shotsFired++;
            return this.createBullet('railgun');
        }
        
        // Regular bullet
        if (decision.shoot && this.weapons.bullet.ready) {
            this.weapons.bullet.lastShot = now;
            this.shotsFired++;
            return this.createBullet('bullet');
        }
        
        return null;
    }
    
    fireLaser(enemies) {
        // Hitscan - instant hit detection along beam
        const range = this.weapons.laser.range;
        const endX = this.x + Math.cos(this.angle) * range;
        const endY = this.y + Math.sin(this.angle) * range;
        
        // Store laser for drawing
        this.activeLaser = {
            startX: this.x + Math.cos(this.angle) * this.radius,
            startY: this.y + Math.sin(this.angle) * this.radius,
            endX: endX,
            endY: endY,
            startTime: Date.now(),
            hit: false
        };
        
        // Check for hits along the beam
        let closestHit = null;
        let closestDist = range;
        
        enemies.forEach(enemy => {
            if (enemy === this || !enemy.alive) return;
            
            // Line-circle intersection
            const dx = endX - this.x;
            const dy = endY - this.y;
            const fx = this.x - enemy.x;
            const fy = this.y - enemy.y;
            
            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - enemy.radius * enemy.radius;
            
            let discriminant = b * b - 4 * a * c;
            
            if (discriminant >= 0) {
                discriminant = Math.sqrt(discriminant);
                const t1 = (-b - discriminant) / (2 * a);
                const t2 = (-b + discriminant) / (2 * a);
                
                if (t1 >= 0 && t1 <= 1) {
                    const hitDist = t1 * Math.sqrt(a);
                    if (hitDist < closestDist) {
                        closestDist = hitDist;
                        closestHit = enemy;
                    }
                } else if (t2 >= 0 && t2 <= 1) {
                    const hitDist = t2 * Math.sqrt(a);
                    if (hitDist < closestDist) {
                        closestDist = hitDist;
                        closestHit = enemy;
                    }
                }
            }
        });
        
        if (closestHit) {
            // Update laser endpoint to hit location
            this.activeLaser.endX = this.x + Math.cos(this.angle) * closestDist;
            this.activeLaser.endY = this.y + Math.sin(this.angle) * closestDist;
            this.activeLaser.hit = true;
            
            closestHit.takeDamage(this.weapons.laser.damage, this);
            this.shotsHit++;
            this.laserHits++;
            this.learn('hit_enemy', { target: closestHit.type, damage: this.weapons.laser.damage, weaponType: 'laser' });
        } else {
            this.learn('missed', {});
        }
    }
    
    createBullet(weaponType = 'bullet') {
        const weapon = this.weapons[weaponType];
        const spread = weaponType === 'railgun' ? 
            (1 - this.weights.accuracy) * 0.1 : // Railgun more accurate
            (1 - this.weights.accuracy) * 0.3;
        const angle = this.angle + (Math.random() - 0.5) * spread;
        
        return {
            x: this.x + Math.cos(this.angle) * this.radius,
            y: this.y + Math.sin(this.angle) * this.radius,
            vx: Math.cos(angle) * weapon.speed * gameSpeed,
            vy: Math.sin(angle) * weapon.speed * gameSpeed,
            owner: this,
            damage: weapon.damage,
            color: weaponType === 'railgun' ? '#fff' : this.color,
            type: weaponType,
            size: weaponType === 'railgun' ? 6 : 4,
            trail: weaponType === 'railgun' ? 0.08 : 0.03
        };
    }
    
    takeDamage(amount, from) {
        this.health -= amount;
        this.learn('took_damage', { amount, from: from?.type });
        
        if (this.health <= 0) {
            this.die(from);
        }
    }
    
    die(killer) {
        this.alive = false;
        this.deaths++;
        this.respawnTimer = 3000 / gameSpeed;
        this.learn('died', { killer: killer?.type });
        
        if (killer) {
            killer.kills++;
            killer.learn('killed', { victim: this.type });
        }
        
        addLog(`${killer?.type || 'Unknown'} killed ${this.type}!`, 'kill');
    }
    
    respawn() {
        this.alive = true;
        this.health = this.maxHealth;
        this.x = Math.random() * (canvas.width - 100) + 50;
        this.y = Math.random() * (canvas.height - 100) + 50;
        this.recentDamageFrom = {};
        addLog(`${this.type} respawned`, 'respawn');
    }
    
    draw() {
        if (!this.alive) return;
        
        // Draw active laser beam first (so it's behind the agent)
        if (this.activeLaser) {
            const laserAge = Date.now() - this.activeLaser.startTime;
            const alpha = 1 - (laserAge / this.weapons.laser.duration);
            
            // Outer glow
            ctx.strokeStyle = `rgba(255, 0, 255, ${alpha * 0.3})`;
            ctx.lineWidth = 12;
            ctx.beginPath();
            ctx.moveTo(this.activeLaser.startX, this.activeLaser.startY);
            ctx.lineTo(this.activeLaser.endX, this.activeLaser.endY);
            ctx.stroke();
            
            // Core beam
            ctx.strokeStyle = `rgba(255, 100, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(this.activeLaser.startX, this.activeLaser.startY);
            ctx.lineTo(this.activeLaser.endX, this.activeLaser.endY);
            ctx.stroke();
            
            // Bright center
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.activeLaser.startX, this.activeLaser.startY);
            ctx.lineTo(this.activeLaser.endX, this.activeLaser.endY);
            ctx.stroke();
            
            // Hit flash
            if (this.activeLaser.hit) {
                const flashRadius = Math.max(1, 15 * alpha);
                ctx.fillStyle = `rgba(255, 200, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.activeLaser.endX, this.activeLaser.endY, flashRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Glow effect
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, Math.max(1, this.radius * 2));
        gradient.addColorStop(0, this.color + '40');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, Math.max(1, this.radius * 2), 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.radius, 0);
        ctx.lineTo(-this.radius * 0.7, -this.radius * 0.6);
        ctx.lineTo(-this.radius * 0.4, 0);
        ctx.lineTo(-this.radius * 0.7, this.radius * 0.6);
        ctx.closePath();
        ctx.fill();
        
        // Core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-this.radius * 0.2, 0, Math.max(1, this.radius * 0.25), 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        // Health bar
        const barWidth = 40;
        const barHeight = 4;
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 12, barWidth, barHeight);
        ctx.fillStyle = this.color;
        const healthWidth = Math.max(0, barWidth * (this.health / this.maxHealth));
        ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 12, healthWidth, barHeight);
        
        // Railgun cooldown indicator
        if (this.weapons.railgun.ready) {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x + barWidth/2 + 6, this.y - this.radius - 10, 3, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.strokeStyle = '#555';
            ctx.beginPath();
            ctx.arc(this.x + barWidth/2 + 6, this.y - this.radius - 10, 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Laser cooldown indicator
        if (this.weapons.laser.ready) {
            ctx.fillStyle = '#ff00ff';
            ctx.beginPath();
            ctx.arc(this.x + barWidth/2 + 14, this.y - this.radius - 10, 3, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.strokeStyle = '#552255';
            ctx.beginPath();
            ctx.arc(this.x + barWidth/2 + 14, this.y - this.radius - 10, 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Type label
        ctx.fillStyle = '#fff';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.type.substring(0, 4), this.x, this.y - this.radius - 16);
    }
    
    getAccuracy() {
        return this.shotsFired > 0 ? Math.round((this.shotsHit / this.shotsFired) * 100) : 0;
    }
}

// TRANSFORMER - Uses attention mechanism to focus on threats
class TransformerAgent extends NeuralAgent {
    constructor(x, y) {
        super('TRANSFORMER', '#ff6b6b', x, y);
    }
    
    initArchitecture() {
        this.attentionHeads = 8;
        this.attentionWeights = new Array(4).fill(0).map(() => Math.random());
        this.positionEncoding = [];
    }
    
    think(enemies, bullets, dt) {
        // Multi-head attention: compute attention scores for each enemy
        let attention = enemies.filter(e => e.alive && e !== this).map(enemy => {
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const dist = this.safeDist(dx, dy);
            const angle = Math.atan2(dy, dx);
            
            // Attention score based on: distance, health, threat level
            const distScore = 1 / (dist + 50);
            const healthScore = (100 - enemy.health) / 100;
            const threatScore = this.recentDamageFrom[enemy.type] || 0;
            
            const score = distScore * this.attentionWeights[0] + 
                         healthScore * this.attentionWeights[1] + 
                         threatScore * this.attentionWeights[2] * 0.1;
            
            return { enemy, score, dist, angle, dx, dy };
        });
        
        // Softmax attention
        const totalScore = attention.reduce((s, a) => s + Math.exp(a.score * 5), 0) || 1;
        attention = attention.map(a => ({ ...a, prob: Math.exp(a.score * 5) / totalScore }));
        
        // Focus on highest attention target
        attention.sort((a, b) => b.prob - a.prob);
        const target = attention[0];
        
        let moveX = 0, moveY = 0, shoot = false, shootAlt = false, shootLaser = false, targetAngle = this.angle;
        
        if (target) {
            targetAngle = target.angle;
            
            // Predict target movement
            const predX = target.enemy.x + (target.enemy.vx || 0) * this.weights.prediction * 0.5;
            const predY = target.enemy.y + (target.enemy.vy || 0) * this.weights.prediction * 0.5;
            targetAngle = Math.atan2(predY - this.y, predX - this.x);
            
            // Movement: approach or evade based on weights
            if (target.dist > 200) {
                moveX = Math.cos(target.angle) * this.weights.aggression;
                moveY = Math.sin(target.angle) * this.weights.aggression;
            } else if (target.dist < 100) {
                moveX = -Math.cos(target.angle) * this.weights.evasion;
                moveY = -Math.sin(target.angle) * this.weights.evasion;
            }
            
            // Shoot if aligned
            const angleDiff = Math.abs(targetAngle - this.angle);
            if (angleDiff < 0.3 && target.dist < 400) {
                // Transformer uses attention to decide weapon
                // Laser for close range (guaranteed hit)
                if (target.dist < 200 && this.weapons.laser.ready) {
                    shootLaser = Math.random() < 0.6;
                }
                // Railgun for distant/high-health targets
                else if (target.dist > 250 && target.enemy.health > 40 && this.weapons.railgun.ready) {
                    shootAlt = Math.random() < this.weights.railgunPreference;
                }
                shoot = Math.random() < this.weights.aggression && !shootAlt && !shootLaser;
            }
        }
        
        // Evade bullets
        bullets.forEach(b => {
            if (b.owner === this) return;
            const dx = b.x - this.x;
            const dy = b.y - this.y;
            const dist = this.safeDist(dx, dy);
            if (dist < 80) {
                moveX -= (dx / dist) * this.weights.evasion * 0.5;
                moveY -= (dy / dist) * this.weights.evasion * 0.5;
            }
        });
        
        // Normalize movement
        const mag = Math.sqrt(moveX * moveX + moveY * moveY);
        if (mag > 1) { moveX /= mag; moveY /= mag; }
        
        return { moveX, moveY, shoot, shootAlt, shootLaser, targetAngle };
    }
    
    learn(event, data) {
        super.learn(event, data);
        
        // Transformer-specific: adjust attention weights
        if (event === 'hit_enemy') {
            this.attentionWeights[0] *= 1.05; // Distance attention worked
        } else if (event === 'took_damage') {
            this.attentionWeights[2] *= 1.1; // Increase threat attention
        } else if (event === 'killed') {
            this.attentionWeights[1] *= 1.05; // Health targeting worked
        }
        
        // Normalize
        const sum = this.attentionWeights.reduce((a, b) => a + b, 0);
        this.attentionWeights = this.attentionWeights.map(w => w / sum);
    }
}

// MAMBA - State Space Model with efficient sequential processing
class MambaAgent extends NeuralAgent {
    constructor(x, y) {
        super('MAMBA', '#4ecdc4', x, y);
    }
    
    initArchitecture() {
        this.stateDim = 16;
        this.hiddenState = new Array(this.stateDim).fill(0);
        this.A = new Array(this.stateDim).fill(0).map(() => 0.9 + Math.random() * 0.1);
        this.B = new Array(this.stateDim).fill(0).map(() => Math.random() * 0.5);
        this.C = new Array(4).fill(0).map(() => Math.random()); // Output: moveX, moveY, shoot, targetAngle
        this.selectivity = 0.5;
    }
    
    think(enemies, bullets, dt) {
        // Encode current observation
        const aliveEnemies = enemies.filter(e => e.alive && e !== this);
        
        // Create input based on environment
        let input = new Array(this.stateDim).fill(0);
        
        aliveEnemies.forEach((enemy, i) => {
            if (i < 4) {
                const dx = (enemy.x - this.x) / canvas.width;
                const dy = (enemy.y - this.y) / canvas.height;
                const dist = Math.sqrt(dx * dx + dy * dy);
                input[i * 4] = dx;
                input[i * 4 + 1] = dy;
                input[i * 4 + 2] = enemy.health / 100;
                input[i * 4 + 3] = dist;
            }
        });
        
        // SSM update: h_t = A * h_{t-1} + B * x_t (selective)
        const selectivityGate = Math.tanh(this.selectivity * input.reduce((a, b) => a + b, 0));
        
        for (let i = 0; i < this.stateDim; i++) {
            this.hiddenState[i] = this.A[i] * this.hiddenState[i] * selectivityGate + 
                                  this.B[i] * input[i];
            this.hiddenState[i] = Math.tanh(this.hiddenState[i]);
        }
        
        // Output from hidden state
        let output = [0, 0, 0, 0];
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < this.stateDim; j++) {
                output[i] += this.hiddenState[j] * this.C[i] * (j === i % this.stateDim ? 1 : 0.1);
            }
            output[i] = Math.tanh(output[i]);
        }
        
        // Find target
        let targetAngle = this.angle;
        let targetDist = 999;
        const target = aliveEnemies.sort((a, b) => {
            const da = this.safeDist(a.x - this.x, a.y - this.y);
            const db = this.safeDist(b.x - this.x, b.y - this.y);
            return da - db;
        })[0];
        
        if (target) {
            targetAngle = Math.atan2(target.y - this.y, target.x - this.x);
            targetDist = this.safeDist(target.x - this.x, target.y - this.y);
        }
        
        // Bullet evasion with state memory
        bullets.forEach(b => {
            if (b.owner === this) return;
            const dx = b.x - this.x;
            const dy = b.y - this.y;
            const dist = this.safeDist(dx, dy);
            if (dist < 100) {
                output[0] -= (dx / dist) * this.weights.evasion;
                output[1] -= (dy / dist) * this.weights.evasion;
            }
        });
        
        // Mamba uses state to decide weapon - prefers railgun when state is "charged"
        const stateEnergy = this.hiddenState.reduce((a, b) => a + Math.abs(b), 0) / this.stateDim;
        const useRailgun = targetDist > 200 && stateEnergy > 0.3 && this.weapons.railgun.ready;
        const useLaser = targetDist < 180 && targetDist > 50 && this.weapons.laser.ready && stateEnergy > 0.2;
        
        // Clamp outputs to prevent NaN propagation
        output[0] = Math.max(-1, Math.min(1, output[0] || 0));
        output[1] = Math.max(-1, Math.min(1, output[1] || 0));
        output[2] = Math.max(-1, Math.min(1, output[2] || 0));
        
        return {
            moveX: output[0] * this.weights.aggression,
            moveY: output[1] * this.weights.aggression,
            shoot: output[2] > 0.3 && target && !useRailgun && !useLaser,
            shootAlt: useRailgun && output[2] > 0.2,
            shootLaser: useLaser && output[2] > 0.2,
            targetAngle
        };
    }
    
    learn(event, data) {
        super.learn(event, data);
        
        // Mamba-specific: adjust state matrices
        if (event === 'hit_enemy') {
            this.selectivity = Math.min(1, this.selectivity + 0.02);
            // Reinforce output weights
            this.C = this.C.map(c => c * 1.02);
        } else if (event === 'died') {
            // Make state more responsive
            this.A = this.A.map(a => a * 0.98);
            this.B = this.B.map(b => Math.min(1, b * 1.05));
        }
    }
}

// MIXTURE OF EXPERTS - Specialized sub-networks for different situations
class MoEAgent extends NeuralAgent {
    constructor(x, y) {
        super('MOE', '#ffe66d', x, y);
    }
    
    initArchitecture() {
        this.numExperts = 8;
        this.activeExperts = 2;
        this.experts = [];
        
        // Each expert specializes in different behavior
        const specializations = ['aggressive', 'defensive', 'sniper', 'flanker', 
                                 'hunter', 'survivor', 'berserker', 'tactician'];
        
        for (let i = 0; i < this.numExperts; i++) {
            this.experts.push({
                name: specializations[i],
                weights: {
                    aggression: Math.random(),
                    evasion: Math.random(),
                    range: Math.random(),
                    accuracy: Math.random()
                },
                score: 0,
                uses: 0
            });
        }
        
        // Gating network weights
        this.gatingWeights = new Array(this.numExperts).fill(0).map(() => Math.random());
    }
    
    think(enemies, bullets, dt) {
        const aliveEnemies = enemies.filter(e => e.alive && e !== this);
        
        // Compute situation features for gating
        const avgDist = aliveEnemies.length > 0 ? aliveEnemies.reduce((sum, e) => {
            return sum + this.safeDist(e.x - this.x, e.y - this.y);
        }, 0) / aliveEnemies.length : 500;
        
        const threatLevel = bullets.filter(b => {
            if (b.owner === this) return false;
            const dist = this.safeDist(b.x - this.x, b.y - this.y);
            return dist < 150;
        }).length;
        
        const healthRatio = this.health / this.maxHealth;
        
        // Compute gating scores
        const situationVector = [avgDist / 500, threatLevel / 5, healthRatio, this.kills / 10];
        
        let expertScores = this.experts.map((expert, i) => {
            let score = this.gatingWeights[i];
            
            // Situation-based scoring
            if (expert.name === 'aggressive' && healthRatio > 0.5) score *= 1.5;
            if (expert.name === 'defensive' && healthRatio < 0.5) score *= 2;
            if (expert.name === 'sniper' && avgDist > 300) score *= 1.5;
            if (expert.name === 'flanker' && avgDist < 200) score *= 1.3;
            if (expert.name === 'survivor' && threatLevel > 2) score *= 2;
            if (expert.name === 'berserker' && this.kills > 3) score *= 1.5;
            
            return { expert, score, index: i };
        });
        
        // Select top-k experts
        expertScores.sort((a, b) => b.score - a.score);
        const selectedExperts = expertScores.slice(0, this.activeExperts);
        
        // Combine expert outputs
        let moveX = 0, moveY = 0, shootProb = 0;
        let totalWeight = selectedExperts.reduce((s, e) => s + e.score, 0);
        
        selectedExperts.forEach(({ expert, score }) => {
            const weight = score / totalWeight;
            expert.uses++;
            
            // Expert-specific behavior
            if (expert.name === 'aggressive') {
                if (aliveEnemies[0]) {
                    const dx = aliveEnemies[0].x - this.x;
                    const dy = aliveEnemies[0].y - this.y;
                    const dist = this.safeDist(dx, dy);
                    moveX += (dx / dist) * weight * expert.weights.aggression;
                    moveY += (dy / dist) * weight * expert.weights.aggression;
                    shootProb += weight * 0.8;
                }
            } else if (expert.name === 'defensive') {
                bullets.forEach(b => {
                    if (b.owner === this) return;
                    const dx = b.x - this.x;
                    const dy = b.y - this.y;
                    const dist = this.safeDist(dx, dy);
                    if (dist < 150) {
                        moveX -= (dx / dist) * weight * expert.weights.evasion;
                        moveY -= (dy / dist) * weight * expert.weights.evasion;
                    }
                });
                shootProb += weight * 0.3;
            } else if (expert.name === 'sniper') {
                // Stay at range and shoot accurately
                if (aliveEnemies[0]) {
                    const dx = aliveEnemies[0].x - this.x;
                    const dy = aliveEnemies[0].y - this.y;
                    const dist = this.safeDist(dx, dy);
                    if (dist < 300) {
                        moveX -= (dx / dist) * weight * 0.5;
                        moveY -= (dy / dist) * weight * 0.5;
                    }
                    shootProb += weight * 0.9;
                }
            } else if (expert.name === 'flanker') {
                // Circle around target
                if (aliveEnemies[0]) {
                    const dx = aliveEnemies[0].x - this.x;
                    const dy = aliveEnemies[0].y - this.y;
                    const dist = this.safeDist(dx, dy);
                    moveX += (-dy / dist) * weight * 0.5;
                    moveY += (dx / dist) * weight * 0.5;
                    shootProb += weight * 0.5;
                }
            } else {
                // Generic behavior for other experts
                if (aliveEnemies[0]) {
                    const dx = aliveEnemies[0].x - this.x;
                    const dy = aliveEnemies[0].y - this.y;
                    const dist = this.safeDist(dx, dy);
                    moveX += (dx / dist) * weight * expert.weights.aggression * 0.5;
                    moveY += (dy / dist) * weight * expert.weights.aggression * 0.5;
                    shootProb += weight * 0.5;
                }
            }
        });
        
        // Store active experts for display
        this.currentExperts = selectedExperts.map(e => e.expert.name).join(', ');
        
        let targetAngle = this.angle;
        let targetDist = 999;
        if (aliveEnemies[0]) {
            targetAngle = Math.atan2(aliveEnemies[0].y - this.y, aliveEnemies[0].x - this.x);
            targetDist = this.safeDist(aliveEnemies[0].x - this.x, aliveEnemies[0].y - this.y);
        }
        
        const mag = Math.sqrt(moveX * moveX + moveY * moveY);
        if (mag > 1) { moveX /= mag; moveY /= mag; }
        
        // Clamp to prevent NaN
        moveX = Math.max(-1, Math.min(1, moveX || 0));
        moveY = Math.max(-1, Math.min(1, moveY || 0));
        
        // MoE: sniper expert prefers railgun, aggressive prefers laser at close range
        const sniperActive = selectedExperts.some(e => e.expert.name === 'sniper');
        const aggressiveActive = selectedExperts.some(e => e.expert.name === 'aggressive');
        const useRailgun = sniperActive && targetDist > 200 && this.weapons.railgun.ready;
        const useLaser = aggressiveActive && targetDist < 200 && this.weapons.laser.ready;
        
        return {
            moveX,
            moveY,
            shoot: Math.random() < shootProb && !useRailgun && !useLaser,
            shootAlt: useRailgun && shootProb > 0.3,
            shootLaser: useLaser && shootProb > 0.4,
            targetAngle
        };
    }
    
    learn(event, data) {
        super.learn(event, data);
        
        // MoE-specific: adjust expert and gating weights
        if (event === 'hit_enemy' || event === 'killed') {
            // Reinforce recently used experts
            this.experts.forEach((expert, i) => {
                if (expert.uses > 0) {
                    this.gatingWeights[i] *= 1.05;
                    expert.score += 0.1;
                }
            });
        } else if (event === 'died') {
            // Reduce weight of recently used experts
            this.experts.forEach((expert, i) => {
                if (expert.uses > 0) {
                    this.gatingWeights[i] *= 0.95;
                }
            });
        }
        
        // Reset usage counts
        this.experts.forEach(e => e.uses = 0);
        
        // Normalize gating weights
        const sum = this.gatingWeights.reduce((a, b) => a + b, 0);
        this.gatingWeights = this.gatingWeights.map(w => w / sum);
    }
}

// NEURAL TURING MACHINE - External memory for strategic planning
class NTMAgent extends NeuralAgent {
    constructor(x, y) {
        super('NTM', '#a855f7', x, y);
    }
    
    initArchitecture() {
        this.memorySlots = 32;
        this.memoryDim = 8;
        this.memory = [];
        for (let i = 0; i < this.memorySlots; i++) {
            this.memory.push(new Array(this.memoryDim).fill(0));
        }
        
        this.readHead = 0;
        this.writeHead = 0;
        this.readWeights = new Array(this.memorySlots).fill(1 / this.memorySlots);
        this.writeWeights = new Array(this.memorySlots).fill(1 / this.memorySlots);
        
        // Controller state
        this.controller = {
            hidden: new Array(16).fill(0),
            Wk: new Array(this.memoryDim).fill(0).map(() => Math.random() - 0.5), // Key
            Wv: new Array(this.memoryDim).fill(0).map(() => Math.random() - 0.5), // Value
        };
    }
    
    contentAddressing(key) {
        // Compute attention over memory using key
        let scores = this.memory.map(slot => {
            let dot = 0;
            for (let i = 0; i < this.memoryDim; i++) {
                dot += key[i] * slot[i];
            }
            return Math.exp(dot);
        });
        
        const sum = scores.reduce((a, b) => a + b, 0) || 1;
        return scores.map(s => s / sum);
    }
    
    think(enemies, bullets, dt) {
        const aliveEnemies = enemies.filter(e => e.alive && e !== this);
        
        // Encode current state
        let currentState = new Array(this.memoryDim).fill(0);
        
        aliveEnemies.forEach((enemy, i) => {
            if (i < 2) {
                const dx = (enemy.x - this.x) / canvas.width;
                const dy = (enemy.y - this.y) / canvas.height;
                currentState[i * 4] = dx;
                currentState[i * 4 + 1] = dy;
                currentState[i * 4 + 2] = enemy.health / 100;
                currentState[i * 4 + 3] = enemy.vx / 200;
            }
        });
        
        // Read from memory (content-based addressing)
        const readKey = currentState.map((s, i) => s * this.controller.Wk[i]);
        this.readWeights = this.contentAddressing(readKey);
        
        let readVector = new Array(this.memoryDim).fill(0);
        for (let i = 0; i < this.memorySlots; i++) {
            for (let j = 0; j < this.memoryDim; j++) {
                readVector[j] += this.readWeights[i] * this.memory[i][j];
            }
        }
        
        // Write to memory (store current state with learned value)
        const writeValue = currentState.map((s, i) => 
            s * 0.5 + readVector[i] * 0.3 + this.controller.Wv[i] * 0.2
        );
        
        // Interpolate with existing memory at write head
        const writeIndex = Math.floor(this.writeHead) % this.memorySlots;
        for (let i = 0; i < this.memoryDim; i++) {
            this.memory[writeIndex][i] = 
                this.memory[writeIndex][i] * 0.7 + writeValue[i] * 0.3;
        }
        this.writeHead = (this.writeHead + 0.1) % this.memorySlots;
        
        // Decision making from controller + memory
        let moveX = 0, moveY = 0, shoot = false, shootAlt = false, shootLaser = false;
        let targetAngle = this.angle;
        
        // Use memory-augmented decision
        const memoryBias = readVector.reduce((a, b) => a + b, 0) / this.memoryDim;
        const aggressionMod = Math.tanh(memoryBias) * 0.5 + 0.5;
        
        // Find best target using memory of past encounters
        let bestTarget = null;
        let bestScore = -Infinity;
        
        aliveEnemies.forEach(enemy => {
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const dist = this.safeDist(dx, dy);
            
            // Score based on distance, health, and memory
            let score = (1000 - dist) / 1000;
            score += (100 - enemy.health) / 200;
            
            // Check if we remember this type being dangerous
            const dangerMemory = this.recentDamageFrom[enemy.type] || 0;
            score += dangerMemory * 0.1;
            
            if (score > bestScore) {
                bestScore = score;
                bestTarget = { enemy, dx, dy, dist };
            }
        });
        
        if (bestTarget) {
            targetAngle = Math.atan2(bestTarget.dy, bestTarget.dx);
            
            // Movement strategy based on memory-modulated aggression
            const effectiveAggression = this.weights.aggression * aggressionMod;
            
            if (bestTarget.dist > 250) {
                moveX = Math.cos(targetAngle) * effectiveAggression;
                moveY = Math.sin(targetAngle) * effectiveAggression;
            } else if (bestTarget.dist < 120) {
                moveX = -Math.cos(targetAngle) * this.weights.evasion;
                moveY = -Math.sin(targetAngle) * this.weights.evasion;
            } else {
                // Strafe
                moveX = -Math.sin(targetAngle) * 0.5;
                moveY = Math.cos(targetAngle) * 0.5;
            }
            
            // Predict and shoot
            const predX = bestTarget.enemy.x + bestTarget.enemy.vx * this.weights.prediction;
            const predY = bestTarget.enemy.y + bestTarget.enemy.vy * this.weights.prediction;
            targetAngle = Math.atan2(predY - this.y, predX - this.x);
            
            const angleDiff = Math.abs(targetAngle - this.angle);
            if (angleDiff < 0.4 && bestTarget.dist < 350) {
                // NTM uses memory to decide weapon - checks if railgun worked before
                const railgunMemory = this.memory[0].reduce((a, b) => a + b, 0);
                if (bestTarget.dist > 220 && railgunMemory > 0.5 && this.weapons.railgun.ready) {
                    shootAlt = Math.random() < this.weights.railgunPreference;
                }
                // Laser for close range - NTM remembers it's reliable
                if (bestTarget.dist < 200 && this.weapons.laser.ready && !shootAlt) {
                    shootLaser = Math.random() < 0.5;
                }
                shoot = Math.random() < effectiveAggression * 0.8 && !shootAlt && !shootLaser;
            }
        }
        
        // Bullet evasion
        bullets.forEach(b => {
            if (b.owner === this) return;
            const dx = b.x - this.x;
            const dy = b.y - this.y;
            const dist = this.safeDist(dx, dy);
            if (dist < 100) {
                moveX -= (dx / dist) * this.weights.evasion * 0.7;
                moveY -= (dy / dist) * this.weights.evasion * 0.7;
            }
        });
        
        const mag = Math.sqrt(moveX * moveX + moveY * moveY);
        if (mag > 1) { moveX /= mag; moveY /= mag; }
        
        // Clamp to prevent NaN
        moveX = Math.max(-1, Math.min(1, moveX || 0));
        moveY = Math.max(-1, Math.min(1, moveY || 0));
        
        return { moveX, moveY, shoot, shootAlt, shootLaser, targetAngle };
    }
    
    learn(event, data) {
        super.learn(event, data);
        
        // NTM-specific: adjust controller weights and memory
        if (event === 'hit_enemy' || event === 'killed') {
            // Strengthen current memory pattern
            const idx = Math.floor(this.writeHead) % this.memorySlots;
            for (let i = 0; i < this.memoryDim; i++) {
                this.memory[idx][i] *= 1.1;
                this.controller.Wv[i] += 0.01;
            }
        } else if (event === 'died') {
            // Weaken recent memory patterns (they led to death)
            for (let i = 0; i < 3; i++) {
                const idx = (Math.floor(this.writeHead) - i + this.memorySlots) % this.memorySlots;
                for (let j = 0; j < this.memoryDim; j++) {
                    this.memory[idx][j] *= 0.8;
                }
            }
        }
    }
}

// RWKV - Linear attention RNN with time-mixing and channel-mixing
class RWKVAgent extends NeuralAgent {
    constructor(x, y) {
        super('RWKV', '#22c55e', x, y);
    }
    
    initArchitecture() {
        this.channels = 16;
        
        // Time-mixing state (replaces attention)
        this.timeMixState = new Array(this.channels).fill(0);
        this.timeDecay = new Array(this.channels).fill(0).map(() => 0.9 + Math.random() * 0.09);
        this.timeFirst = new Array(this.channels).fill(0).map(() => Math.random() * 0.5);
        
        // Channel-mixing state (replaces FFN)
        this.channelMixState = new Array(this.channels).fill(0);
        this.channelWeights = new Array(this.channels).fill(0).map(() => Math.random() - 0.5);
        
        // Receptance, Key, Value weights (the RKV in RWKV)
        this.Wr = new Array(this.channels).fill(0).map(() => Math.random());
        this.Wk = new Array(this.channels).fill(0).map(() => Math.random());
        this.Wv = new Array(this.channels).fill(0).map(() => Math.random());
        
        // Output projection
        this.Wo = [Math.random() + 0.5, Math.random() + 0.5, Math.random() + 0.5, Math.random() + 0.5];
        
        // Token shift mixing ratios (learnable)
        this.mixR = 0.5;
        this.mixK = 0.5;
        this.mixV = 0.5;
        
        // Shooting aggression
        this.shootBias = 0.3;
    }
    
    think(enemies, bullets, dt) {
        const aliveEnemies = enemies.filter(e => e.alive && e !== this);
        
        // Encode current observation into channels
        let currentInput = new Array(this.channels).fill(0);
        
        // Encode enemies
        aliveEnemies.forEach((enemy, i) => {
            if (i < 3) {
                const dx = (enemy.x - this.x) / canvas.width;
                const dy = (enemy.y - this.y) / canvas.height;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) / Math.PI;
                currentInput[i * 4] = dx;
                currentInput[i * 4 + 1] = dy;
                currentInput[i * 4 + 2] = dist;
                currentInput[i * 4 + 3] = enemy.health / 100;
            }
        });
        
        // Encode nearby bullets as threat
        let bulletThreat = 0;
        let bulletEvadeX = 0, bulletEvadeY = 0;
        bullets.forEach(b => {
            if (b.owner === this) return;
            const dx = b.x - this.x;
            const dy = b.y - this.y;
            const dist = this.safeDist(dx, dy);
            if (dist < 120) {
                bulletThreat += (120 - dist) / 120;
                bulletEvadeX -= dx / dist;
                bulletEvadeY -= dy / dist;
            }
        });
        currentInput[12] = Math.min(1, bulletThreat);
        currentInput[13] = bulletEvadeX / (Math.abs(bulletEvadeX) + 1);
        currentInput[14] = bulletEvadeY / (Math.abs(bulletEvadeY) + 1);
        currentInput[15] = this.health / 100;
        
        // TIME-MIXING (replaces self-attention with O(1) complexity per token)
        // This is the key innovation of RWKV
        let r = new Array(this.channels).fill(0);
        let k = new Array(this.channels).fill(0);
        let v = new Array(this.channels).fill(0);
        
        for (let i = 0; i < this.channels; i++) {
            // Token shift: mix current input with previous state
            const shifted = this.mixR * currentInput[i] + (1 - this.mixR) * this.timeMixState[i];
            
            r[i] = this.sigmoid(shifted * this.Wr[i]); // Receptance (gate)
            k[i] = shifted * this.Wk[i]; // Key
            v[i] = shifted * this.Wv[i]; // Value
        }
        
        // WKV computation (linear attention with decay)
        let wkv = new Array(this.channels).fill(0);
        for (let i = 0; i < this.channels; i++) {
            // Exponential decay creates "forgetting" of old information
            const decay = this.timeDecay[i];
            const bonus = this.timeFirst[i] * k[i]; // Bonus for current token
            
            wkv[i] = (this.timeMixState[i] * decay + Math.exp(bonus) * v[i]) / 
                     (decay + Math.exp(bonus) + 0.001);
            
            // Update state for next timestep
            this.timeMixState[i] = this.timeMixState[i] * decay + k[i] * v[i];
        }
        
        // Apply receptance gate
        let timeOut = new Array(this.channels).fill(0);
        for (let i = 0; i < this.channels; i++) {
            timeOut[i] = r[i] * wkv[i];
        }
        
        // CHANNEL-MIXING (replaces FFN)
        let channelOut = new Array(this.channels).fill(0);
        for (let i = 0; i < this.channels; i++) {
            const mixed = this.mixK * timeOut[i] + (1 - this.mixK) * this.channelMixState[i];
            channelOut[i] = Math.tanh(mixed * this.channelWeights[i] * 2); // Amplify
            this.channelMixState[i] = timeOut[i];
        }
        
        // Output projection to actions - stronger projection
        let output = [0, 0, 0, 0]; // moveX, moveY, shoot, aim
        for (let i = 0; i < this.channels; i++) {
            output[i % 4] += channelOut[i] * this.Wo[i % 4] * 0.5;
        }
        output = output.map(o => Math.tanh(o));
        
        // Determine target
        let targetAngle = this.angle;
        let targetDist = 999;
        if (aliveEnemies.length > 0) {
            // Find closest/weakest enemy
            const target = aliveEnemies.sort((a, b) => {
                const da = this.safeDist(a.x - this.x, a.y - this.y);
                const db = this.safeDist(b.x - this.x, b.y - this.y);
                return (da + a.health) - (db + b.health);
            })[0];
            
            // Predict position
            const predX = target.x + (target.vx || 0) * this.weights.prediction * 0.3;
            const predY = target.y + (target.vy || 0) * this.weights.prediction * 0.3;
            targetAngle = Math.atan2(predY - this.y, predX - this.x);
            targetDist = this.safeDist(target.x - this.x, target.y - this.y);
        }
        
        // Combine network output with bullet evasion
        let moveX = output[0] * this.weights.aggression + bulletEvadeX * this.weights.evasion * 0.5;
        let moveY = output[1] * this.weights.aggression + bulletEvadeY * this.weights.evasion * 0.5;
        
        const mag = Math.sqrt(moveX * moveX + moveY * moveY);
        if (mag > 1) { moveX /= mag; moveY /= mag; }
        
        // Clamp to prevent NaN
        moveX = Math.max(-1, Math.min(1, moveX || 0));
        moveY = Math.max(-1, Math.min(1, moveY || 0));
        
        // Weapon selection: railgun at distance, laser close, bullets mid-range
        const useRailgun = targetDist > 250 && this.weapons.railgun.ready && Math.random() < this.weights.railgunPreference;
        const useLaser = targetDist < 200 && targetDist > 50 && this.weapons.laser.ready && !useRailgun;
        
        // More aggressive shooting - combine network output with direct targeting
        const hasTarget = aliveEnemies.length > 0;
        const shootDecision = (output[2] + this.shootBias) > 0.2 || (hasTarget && Math.random() < this.weights.aggression * 0.5);
        
        return {
            moveX,
            moveY,
            shoot: shootDecision && hasTarget && !useRailgun && !useLaser,
            shootAlt: useRailgun && hasTarget && shootDecision,
            shootLaser: useLaser && hasTarget && shootDecision,
            targetAngle
        };
    }
    
    sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }
    
    learn(event, data) {
        super.learn(event, data);
        
        const lr = this.weights.learningRate * 1.5; // RWKV learns faster
        
        if (event === 'hit_enemy') {
            // Reinforce current mixing ratios and weights
            this.mixR = Math.min(0.9, this.mixR + lr * 0.1);
            this.mixK = Math.min(0.9, this.mixK + lr * 0.1);
            this.shootBias = Math.min(0.6, this.shootBias + lr * 0.1);
            
            // Strengthen output weights
            this.Wo = this.Wo.map(w => w * (1 + lr * 0.2));
            
            // Reduce time decay (remember more)
            this.timeDecay = this.timeDecay.map(d => Math.max(0.8, d - lr * 0.05));
        } else if (event === 'killed') {
            // Big reinforcement
            this.Wr = this.Wr.map(w => w * (1 + lr * 0.3));
            this.Wv = this.Wv.map(w => w * (1 + lr * 0.3));
            this.timeFirst = this.timeFirst.map(t => Math.min(1, t + lr * 0.2));
            this.shootBias = Math.min(0.7, this.shootBias + lr * 0.15);
        } else if (event === 'took_damage') {
            // Increase responsiveness
            this.timeDecay = this.timeDecay.map(d => Math.min(0.99, d + lr * 0.02));
            this.channelWeights = this.channelWeights.map(w => w * (1 + lr * 0.1));
        } else if (event === 'died') {
            // Adjust channel mixing
            this.mixV = Math.max(0.2, this.mixV - lr * 0.1);
            this.channelWeights = this.channelWeights.map(w => w * (1 - lr * 0.1));
            this.shootBias = Math.max(0.1, this.shootBias - lr * 0.05);
        }
    }
}

// xLSTM - Extended LSTM with exponential gating and matrix memory (2024)
class xLSTMAgent extends NeuralAgent {
    constructor(x, y) {
        super('xLSTM', '#f97316', x, y);
    }
    
    initArchitecture() {
        this.hiddenSize = 16;
        
        // sLSTM component (scalar LSTM with exponential gating)
        this.sCell = new Array(this.hiddenSize).fill(0);      // Cell state
        this.sHidden = new Array(this.hiddenSize).fill(0);    // Hidden state
        this.sNormalizer = new Array(this.hiddenSize).fill(1); // Normalizer state
        
        // Exponential gates (key innovation of xLSTM)
        this.expInputGate = new Array(this.hiddenSize).fill(0).map(() => Math.random());
        this.expForgetGate = new Array(this.hiddenSize).fill(0).map(() => 0.9 + Math.random() * 0.1);
        
        // mLSTM component (matrix memory)
        this.matrixMemory = [];
        for (let i = 0; i < 8; i++) {
            this.matrixMemory.push(new Array(8).fill(0).map(() => Math.random() * 0.1));
        }
        this.mNormalizer = new Array(8).fill(1);
        
        // Gate weights
        this.Wi = new Array(this.hiddenSize).fill(0).map(() => Math.random() - 0.5);
        this.Wf = new Array(this.hiddenSize).fill(0).map(() => Math.random() + 0.5);
        this.Wo = new Array(this.hiddenSize).fill(0).map(() => Math.random() - 0.5);
        this.Wc = new Array(this.hiddenSize).fill(0).map(() => Math.random() - 0.5);
        
        // Output projection - stronger weights
        this.Wout = [Math.random() + 0.5, Math.random() + 0.5, Math.random() + 0.5, Math.random() + 0.5, Math.random() + 0.5];
        
        // Covariance update rule weight
        this.covarianceRate = 0.1;
        
        // Movement and shooting biases
        this.moveBias = 0.4;
        this.shootBias = 0.3;
    }
    
    think(enemies, bullets, dt) {
        const aliveEnemies = enemies.filter(e => e.alive && e !== this);
        
        // Encode input
        let input = new Array(this.hiddenSize).fill(0);
        
        aliveEnemies.forEach((enemy, i) => {
            if (i < 3) {
                const dx = (enemy.x - this.x) / canvas.width;
                const dy = (enemy.y - this.y) / canvas.height;
                const dist = Math.sqrt(dx * dx + dy * dy);
                input[i * 4] = dx;
                input[i * 4 + 1] = dy;
                input[i * 4 + 2] = dist;
                input[i * 4 + 3] = (enemy.health - this.health) / 100;
            }
        });
        
        // Bullet threat encoding
        let bulletThreat = 0;
        let evadeX = 0, evadeY = 0;
        bullets.forEach(b => {
            if (b.owner === this) return;
            const dx = b.x - this.x;
            const dy = b.y - this.y;
            const dist = this.safeDist(dx, dy);
            if (dist < 150) {
                bulletThreat += (150 - dist) / 150;
                evadeX -= dx / dist;
                evadeY -= dy / dist;
            }
        });
        input[12] = bulletThreat;
        input[13] = evadeX;
        input[14] = evadeY;
        input[15] = this.health / 100;
        
        // === sLSTM with EXPONENTIAL GATING ===
        // This is the key innovation - exp gates allow unbounded memory
        let inputGate = new Array(this.hiddenSize).fill(0);
        let forgetGate = new Array(this.hiddenSize).fill(0);
        let outputGate = new Array(this.hiddenSize).fill(0);
        let cellInput = new Array(this.hiddenSize).fill(0);
        
        for (let i = 0; i < this.hiddenSize; i++) {
            // Exponential input gate (can be > 1, unlike sigmoid)
            inputGate[i] = Math.exp(this.Wi[i] * input[i] * this.expInputGate[i]);
            
            // Exponential forget gate
            forgetGate[i] = Math.exp(this.Wf[i] * this.expForgetGate[i]);
            
            // Regular sigmoid output gate
            outputGate[i] = 1 / (1 + Math.exp(-this.Wo[i] * (input[i] + this.sHidden[i])));
            
            // Cell input
            cellInput[i] = Math.tanh(this.Wc[i] * input[i]);
        }
        
        // Update cell state with exponential gating
        for (let i = 0; i < this.hiddenSize; i++) {
            // Normalizer update (prevents explosion)
            this.sNormalizer[i] = forgetGate[i] * this.sNormalizer[i] + inputGate[i];
            
            // Cell state update
            this.sCell[i] = forgetGate[i] * this.sCell[i] + inputGate[i] * cellInput[i];
            
            // Hidden state (normalized)
            this.sHidden[i] = outputGate[i] * (this.sCell[i] / (this.sNormalizer[i] + 0.001));
        }
        
        // === mLSTM: Matrix Memory Update ===
        // Stores key-value associations in a matrix
        const queryVec = this.sHidden.slice(0, 8);
        const keyVec = input.slice(0, 8);
        const valueVec = input.slice(8, 16);
        
        // Retrieve from matrix memory
        let retrieved = new Array(8).fill(0);
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                retrieved[i] += this.matrixMemory[i][j] * queryVec[j];
            }
            retrieved[i] /= (this.mNormalizer[i] + 0.001);
        }
        
        // Update matrix memory (covariance update rule)
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                this.matrixMemory[i][j] = this.matrixMemory[i][j] * 0.95 + 
                    this.covarianceRate * valueVec[i] * keyVec[j];
            }
            this.mNormalizer[i] = this.mNormalizer[i] * 0.95 + 
                this.covarianceRate * Math.abs(keyVec[i]);
        }
        
        // Combine sLSTM hidden state with mLSTM retrieval
        let combined = new Array(this.hiddenSize).fill(0);
        for (let i = 0; i < this.hiddenSize; i++) {
            if (i < 8) {
                combined[i] = this.sHidden[i] * 0.6 + retrieved[i] * 0.4;
            } else {
                combined[i] = this.sHidden[i];
            }
        }
        
        // Output projection - amplified
        let output = [0, 0, 0, 0, 0]; // moveX, moveY, shoot, shootAlt, aggression
        for (let i = 0; i < this.hiddenSize; i++) {
            output[i % 5] += combined[i] * this.Wout[i % 5] * 0.4;
        }
        output = output.map(o => Math.tanh(o));
        
        // Find target
        let targetAngle = this.angle;
        let targetDist = 999;
        let targetHealth = 100;
        let targetDx = 0, targetDy = 0;
        
        if (aliveEnemies.length > 0) {
            const target = aliveEnemies.sort((a, b) => {
                const da = this.safeDist(a.x - this.x, a.y - this.y);
                const db = this.safeDist(b.x - this.x, b.y - this.y);
                return (da * 0.5 + a.health * 0.5) - (db * 0.5 + b.health * 0.5);
            })[0];
            
            targetDx = target.x - this.x;
            targetDy = target.y - this.y;
            const predX = target.x + (target.vx || 0) * this.weights.prediction * 0.4;
            const predY = target.y + (target.vy || 0) * this.weights.prediction * 0.4;
            targetAngle = Math.atan2(predY - this.y, predX - this.x);
            targetDist = this.safeDist(targetDx, targetDy);
            targetHealth = target.health;
        }
        
        // Movement - combine network output with direct chase/evade behavior
        let moveX = output[0] * this.weights.aggression;
        let moveY = output[1] * this.weights.aggression;
        
        // Add direct movement toward/away from target based on distance
        if (aliveEnemies.length > 0) {
            const dirX = targetDx / targetDist;
            const dirY = targetDy / targetDist;
            
            if (targetDist > 200) {
                // Chase
                moveX += dirX * this.moveBias * this.weights.aggression;
                moveY += dirY * this.moveBias * this.weights.aggression;
            } else if (targetDist < 80) {
                // Retreat
                moveX -= dirX * this.moveBias * this.weights.evasion;
                moveY -= dirY * this.moveBias * this.weights.evasion;
            } else {
                // Strafe
                moveX += -dirY * this.moveBias * 0.5;
                moveY += dirX * this.moveBias * 0.5;
            }
        }
        
        // Add evasion
        moveX += evadeX * this.weights.evasion * 0.4;
        moveY += evadeY * this.weights.evasion * 0.4;
        
        const mag = Math.sqrt(moveX * moveX + moveY * moveY);
        if (mag > 1) { moveX /= mag; moveY /= mag; }
        
        // Clamp to prevent NaN
        moveX = Math.max(-1, Math.min(1, moveX || 0));
        moveY = Math.max(-1, Math.min(1, moveY || 0));
        
        // Weapon selection based on learned output and situation
        // xLSTM uses matrix memory to remember which weapon works in which situation
        const useRailgun = (targetDist > 200 && targetHealth > 50) || output[3] > 0.5;
        const useLaser = targetDist < 200 && targetDist > 40 && !useRailgun && this.weapons.laser.ready;
        
        // More aggressive shooting
        const hasTarget = aliveEnemies.length > 0;
        const shootDecision = (output[2] + this.shootBias) > 0.15 || (hasTarget && Math.random() < this.weights.aggression * 0.5);
        
        return {
            moveX,
            moveY,
            shoot: shootDecision && hasTarget && !useRailgun && !useLaser,
            shootAlt: useRailgun && this.weapons.railgun.ready && shootDecision && hasTarget,
            shootLaser: useLaser && shootDecision && hasTarget,
            targetAngle
        };
    }
    
    learn(event, data) {
        super.learn(event, data);
        
        const lr = this.weights.learningRate * 1.2;
        
        if (event === 'hit_enemy') {
            // Strengthen exponential gates
            this.expInputGate = this.expInputGate.map(g => Math.min(2, g + lr * 0.15));
            this.covarianceRate = Math.min(0.3, this.covarianceRate + lr * 0.05);
            this.Wout = this.Wout.map(w => w * (1 + lr * 0.1));
            this.shootBias = Math.min(0.6, this.shootBias + lr * 0.1);
        } else if (event === 'killed') {
            // Big reinforcement to memory
            this.expInputGate = this.expInputGate.map(g => Math.min(2.5, g + lr * 0.3));
            this.covarianceRate = Math.min(0.4, this.covarianceRate + lr * 0.1);
            this.moveBias = Math.min(0.7, this.moveBias + lr * 0.1);
            this.shootBias = Math.min(0.7, this.shootBias + lr * 0.15);
            
            // Strengthen forget gates (remember winning patterns)
            this.expForgetGate = this.expForgetGate.map(g => Math.min(1.5, g + lr * 0.1));
        } else if (event === 'took_damage') {
            // Increase forget (react faster to new situations)
            this.expForgetGate = this.expForgetGate.map(g => Math.max(0.7, g - lr * 0.05));
            this.Wi = this.Wi.map(w => w * (1 + lr * 0.1));
            this.moveBias = Math.min(0.8, this.moveBias + lr * 0.1); // Move more when taking damage
        } else if (event === 'died') {
            // Reduce memory persistence, need fresh strategy
            this.expForgetGate = this.expForgetGate.map(g => Math.max(0.6, g - lr * 0.1));
            this.covarianceRate = Math.max(0.05, this.covarianceRate - lr * 0.05);
            
            // Partially reset matrix memory
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    this.matrixMemory[i][j] *= 0.8;
                }
            }
        }
    }
}

// HYENA - Long convolutions with data-controlled gating (2023)
class HyenaAgent extends NeuralAgent {
    constructor(x, y) {
        super('HYENA', '#06b6d4', x, y);
    }
    
    initArchitecture() {
        this.seqLen = 16; // Sequence length for convolution
        this.filterOrder = 3; // Number of Hyena filters
        
        // Input history buffer (simulates sequence)
        this.inputHistory = [];
        for (let i = 0; i < this.seqLen; i++) {
            this.inputHistory.push(new Array(8).fill(0));
        }
        
        // Hyena filters (long convolution kernels) - learnable
        this.filters = [];
        for (let i = 0; i < this.filterOrder; i++) {
            this.filters.push(new Array(this.seqLen).fill(0).map((_, j) => 
                Math.exp(-j * 0.2) * (Math.random() - 0.5) * 2
            ));
        }
        
        // Data-controlled gating projections
        this.gateProjections = [];
        for (let i = 0; i < this.filterOrder; i++) {
            this.gateProjections.push(new Array(8).fill(0).map(() => Math.random() - 0.5));
        }
        
        // Output projection
        this.Wout = new Array(8).fill(0).map(() => Math.random() + 0.3);
        
        // Positional encoding (implicit in filter design)
        this.positionalBias = new Array(this.seqLen).fill(0).map((_, i) => 
            Math.sin(i * 0.5) * 0.3
        );
        
        // Biases for behavior
        this.shootBias = 0.35;
        this.moveBias = 0.4;
    }
    
    think(enemies, bullets, dt) {
        const aliveEnemies = enemies.filter(e => e.alive && e !== this);
        
        // Create current input
        let currentInput = new Array(8).fill(0);
        
        // Encode enemies
        aliveEnemies.forEach((enemy, i) => {
            if (i < 2) {
                const dx = (enemy.x - this.x) / canvas.width;
                const dy = (enemy.y - this.y) / canvas.height;
                const dist = this.safeDist(enemy.x - this.x, enemy.y - this.y) / 500;
                const health = enemy.health / 100;
                currentInput[i * 4] = dx;
                currentInput[i * 4 + 1] = dy;
                currentInput[i * 4 + 2] = dist;
                currentInput[i * 4 + 3] = health;
            }
        });
        
        // Update input history (shift and add new)
        this.inputHistory.shift();
        this.inputHistory.push([...currentInput]);
        
        // === HYENA OPERATOR ===
        // The key innovation: long convolutions + data-controlled gating
        
        // Step 1: Apply long convolution with each filter
        let convOutputs = [];
        for (let f = 0; f < this.filterOrder; f++) {
            let convResult = new Array(8).fill(0);
            
            // Convolve input history with filter
            for (let i = 0; i < this.seqLen; i++) {
                const filterVal = this.filters[f][i] + this.positionalBias[i];
                for (let j = 0; j < 8; j++) {
                    convResult[j] += this.inputHistory[i][j] * filterVal;
                }
            }
            convOutputs.push(convResult);
        }
        
        // Step 2: Data-controlled gating (multiplicative interactions)
        // This is what gives Hyena its expressiveness
        let gatedOutput = new Array(8).fill(0);
        
        for (let j = 0; j < 8; j++) {
            let value = convOutputs[0][j]; // Start with first conv output
            
            // Apply multiplicative gating from other conv outputs
            for (let f = 1; f < this.filterOrder; f++) {
                // Gate is sigmoid of projected current input
                const gateInput = currentInput.reduce((sum, x, k) => 
                    sum + x * this.gateProjections[f][k], 0);
                const gate = 1 / (1 + Math.exp(-gateInput));
                
                // Multiply previous value by gated conv output
                value = value * gate + convOutputs[f][j] * (1 - gate);
            }
            
            gatedOutput[j] = Math.tanh(value);
        }
        
        // Step 3: Output projection
        let output = [0, 0, 0, 0]; // moveX, moveY, shoot, weaponSelect
        for (let j = 0; j < 8; j++) {
            output[j % 4] += gatedOutput[j] * this.Wout[j];
        }
        output = output.map(o => Math.tanh(o * 0.5));
        
        // Find target
        let targetAngle = this.angle;
        let targetDist = 999;
        let targetHealth = 100;
        let targetDx = 0, targetDy = 0;
        
        if (aliveEnemies.length > 0) {
            const target = aliveEnemies.sort((a, b) => {
                const da = this.safeDist(a.x - this.x, a.y - this.y);
                const db = this.safeDist(b.x - this.x, b.y - this.y);
                return da - db;
            })[0];
            
            targetDx = target.x - this.x;
            targetDy = target.y - this.y;
            targetDist = this.safeDist(targetDx, targetDy);
            targetHealth = target.health;
            
            const predX = target.x + (target.vx || 0) * this.weights.prediction * 0.4;
            const predY = target.y + (target.vy || 0) * this.weights.prediction * 0.4;
            targetAngle = Math.atan2(predY - this.y, predX - this.x);
        }
        
        // Movement - combine network output with direct behavior
        let moveX = output[0] * this.weights.aggression;
        let moveY = output[1] * this.weights.aggression;
        
        if (aliveEnemies.length > 0) {
            const dirX = targetDx / targetDist;
            const dirY = targetDy / targetDist;
            
            if (targetDist > 220) {
                moveX += dirX * this.moveBias * this.weights.aggression;
                moveY += dirY * this.moveBias * this.weights.aggression;
            } else if (targetDist < 100) {
                moveX -= dirX * this.moveBias * this.weights.evasion * 0.7;
                moveY -= dirY * this.moveBias * this.weights.evasion * 0.7;
            }
        }
        
        // Bullet evasion
        bullets.forEach(b => {
            if (b.owner === this) return;
            const dx = b.x - this.x;
            const dy = b.y - this.y;
            const dist = this.safeDist(dx, dy);
            if (dist < 120) {
                moveX -= (dx / dist) * this.weights.evasion * 0.5;
                moveY -= (dy / dist) * this.weights.evasion * 0.5;
            }
        });
        
        const mag = Math.sqrt(moveX * moveX + moveY * moveY);
        if (mag > 1) { moveX /= mag; moveY /= mag; }
        
        moveX = Math.max(-1, Math.min(1, moveX || 0));
        moveY = Math.max(-1, Math.min(1, moveY || 0));
        
        // Weapon selection based on output[3] and situation
        // Hyena's long convolutions help it learn temporal patterns of when to use each weapon
        const weaponScore = output[3];
        const hasTarget = aliveEnemies.length > 0;
        const shootDecision = (output[2] + this.shootBias) > 0.2 || (hasTarget && Math.random() < this.weights.aggression * 0.4);
        
        let useRailgun = false, useLaser = false;
        
        if (targetDist > 220 && weaponScore > 0.3 && this.weapons.railgun.ready) {
            useRailgun = true;
        } else if (targetDist < 200 && targetDist > 50 && weaponScore < -0.2 && this.weapons.laser.ready) {
            useLaser = true;
        }
        
        return {
            moveX,
            moveY,
            shoot: shootDecision && hasTarget && !useRailgun && !useLaser,
            shootAlt: useRailgun && hasTarget && shootDecision,
            shootLaser: useLaser && hasTarget && shootDecision,
            targetAngle
        };
    }
    
    learn(event, data) {
        super.learn(event, data);
        
        const lr = this.weights.learningRate * 1.3;
        
        if (event === 'hit_enemy') {
            // Strengthen filters that contributed
            this.filters = this.filters.map(filter => 
                filter.map(f => f * (1 + lr * 0.1))
            );
            this.Wout = this.Wout.map(w => w * (1 + lr * 0.15));
            this.shootBias = Math.min(0.6, this.shootBias + lr * 0.1);
        } else if (event === 'killed') {
            // Big reinforcement
            this.filters = this.filters.map(filter => 
                filter.map(f => f * (1 + lr * 0.2))
            );
            this.gateProjections = this.gateProjections.map(gate =>
                gate.map(g => g * (1 + lr * 0.15))
            );
            this.moveBias = Math.min(0.7, this.moveBias + lr * 0.1);
            this.shootBias = Math.min(0.7, this.shootBias + lr * 0.15);
        } else if (event === 'took_damage') {
            // Adjust positional bias to react faster
            this.positionalBias = this.positionalBias.map((p, i) => 
                p + (i < this.seqLen / 2 ? lr * 0.05 : -lr * 0.02)
            );
            this.moveBias = Math.min(0.8, this.moveBias + lr * 0.1);
        } else if (event === 'died') {
            // Decay old filter values
            this.filters = this.filters.map(filter => 
                filter.map((f, i) => f * (0.9 + i * 0.005))
            );
            this.shootBias = Math.max(0.15, this.shootBias - lr * 0.1);
        }
    }
}

// Game objects
let agents = [];
let bullets = [];

function getRandomSpawnPositions(count) {
    const positions = [];
    const margin = 80;
    const minDist = 150; // Minimum distance between agents
    
    for (let i = 0; i < count; i++) {
        let attempts = 0;
        let pos;
        
        do {
            pos = {
                x: margin + Math.random() * (canvas.width - margin * 2),
                y: margin + Math.random() * (canvas.height - margin * 2)
            };
            attempts++;
            
            // Check distance from other positions
            let tooClose = false;
            for (const other of positions) {
                const dx = pos.x - other.x;
                const dy = pos.y - other.y;
                if (Math.sqrt(dx * dx + dy * dy) < minDist) {
                    tooClose = true;
                    break;
                }
            }
            
            if (!tooClose || attempts > 50) {
                positions.push(pos);
                break;
            }
        } while (true);
    }
    
    return positions;
}

function initAgents() {
    const positions = getRandomSpawnPositions(7);
    
    agents = [
        new TransformerAgent(positions[0].x, positions[0].y),
        new MambaAgent(positions[1].x, positions[1].y),
        new MoEAgent(positions[2].x, positions[2].y),
        new NTMAgent(positions[3].x, positions[3].y),
        new RWKVAgent(positions[4].x, positions[4].y),
        new xLSTMAgent(positions[5].x, positions[5].y),
        new HyenaAgent(positions[6].x, positions[6].y)
    ];
}

function updateUI() {
    // Transformer
    document.getElementById('t-health').style.width = `${agents[0].health}%`;
    document.getElementById('t-kills').textContent = agents[0].kills;
    document.getElementById('t-deaths').textContent = agents[0].deaths;
    document.getElementById('t-wins').textContent = roundWins[0];
    document.getElementById('t-accuracy').textContent = `${agents[0].getAccuracy()}%`;
    document.getElementById('t-learning').textContent = agents[0].alive ? 
        `ATT: ${agents[0].attentionWeights.map(w => w.toFixed(2)).join(', ')}` : 'ELIMINATED';
    document.getElementById('t-weights').textContent = 
        `agg:${agents[0].weights.aggression.toFixed(2)} eva:${agents[0].weights.evasion.toFixed(2)} acc:${agents[0].weights.accuracy.toFixed(2)}`;
    
    // Mamba
    document.getElementById('m-health').style.width = `${agents[1].health}%`;
    document.getElementById('m-kills').textContent = agents[1].kills;
    document.getElementById('m-deaths').textContent = agents[1].deaths;
    document.getElementById('m-wins').textContent = roundWins[1];
    document.getElementById('m-accuracy').textContent = `${agents[1].getAccuracy()}%`;
    document.getElementById('m-learning').textContent = agents[1].alive ? 
        `SEL: ${agents[1].selectivity.toFixed(3)}` : 'ELIMINATED';
    document.getElementById('m-weights').textContent = 
        `agg:${agents[1].weights.aggression.toFixed(2)} eva:${agents[1].weights.evasion.toFixed(2)} acc:${agents[1].weights.accuracy.toFixed(2)}`;
    
    // MoE
    document.getElementById('e-health').style.width = `${agents[2].health}%`;
    document.getElementById('e-kills').textContent = agents[2].kills;
    document.getElementById('e-deaths').textContent = agents[2].deaths;
    document.getElementById('e-wins').textContent = roundWins[2];
    document.getElementById('e-accuracy').textContent = `${agents[2].getAccuracy()}%`;
    document.getElementById('e-experts').textContent = agents[2].currentExperts || '...';
    document.getElementById('e-learning').textContent = agents[2].alive ? 
        `GATE: ${agents[2].gatingWeights.slice(0, 4).map(w => w.toFixed(2)).join(', ')}...` : 'ELIMINATED';
    document.getElementById('e-weights').textContent = 
        `agg:${agents[2].weights.aggression.toFixed(2)} eva:${agents[2].weights.evasion.toFixed(2)} acc:${agents[2].weights.accuracy.toFixed(2)}`;
    
    // NTM
    document.getElementById('n-health').style.width = `${agents[3].health}%`;
    document.getElementById('n-kills').textContent = agents[3].kills;
    document.getElementById('n-deaths').textContent = agents[3].deaths;
    document.getElementById('n-wins').textContent = roundWins[3];
    document.getElementById('n-accuracy').textContent = `${agents[3].getAccuracy()}%`;
    document.getElementById('n-learning').textContent = agents[3].alive ? 
        `MEM HEAD: ${agents[3].writeHead.toFixed(1)}` : 'ELIMINATED';
    document.getElementById('n-weights').textContent = 
        `agg:${agents[3].weights.aggression.toFixed(2)} eva:${agents[3].weights.evasion.toFixed(2)} acc:${agents[3].weights.accuracy.toFixed(2)}`;
    
    // RWKV
    document.getElementById('r-health').style.width = `${agents[4].health}%`;
    document.getElementById('r-kills').textContent = agents[4].kills;
    document.getElementById('r-deaths').textContent = agents[4].deaths;
    document.getElementById('r-wins').textContent = roundWins[4];
    document.getElementById('r-accuracy').textContent = `${agents[4].getAccuracy()}%`;
    document.getElementById('r-learning').textContent = agents[4].alive ? 
        `MIX: R${agents[4].mixR.toFixed(2)} K${agents[4].mixK.toFixed(2)} SHOOT:${agents[4].shootBias.toFixed(2)}` : 'ELIMINATED';
    document.getElementById('r-weights').textContent = 
        `agg:${agents[4].weights.aggression.toFixed(2)} eva:${agents[4].weights.evasion.toFixed(2)} rail:${agents[4].weights.railgunPreference.toFixed(2)}`;
    
    // xLSTM
    document.getElementById('x-health').style.width = `${agents[5].health}%`;
    document.getElementById('x-kills').textContent = agents[5].kills;
    document.getElementById('x-deaths').textContent = agents[5].deaths;
    document.getElementById('x-wins').textContent = roundWins[5];
    document.getElementById('x-accuracy').textContent = `${agents[5].getAccuracy()}%`;
    const avgExpGate = agents[5].expInputGate.reduce((a,b) => a+b, 0) / agents[5].expInputGate.length;
    document.getElementById('x-learning').textContent = agents[5].alive ? 
        `EXP:${avgExpGate.toFixed(2)} MOV:${agents[5].moveBias.toFixed(2)} SHT:${agents[5].shootBias.toFixed(2)}` : 'ELIMINATED';
    document.getElementById('x-weights').textContent = 
        `agg:${agents[5].weights.aggression.toFixed(2)} eva:${agents[5].weights.evasion.toFixed(2)} rail:${agents[5].weights.railgunPreference.toFixed(2)}`;
    
    // Hyena
    document.getElementById('h-health').style.width = `${agents[6].health}%`;
    document.getElementById('h-kills').textContent = agents[6].kills;
    document.getElementById('h-deaths').textContent = agents[6].deaths;
    document.getElementById('h-wins').textContent = roundWins[6];
    document.getElementById('h-accuracy').textContent = `${agents[6].getAccuracy()}%`;
    document.getElementById('h-learning').textContent = agents[6].alive ? 
        `MOV:${agents[6].moveBias.toFixed(2)} SHT:${agents[6].shootBias.toFixed(2)}` : 'ELIMINATED';
    document.getElementById('h-weights').textContent = 
        `agg:${agents[6].weights.aggression.toFixed(2)} eva:${agents[6].weights.evasion.toFixed(2)} rail:${agents[6].weights.railgunPreference.toFixed(2)}`;
    
    // Update brain visualizations
    updateBrainVis('t-brain', agents[0].attentionWeights);
    updateBrainVis('m-brain', agents[1].hiddenState.slice(0, 12));
    updateBrainVis('e-brain', agents[2].gatingWeights);
    updateBrainVis('n-brain', agents[3].readWeights.slice(0, 12));
    updateBrainVis('r-brain', agents[4].timeMixState.slice(0, 12));
    updateBrainVis('x-brain', agents[5].sHidden.slice(0, 12));
    updateBrainVis('h-brain', agents[6].filters[0].slice(0, 12));
    
    // Generation and round info
    document.getElementById('gen-num').textContent = generation;
    document.getElementById('round-num').textContent = roundNumber;
    document.getElementById('fight-num').textContent = totalFights;
}

function updateBrainVis(id, values) {
    const container = document.getElementById(id);
    container.innerHTML = '';
    values.forEach(v => {
        const neuron = document.createElement('div');
        neuron.className = 'neuron' + (Math.abs(v) > 0.1 ? ' active' : '');
        neuron.style.opacity = Math.min(1, Math.abs(v) * 2 + 0.3);
        container.appendChild(neuron);
    });
}

const logContainer = document.getElementById('log');
function addLog(message, type = '') {
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + type;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logContainer.insertBefore(entry, logContainer.firstChild);
    
    // Keep only last 50 entries
    while (logContainer.children.length > 50) {
        logContainer.removeChild(logContainer.lastChild);
    }
}

function update(dt) {
    if (paused) return;
    
    // Handle round end timer
    if (!roundInProgress) {
        roundEndTimer -= dt * 1000;
        if (roundEndTimer <= 0) {
            startNewRound();
        }
        return;
    }
    
    // Update agents
    agents.forEach(agent => {
        const bullet = agent.update(agents, bullets, dt);
        if (bullet) bullets.push(bullet);
    });
    
    // Update bullets
    bullets = bullets.filter(bullet => {
        bullet.x += bullet.vx * dt;
        bullet.y += bullet.vy * dt;
        
        // NaN protection for bullets
        if (isNaN(bullet.x) || isNaN(bullet.y)) return false;
        
        // Screen wrapping for bullets
        if (bullet.x < -20) bullet.x = canvas.width + 20;
        if (bullet.x > canvas.width + 20) bullet.x = -20;
        if (bullet.y < -20) bullet.y = canvas.height + 20;
        if (bullet.y > canvas.height + 20) bullet.y = -20;
        
        // Bullet lifetime limit (prevent infinite bullets)
        bullet.life = (bullet.life || 0) + dt;
        if (bullet.life > 5) {
            bullet.owner.learn('missed', {});
            return false;
        }
        
        // Check collisions
        for (const agent of agents) {
            if (agent === bullet.owner || !agent.alive) continue;
            
            const dx = bullet.x - agent.x;
            const dy = bullet.y - agent.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < agent.radius) {
                agent.takeDamage(bullet.damage, bullet.owner);
                bullet.owner.shotsHit++;
                bullet.owner.learn('hit_enemy', { 
                    target: agent.type, 
                    damage: bullet.damage,
                    weaponType: bullet.type || 'bullet'
                });
                totalFights++;
                return false;
            }
        }
        
        return true;
    });
    
    // Check for round winner (last one standing)
    const aliveAgents = agents.filter(a => a.alive);
    if (aliveAgents.length === 1 && roundInProgress) {
        const winner = aliveAgents[0];
        const winnerIndex = agents.indexOf(winner);
        roundWins[winnerIndex]++;
        
        addLog(`üèÜ ${winner.type} WINS ROUND ${roundNumber}!`, 'kill');
        
        roundInProgress = false;
        roundEndTimer = 2000 / gameSpeed; // 2 second pause before next round
        roundNumber++;
        
        // Check for generation advancement (every 5 rounds)
        if (roundNumber > generation * 5) {
            advanceGeneration();
        }
    }
    
    // Edge case: everyone dead at same time
    if (aliveAgents.length === 0 && roundInProgress) {
        addLog(`üíÄ MUTUAL DESTRUCTION! No winner.`, 'respawn');
        roundInProgress = false;
        roundEndTimer = 2000 / gameSpeed;
        roundNumber++;
        
        if (roundNumber > generation * 5) {
            advanceGeneration();
        }
    }
}

function startNewRound() {
    addLog(`--- Round ${roundNumber} ---`, 'learn');
    
    // Get random positions for this round
    const positions = getRandomSpawnPositions(7);
    
    agents.forEach((agent, i) => {
        agent.x = positions[i].x;
        agent.y = positions[i].y;
        agent.health = agent.maxHealth;
        agent.alive = true;
        agent.respawnTimer = 0;
        agent.vx = 0;
        agent.vy = 0;
        agent.angle = Math.random() * Math.PI * 2;
        agent.activeLaser = null;
    });
    
    bullets = [];
    roundInProgress = true;
}

function advanceGeneration() {
    generation++;
    addLog(`üß¨ === GENERATION ${generation} === üß¨`, 'learn');
    
    // Find the best and worst performers
    const rankings = agents.map((agent, i) => ({
        agent,
        index: i,
        wins: roundWins[i],
        kd: agent.kills / (agent.deaths || 1),
        accuracy: agent.getAccuracy()
    })).sort((a, b) => b.wins - a.wins || b.kd - a.kd);
    
    const best = rankings[0];
    const worst = rankings[6];
    const secondWorst = rankings[5];
    
    addLog(`ü•á Best: ${best.agent.type} (${best.wins} wins, ${best.accuracy}% acc)`, 'learn');
    addLog(`üìà ${worst.agent.type} & ${secondWorst.agent.type} evolving...`, 'learn');
    
    // Evolution: bottom 2 performers inherit traits from best
    const inheritRate = 0.4;
    [worst, secondWorst].forEach(loser => {
        loser.agent.weights.aggression = loser.agent.weights.aggression * (1 - inheritRate) + 
                                          best.agent.weights.aggression * inheritRate;
        loser.agent.weights.evasion = loser.agent.weights.evasion * (1 - inheritRate) + 
                                       best.agent.weights.evasion * inheritRate;
        loser.agent.weights.accuracy = loser.agent.weights.accuracy * (1 - inheritRate) + 
                                        best.agent.weights.accuracy * inheritRate;
        loser.agent.weights.prediction = loser.agent.weights.prediction * (1 - inheritRate) + 
                                          best.agent.weights.prediction * inheritRate;
        loser.agent.weights.railgunPreference = loser.agent.weights.railgunPreference * (1 - inheritRate) + 
                                                 best.agent.weights.railgunPreference * inheritRate;
    });
    
    // Mutation for all agents - stronger mutations
    agents.forEach(agent => {
        const mutationRate = 0.15;
        agent.weights.aggression += (Math.random() - 0.5) * mutationRate;
        agent.weights.evasion += (Math.random() - 0.5) * mutationRate;
        agent.weights.accuracy += (Math.random() - 0.5) * mutationRate;
        agent.weights.prediction += (Math.random() - 0.5) * mutationRate;
        agent.weights.railgunPreference += (Math.random() - 0.5) * mutationRate;
        
        // Clamp weights
        agent.weights.aggression = Math.max(0.15, Math.min(0.95, agent.weights.aggression));
        agent.weights.evasion = Math.max(0.15, Math.min(0.95, agent.weights.evasion));
        agent.weights.accuracy = Math.max(0.15, Math.min(0.95, agent.weights.accuracy));
        agent.weights.prediction = Math.max(0.1, Math.min(0.9, agent.weights.prediction));
        agent.weights.railgunPreference = Math.max(0.1, Math.min(0.9, agent.weights.railgunPreference));
        
        // Boost learning rate each generation
        agent.weights.learningRate = Math.min(0.2, agent.weights.learningRate * 1.1);
    });
    
    // Reset round wins for new generation
    roundWins = [0, 0, 0, 0, 0, 0, 0];
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = '#1a1a2e';
    ctx.lineWidth = 1;
    for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    // Draw bullets
    bullets.forEach(bullet => {
        const size = Math.max(1, bullet.size || 4);
        const trail = bullet.trail || 0.03;
        
        // Railgun has glow effect
        if (bullet.type === 'railgun') {
            ctx.fillStyle = bullet.color + '40';
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, size * 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.fillStyle = bullet.color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Trail
        ctx.strokeStyle = bullet.color + '40';
        ctx.lineWidth = bullet.type === 'railgun' ? 4 : 2;
        ctx.beginPath();
        ctx.moveTo(bullet.x, bullet.y);
        ctx.lineTo(bullet.x - bullet.vx * trail, bullet.y - bullet.vy * trail);
        ctx.stroke();
    });
    
    // Draw agents
    agents.forEach(agent => agent.draw());
    
    // Draw respawn indicators for dead agents
    agents.filter(a => !a.alive).forEach(agent => {
        ctx.fillStyle = agent.color + '40';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${agent.type} respawning...`, agent.x, agent.y);
        ctx.fillText(`${(agent.respawnTimer / 1000).toFixed(1)}s`, agent.x, agent.y + 15);
    });
    
    // Draw round end overlay
    if (!roundInProgress) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const winner = agents.find(a => a.alive);
        
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px monospace';
        
        if (winner) {
            ctx.fillStyle = winner.color;
            ctx.fillText(`üèÜ ${winner.type} WINS! üèÜ`, canvas.width / 2, canvas.height / 2 - 20);
        } else {
            ctx.fillText('üíÄ MUTUAL DESTRUCTION üíÄ', canvas.width / 2, canvas.height / 2 - 20);
        }
        
        ctx.fillStyle = '#888';
        ctx.font = '18px monospace';
        ctx.fillText(`Round ${roundNumber} starting in ${(roundEndTimer / 1000).toFixed(1)}s...`, canvas.width / 2, canvas.height / 2 + 30);
        
        // Show generation advancement if applicable
        if (roundNumber > generation * 5) {
            ctx.fillStyle = '#00ffaa';
            ctx.fillText(`‚¨ÜÔ∏è EVOLVING TO GENERATION ${generation + 1}`, canvas.width / 2, canvas.height / 2 + 60);
        }
    }
}

let lastTime = 0;
function gameLoop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;
    
    update(dt);
    draw();
    updateUI();
    
    requestAnimationFrame(gameLoop);
}

// Controls
document.getElementById('pauseBtn').addEventListener('click', () => {
    paused = !paused;
    document.getElementById('pauseBtn').textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
});

document.getElementById('resetBtn').addEventListener('click', () => {
    bullets = [];
    generation = 1;
    totalFights = 0;
    roundNumber = 1;
    roundWins = [0, 0, 0, 0, 0, 0, 0];
    roundInProgress = true;
    initAgents();
    logContainer.innerHTML = '';
    addLog('Game reset!', 'respawn');
});

document.getElementById('speed-slider').addEventListener('input', (e) => {
    gameSpeed = parseFloat(e.target.value);
    document.getElementById('speed-value').textContent = gameSpeed + 'x';
});

// Initialize
initAgents();
addLog('Neural Network Battle Arena initialized!', 'learn');
addLog('7 AGI architectures with 3 weapons!', 'learn');
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
