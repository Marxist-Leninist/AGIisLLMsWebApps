<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL BOXING 2: ARCHITECTURE BEATDOWN</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(180deg, #1a0505 0%, #0a0a12 50%, #050510 100%);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 8px;
        }
        
        h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 3px;
        }
        
        .subtitle { color: #666; font-size: 0.75rem; }
        
        .ring-container {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        
        .corner-panel {
            background: linear-gradient(145deg, #1a1215, #0a0808);
            border: 2px solid #2a1a1a;
            border-radius: 10px;
            padding: 10px;
            width: 200px;
            font-size: 0.75rem;
        }
        
        .corner-panel.red { border-color: #ff4444; }
        .corner-panel.blue { border-color: #4444ff; }
        
        .fighter-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .fighter-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        
        .corner-panel.red .fighter-icon { background: #ff4444; }
        .corner-panel.blue .fighter-icon { background: #4444ff; }
        
        .fighter-name { font-size: 0.9rem; font-weight: bold; }
        .corner-panel.red .fighter-name { color: #ff6666; }
        .corner-panel.blue .fighter-name { color: #6666ff; }
        
        .fighter-style { font-size: 0.6rem; color: #888; }
        
        .stat-bars { margin-bottom: 8px; }
        
        .stat-bar { margin-bottom: 5px; }
        
        .stat-bar .label {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: #666;
            margin-bottom: 1px;
        }
        
        .bar-bg {
            height: 10px;
            background: #1a1a1a;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.15s;
            border-radius: 5px;
        }
        
        .bar-fill.hp { background: linear-gradient(90deg, #44ff44, #22aa22); }
        .bar-fill.stamina { background: linear-gradient(90deg, #ffaa00, #aa7700); }
        .bar-fill.special { background: linear-gradient(90deg, #ff00ff, #aa00aa); }
        .bar-fill.hp.low { background: linear-gradient(90deg, #ff4444, #aa2222); }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            font-size: 0.65rem;
            margin-bottom: 8px;
        }
        
        .stat-item {
            background: #0a0a0a;
            padding: 4px;
            border-radius: 3px;
            text-align: center;
        }
        
        .stat-item .val {
            font-size: 0.9rem;
            font-weight: bold;
            color: #ffaa00;
        }
        
        .move-list {
            background: #0a0808;
            border-radius: 5px;
            padding: 6px;
            font-size: 0.6rem;
            margin-bottom: 8px;
        }
        
        .move-list h4 {
            color: #555;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-size: 0.55rem;
        }
        
        .move-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid #1a1a1a;
        }
        
        .move-item:last-child { border-bottom: none; }
        .move-item .name { color: #aaa; }
        .move-item .count { color: #ffaa00; }
        
        .brain-panel {
            background: #0a0808;
            border-radius: 5px;
            padding: 6px;
        }
        
        .brain-panel h4 {
            font-size: 0.55rem;
            color: #555;
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
        }
        
        .mem-cell {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            background: #1a1a1a;
        }
        
        .hidden-neurons {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
        }
        
        .neuron {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: #1a1a1a;
        }
        
        .ring {
            position: relative;
            width: 580px;
            height: 420px;
            background: linear-gradient(180deg, #2a2a35 0%, #1a1a22 100%);
            border: 8px solid #8B4513;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .ring-floor {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 180px;
            background: linear-gradient(180deg, #3a3a45 0%, #2a2a35 100%);
        }
        
        .ropes {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }
        
        .rope {
            position: absolute;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #aa2222, #ff4444, #aa2222);
        }
        
        .rope:nth-child(1) { top: 12%; }
        .rope:nth-child(2) { top: 28%; }
        .rope:nth-child(3) { bottom: 40%; }
        .rope:nth-child(4) { bottom: 25%; }
        
        .corner-post {
            position: absolute;
            width: 12px;
            height: 100%;
            background: linear-gradient(90deg, #555, #888, #555);
        }
        
        .corner-post.left { left: 0; }
        .corner-post.right { right: 0; }
        
        .boxer {
            position: absolute;
            width: 90px;
            height: 130px;
            transition: left 0.06s, bottom 0.06s;
        }
        
        .boxer-body {
            position: absolute;
            bottom: 0;
            width: 55px;
            height: 85px;
            left: 17px;
            border-radius: 28px 28px 18px 18px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s;
        }
        
        .boxer.red .boxer-body { background: linear-gradient(180deg, #ff6666, #cc3333); }
        .boxer.blue .boxer-body { background: linear-gradient(180deg, #6666ff, #3333cc); }
        
        .boxer-head {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: #ffcc99;
            margin-top: -12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            border: 3px solid;
            transition: transform 0.1s;
        }
        
        .boxer.red .boxer-head { border-color: #ff4444; }
        .boxer.blue .boxer-head { border-color: #4444ff; }
        
        .glove {
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            top: 48px;
            transition: all 0.06s;
        }
        
        .boxer.red .glove { background: radial-gradient(circle at 30% 30%, #ff6666, #cc2222); }
        .boxer.blue .glove { background: radial-gradient(circle at 30% 30%, #6666ff, #2222cc); }
        
        .glove.left { left: -5px; }
        .glove.right { right: -5px; }
        
        /* FIGHTING STANCES AND MOVES */
        .boxer.blocking .glove { top: 22px !important; }
        .boxer.blocking .glove.left { left: 8px !important; }
        .boxer.blocking .glove.right { right: 8px !important; }
        
        .boxer.jabbing .glove.right { right: -45px !important; top: 35px !important; }
        
        .boxer.hooking .glove.right { right: -40px !important; top: 28px !important; transform: rotate(-20deg); }
        
        .boxer.uppercutting .glove.right { right: -25px !important; top: 5px !important; }
        
        .boxer.body-shotting .glove.right { right: -40px !important; top: 55px !important; }
        
        .boxer.cross-punching .glove.right { right: -50px !important; top: 30px !important; }
        
        .boxer.combo-1 .glove.left { left: -40px !important; top: 35px !important; }
        .boxer.combo-2 .glove.right { right: -45px !important; top: 30px !important; }
        
        .boxer.slipping-left .boxer-body { transform: translateX(-15px) rotate(-10deg); }
        .boxer.slipping-left .boxer-head { transform: translateX(-10px); }
        
        .boxer.slipping-right .boxer-body { transform: translateX(15px) rotate(10deg); }
        .boxer.slipping-right .boxer-head { transform: translateX(10px); }
        
        .boxer.ducking .boxer-body { transform: translateY(20px) scaleY(0.8); }
        .boxer.ducking .boxer-head { transform: translateY(15px); }
        
        .boxer.weaving .boxer-body { animation: weave 0.4s ease-in-out; }
        
        @keyframes weave {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-12px) rotate(-8deg); }
            75% { transform: translateX(12px) rotate(8deg); }
        }
        
        .boxer.clinching .glove.left { left: 20px !important; top: 15px !important; }
        .boxer.clinching .glove.right { right: 20px !important; top: 15px !important; }
        
        .boxer.taunting .glove.left { left: 0 !important; top: 0 !important; transform: rotate(-30deg); }
        .boxer.taunting .boxer-head { animation: taunt-head 0.3s ease-in-out; }
        
        @keyframes taunt-head {
            0%, 100% { transform: rotate(0); }
            50% { transform: rotate(15deg) scale(1.1); }
        }
        
        .boxer.special-charging {
            animation: charge-glow 0.5s ease-in-out infinite;
        }
        
        @keyframes charge-glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5) drop-shadow(0 0 10px #ff00ff); }
        }
        
        .boxer.special-attacking .glove.right {
            right: -60px !important;
            top: 25px !important;
            transform: scale(1.5);
            animation: special-punch 0.3s ease-out;
        }
        
        @keyframes special-punch {
            0% { transform: scale(1) translateX(0); }
            50% { transform: scale(1.8) translateX(20px); }
            100% { transform: scale(1.5) translateX(10px); }
        }
        
        .boxer.hit { animation: hit-shake 0.15s; }
        
        @keyframes hit-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px) rotate(-3deg); }
            75% { transform: translateX(8px) rotate(3deg); }
        }
        
        .boxer.knocked-down .boxer-body {
            transform: rotate(85deg) translateY(35px) translateX(10px);
        }
        
        .boxer.knocked-down .boxer-head {
            transform: rotate(-85deg);
        }
        
        .boxer.stunned .boxer-head {
            animation: stun-spin 0.5s linear infinite;
        }
        
        @keyframes stun-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* EFFECTS */
        .effect {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }
        
        .punch-effect {
            font-size: 2rem;
            font-weight: bold;
            animation: punch-pop 0.4s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }
        
        @keyframes punch-pop {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(1.5) translateY(-20px); opacity: 0; }
        }
        
        .damage-text {
            font-size: 1.3rem;
            font-weight: bold;
            color: #ff4444;
            animation: damage-float 0.7s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }
        
        @keyframes damage-float {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-40px); opacity: 0; }
        }
        
        .combo-text {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffaa00;
            animation: combo-pop 0.8s ease-out forwards;
            text-shadow: 3px 3px 0 #000;
        }
        
        @keyframes combo-pop {
            0% { transform: scale(0.3) rotate(-10deg); opacity: 1; }
            50% { transform: scale(1.3) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg) translateY(-30px); opacity: 0; }
        }
        
        .special-effect {
            font-size: 2.5rem;
            animation: special-explode 0.6s ease-out forwards;
        }
        
        @keyframes special-explode {
            0% { transform: scale(0); opacity: 1; filter: hue-rotate(0deg); }
            50% { transform: scale(2); filter: hue-rotate(180deg); }
            100% { transform: scale(3); opacity: 0; filter: hue-rotate(360deg); }
        }
        
        .taunt-bubble {
            background: #000000ee;
            color: #fff;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            animation: taunt-float 1.5s ease-out forwards;
            white-space: nowrap;
        }
        
        @keyframes taunt-float {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        .thought-bubble {
            position: absolute;
            background: #000000dd;
            color: #fff;
            padding: 3px 7px;
            border-radius: 6px;
            font-size: 0.6rem;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .thought-bubble.visible { opacity: 1; }
        
        .scoreboard {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: #000000dd;
            padding: 6px 15px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1rem;
            font-weight: bold;
            z-index: 10;
        }
        
        .scoreboard .red { color: #ff4444; }
        .scoreboard .blue { color: #4444ff; }
        .scoreboard .round { color: #ffaa00; font-size: 0.7rem; }
        
        .round-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 3px 3px 0 #000;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        
        .round-banner.visible {
            animation: round-announce 1.8s ease-out forwards;
        }
        
        @keyframes round-announce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; }
        }
        
        .ko-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 4px 4px 0 #000, 0 0 30px #ff0000;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        
        .ko-banner.visible { opacity: 1; animation: ko-shake 0.5s ease-out; }
        
        @keyframes ko-shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0); }
            25% { transform: translate(-50%, -50%) rotate(-5deg) scale(1.1); }
            75% { transform: translate(-50%, -50%) rotate(5deg) scale(1.1); }
        }
        
        .controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
            border: 2px solid #3a3a4e;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 0.8rem;
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover { border-color: #00ffaa; color: #00ffaa; }
        button.active { background: #00aa7733; border-color: #00ffaa; color: #00ffaa; }
        
        .fighter-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
            margin-bottom: 8px;
        }
        
        .fighter-option {
            padding: 5px;
            background: #1a1a1a;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.65rem;
            text-align: center;
        }
        
        .fighter-option:hover { border-color: #444; }
        .fighter-option.selected { border-color: #00ffaa; background: #1a2a2a; }
        .fighter-option .icon { font-size: 1rem; }
        .fighter-option .name { font-weight: bold; color: #fff; font-size: 0.6rem; }
        
        .commentary {
            max-width: 950px;
            margin: 10px auto;
            background: linear-gradient(145deg, #1a1215, #0a0808);
            border: 2px solid #2a1a1a;
            border-radius: 8px;
            padding: 10px;
        }
        
        .commentary h3 { color: #ffaa00; font-size: 0.75rem; margin-bottom: 5px; }
        
        #commentary-text {
            color: #aaa;
            font-size: 0.8rem;
            line-height: 1.4;
            min-height: 35px;
        }
        
        .action-log {
            max-height: 60px;
            overflow-y: auto;
            font-size: 0.65rem;
            color: #666;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid #2a2a2a;
        }
        
        .action-log div { padding: 1px 0; }
        .action-log .red { color: #ff6666; }
        .action-log .blue { color: #6666ff; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü•ä NEURAL BOXING 2 ü•ä</h1>
        <div class="subtitle">Architecture Beatdown ‚Äî Now with Combos, Dodges, Clinches, Taunts & Special Moves!</div>
    </div>
    
    <div class="controls">
        <button id="btn-fight" onclick="toggleFight()">üîî START FIGHT</button>
        <button onclick="resetFight()">‚Ü∫ RESET</button>
        <button onclick="setSpeed(0.5)">0.5x</button>
        <button onclick="setSpeed(1)" class="active">1x</button>
        <button onclick="setSpeed(2)">2x</button>
        <button onclick="setSpeed(3)">3x</button>
    </div>
    
    <div class="ring-container">
        <div class="corner-panel red">
            <div class="fighter-header">
                <div class="fighter-icon" id="icon1">üß†</div>
                <div>
                    <div class="fighter-name" id="name1">TNTM</div>
                    <div class="fighter-style" id="style1">Technical Outboxer</div>
                </div>
            </div>
            
            <div class="fighter-select" id="select1">
                <div class="fighter-option selected" data-type="tntm" onclick="selectFighter(1, 'tntm')">
                    <div class="icon">üß†</div><div class="name">TNTM</div>
                </div>
                <div class="fighter-option" data-type="transformer" onclick="selectFighter(1, 'transformer')">
                    <div class="icon">‚ö°</div><div class="name">Transformer</div>
                </div>
                <div class="fighter-option" data-type="lstm" onclick="selectFighter(1, 'lstm')">
                    <div class="icon">üîÑ</div><div class="name">LSTM</div>
                </div>
                <div class="fighter-option" data-type="mlp" onclick="selectFighter(1, 'mlp')">
                    <div class="icon">üìä</div><div class="name">MLP</div>
                </div>
                <div class="fighter-option" data-type="cnn" onclick="selectFighter(1, 'cnn')">
                    <div class="icon">üëÅÔ∏è</div><div class="name">CNN</div>
                </div>
                <div class="fighter-option" data-type="gan" onclick="selectFighter(1, 'gan')">
                    <div class="icon">üé≠</div><div class="name">GAN</div>
                </div>
            </div>
            
            <div class="stat-bars">
                <div class="stat-bar">
                    <div class="label"><span>HP</span><span id="hp1-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill hp" id="hp1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>STAMINA</span><span id="stam1-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill stamina" id="stam1"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>SPECIAL</span><span id="spec1-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill special" id="spec1"></div></div>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-item"><div class="val" id="hits1">0</div>Hits</div>
                <div class="stat-item"><div class="val" id="combo1">0</div>Combo</div>
                <div class="stat-item"><div class="val" id="kd1">0</div>KDs</div>
            </div>
            
            <div class="move-list">
                <h4>Move Log</h4>
                <div class="move-item"><span class="name">Jabs</span><span class="count" id="m1-jab">0</span></div>
                <div class="move-item"><span class="name">Hooks</span><span class="count" id="m1-hook">0</span></div>
                <div class="move-item"><span class="name">Uppercuts</span><span class="count" id="m1-uppercut">0</span></div>
                <div class="move-item"><span class="name">Body Shots</span><span class="count" id="m1-body">0</span></div>
                <div class="move-item"><span class="name">Combos</span><span class="count" id="m1-combo">0</span></div>
                <div class="move-item"><span class="name">Dodges</span><span class="count" id="m1-dodge">0</span></div>
                <div class="move-item"><span class="name">Clinches</span><span class="count" id="m1-clinch">0</span></div>
                <div class="move-item"><span class="name">Taunts</span><span class="count" id="m1-taunt">0</span></div>
                <div class="move-item"><span class="name">Specials</span><span class="count" id="m1-special">0</span></div>
            </div>
            
            <div class="brain-panel">
                <h4 id="brain1-title">External Memory</h4>
                <div class="brain-viz" id="brain1"></div>
            </div>
        </div>
        
        <div class="ring" id="ring">
            <div class="ring-floor"></div>
            <div class="ropes">
                <div class="rope"></div>
                <div class="rope"></div>
                <div class="rope"></div>
                <div class="rope"></div>
            </div>
            <div class="corner-post left"></div>
            <div class="corner-post right"></div>
            
            <div class="scoreboard">
                <span class="red" id="score1">0</span>
                <span class="round" id="round-display">Round 1/12</span>
                <span class="blue" id="score2">0</span>
            </div>
            
            <div class="boxer red" id="boxer1" style="left: 100px; bottom: 150px;">
                <div class="thought-bubble" id="thought1"></div>
                <div class="boxer-body">
                    <div class="boxer-head">üß†</div>
                </div>
                <div class="glove left"></div>
                <div class="glove right"></div>
            </div>
            
            <div class="boxer blue" id="boxer2" style="left: 400px; bottom: 150px;">
                <div class="thought-bubble" id="thought2"></div>
                <div class="boxer-body">
                    <div class="boxer-head">‚ö°</div>
                </div>
                <div class="glove left"></div>
                <div class="glove right"></div>
            </div>
            
            <div class="round-banner" id="round-banner">ROUND 1</div>
            <div class="ko-banner" id="ko-banner">K.O.!</div>
        </div>
        
        <div class="corner-panel blue">
            <div class="fighter-header">
                <div class="fighter-icon" id="icon2">‚ö°</div>
                <div>
                    <div class="fighter-name" id="name2">Transformer</div>
                    <div class="fighter-style" id="style2">Aggressive Brawler</div>
                </div>
            </div>
            
            <div class="fighter-select" id="select2">
                <div class="fighter-option" data-type="tntm" onclick="selectFighter(2, 'tntm')">
                    <div class="icon">üß†</div><div class="name">TNTM</div>
                </div>
                <div class="fighter-option selected" data-type="transformer" onclick="selectFighter(2, 'transformer')">
                    <div class="icon">‚ö°</div><div class="name">Transformer</div>
                </div>
                <div class="fighter-option" data-type="lstm" onclick="selectFighter(2, 'lstm')">
                    <div class="icon">üîÑ</div><div class="name">LSTM</div>
                </div>
                <div class="fighter-option" data-type="mlp" onclick="selectFighter(2, 'mlp')">
                    <div class="icon">üìä</div><div class="name">MLP</div>
                </div>
                <div class="fighter-option" data-type="cnn" onclick="selectFighter(2, 'cnn')">
                    <div class="icon">üëÅÔ∏è</div><div class="name">CNN</div>
                </div>
                <div class="fighter-option" data-type="gan" onclick="selectFighter(2, 'gan')">
                    <div class="icon">üé≠</div><div class="name">GAN</div>
                </div>
            </div>
            
            <div class="stat-bars">
                <div class="stat-bar">
                    <div class="label"><span>HP</span><span id="hp2-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill hp" id="hp2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>STAMINA</span><span id="stam2-text">100</span></div>
                    <div class="bar-bg"><div class="bar-fill stamina" id="stam2"></div></div>
                </div>
                <div class="stat-bar">
                    <div class="label"><span>SPECIAL</span><span id="spec2-text">0%</span></div>
                    <div class="bar-bg"><div class="bar-fill special" id="spec2"></div></div>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-item"><div class="val" id="hits2">0</div>Hits</div>
                <div class="stat-item"><div class="val" id="combo2">0</div>Combo</div>
                <div class="stat-item"><div class="val" id="kd2">0</div>KDs</div>
            </div>
            
            <div class="move-list">
                <h4>Move Log</h4>
                <div class="move-item"><span class="name">Jabs</span><span class="count" id="m2-jab">0</span></div>
                <div class="move-item"><span class="name">Hooks</span><span class="count" id="m2-hook">0</span></div>
                <div class="move-item"><span class="name">Uppercuts</span><span class="count" id="m2-uppercut">0</span></div>
                <div class="move-item"><span class="name">Body Shots</span><span class="count" id="m2-body">0</span></div>
                <div class="move-item"><span class="name">Combos</span><span class="count" id="m2-combo">0</span></div>
                <div class="move-item"><span class="name">Dodges</span><span class="count" id="m2-dodge">0</span></div>
                <div class="move-item"><span class="name">Clinches</span><span class="count" id="m2-clinch">0</span></div>
                <div class="move-item"><span class="name">Taunts</span><span class="count" id="m2-taunt">0</span></div>
                <div class="move-item"><span class="name">Specials</span><span class="count" id="m2-special">0</span></div>
            </div>
            
            <div class="brain-panel">
                <h4 id="brain2-title">Attention Heads</h4>
                <div class="brain-viz" id="brain2"></div>
            </div>
        </div>
    </div>
    
    <div class="commentary">
        <h3>üì¢ RINGSIDE COMMENTARY</h3>
        <div id="commentary-text">Welcome to NEURAL BOXING 2! Select your architectures and ring the bell!</div>
        <div class="action-log" id="action-log"></div>
    </div>

    <script>
        // =============================================
        // NEURAL NETWORK BOXING BRAINS - ENHANCED
        // =============================================
        
        const MOVES = {
            jab: { damage: 4, stamina: 4, speed: 8, range: 90 },
            hook: { damage: 12, stamina: 12, speed: 18, range: 80 },
            uppercut: { damage: 18, stamina: 18, speed: 25, range: 70 },
            body: { damage: 8, stamina: 8, speed: 12, range: 85, drainStamina: 10 },
            cross: { damage: 14, stamina: 14, speed: 20, range: 95 },
            combo: { damage: 25, stamina: 25, speed: 35, range: 80 },
            clinch: { stamina: -15, speed: 30, range: 60 },
            taunt: { stamina: 5, speed: 40, specialGain: 15 },
            slip_left: { stamina: 3, speed: 10, dodge: true },
            slip_right: { stamina: 3, speed: 10, dodge: true },
            duck: { stamina: 4, speed: 12, dodge: true },
            weave: { stamina: 6, speed: 15, dodge: true },
            block: { stamina: 2, speed: 5 },
            special: { damage: 35, stamina: 30, speed: 40, range: 100, special: true }
        };
        
        class TNTMBoxer {
            constructor() {
                this.name = 'TNTM';
                this.icon = 'üß†';
                this.style = 'Technical Outboxer';
                this.specialName = 'MEMORY OVERLOAD';
                
                this.memorySlots = 32;
                this.memory = Array(32).fill(null).map(() => Array(12).fill(0));
                this.readWeights = Array(32).fill(1/32);
                this.writeHead = 0;
                this.sharpness = 2.5;
                
                this.patternBuffer = [];
                this.enemyPatterns = {};
            }
            
            write(state) {
                this.writeHead = (this.writeHead + 1) % this.memorySlots;
                for (let i = 0; i < Math.min(state.length, 12); i++) {
                    this.memory[this.writeHead][i] = this.memory[this.writeHead][i] * 0.2 + state[i] * 0.8;
                }
            }
            
            read(query) {
                const sims = this.memory.map(mem => {
                    let dot = 0, nQ = 0, nM = 0;
                    for (let j = 0; j < 12; j++) {
                        dot += (query[j] || 0) * mem[j];
                        nQ += (query[j] || 0) ** 2;
                        nM += mem[j] ** 2;
                    }
                    return dot / (Math.sqrt(nQ) * Math.sqrt(nM) + 1e-8);
                });
                
                const max = Math.max(...sims);
                const exps = sims.map(s => Math.exp((s - max) * this.sharpness));
                const sum = exps.reduce((a, b) => a + b);
                this.readWeights = exps.map(e => e / sum);
                
                return Math.max(...this.readWeights);
            }
            
            recordPattern(action) {
                this.patternBuffer.push(action);
                if (this.patternBuffer.length > 30) this.patternBuffer.shift();
                
                // Build pattern dictionary
                if (this.patternBuffer.length >= 3) {
                    const key = this.patternBuffer.slice(-3, -1).join('-');
                    const next = this.patternBuffer[this.patternBuffer.length - 1];
                    if (!this.enemyPatterns[key]) this.enemyPatterns[key] = {};
                    this.enemyPatterns[key][next] = (this.enemyPatterns[key][next] || 0) + 1;
                }
            }
            
            predictNext() {
                if (this.patternBuffer.length < 2) return null;
                const key = this.patternBuffer.slice(-2).join('-');
                const patterns = this.enemyPatterns[key];
                if (!patterns) return null;
                
                let best = null, bestCount = 0;
                for (const [action, count] of Object.entries(patterns)) {
                    if (count > bestCount) { best = action; bestCount = count; }
                }
                return best;
            }
            
            decide(me, enemy, dist) {
                const state = [
                    me.hp/100, me.stamina/100, me.special/100,
                    enemy.hp/100, enemy.stamina/100,
                    dist/300, enemy.isStunned ? 1 : 0,
                    me.comboCount/5, enemy.action === 'block' ? 1 : 0,
                    enemy.lastAction === 'jab' ? 1 : 0,
                    enemy.lastAction === 'hook' ? 1 : 0,
                    enemy.lastAction === 'uppercut' ? 1 : 0
                ];
                
                this.recordPattern(enemy.lastAction);
                this.write(state);
                const confidence = this.read(state);
                const predicted = this.predictNext();
                
                let action = { type: 'idle', move: 0, thought: '' };
                
                // Special move when charged
                if (me.special >= 100 && dist < 100) {
                    action.type = 'special';
                    action.thought = 'MEMORY OVERLOAD!';
                    return action;
                }
                
                // Counter based on prediction
                if (predicted && confidence > 0.25) {
                    if (predicted === 'jab' || predicted === 'cross') {
                        if (dist < 90) {
                            action.type = Math.random() < 0.6 ? 'slip_left' : 'hook';
                            action.thought = `Predicted ${predicted}! Counter!`;
                            return action;
                        }
                    } else if (predicted === 'hook') {
                        action.type = 'duck';
                        action.thought = 'Duck under hook!';
                        return action;
                    } else if (predicted === 'uppercut') {
                        action.type = 'slip_right';
                        action.thought = 'Slip the uppercut!';
                        return action;
                    }
                }
                
                // Low stamina recovery
                if (me.stamina < 25) {
                    if (dist < 70) {
                        action.type = 'clinch';
                        action.thought = 'Need to clinch, recovering...';
                    } else {
                        action.move = -1.5;
                        action.type = 'block';
                        action.thought = 'Backing off, low stamina';
                    }
                    return action;
                }
                
                // Stunned opponent - COMBO TIME
                if (enemy.isStunned && dist < 85) {
                    action.type = 'combo';
                    action.thought = 'STUNNED! COMBO!';
                    return action;
                }
                
                // In range fighting
                if (dist < 80 && me.stamina > 40) {
                    const r = Math.random();
                    if (r < 0.25) action.type = 'jab';
                    else if (r < 0.4) action.type = 'hook';
                    else if (r < 0.5) action.type = 'body';
                    else if (r < 0.55) action.type = 'uppercut';
                    else if (r < 0.65 && me.comboCount >= 2) action.type = 'combo';
                    else if (r < 0.75) action.type = 'cross';
                    else action.type = Math.random() < 0.5 ? 'slip_left' : 'slip_right';
                    
                    action.thought = `Conf: ${(confidence * 100).toFixed(0)}%`;
                } else if (dist > 110) {
                    action.move = 1.8;
                    if (Math.random() < 0.1) action.type = 'taunt';
                    action.thought = 'Closing distance...';
                } else {
                    action.type = Math.random() < 0.3 ? 'jab' : 'idle';
                    action.move = Math.random() < 0.5 ? 0.8 : -0.5;
                }
                
                return action;
            }
            
            renderBrain(container) {
                container.innerHTML = '';
                const grid = document.createElement('div');
                grid.className = 'memory-grid';
                
                for (let i = 0; i < this.memorySlots; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'mem-cell';
                    const w = this.readWeights[i];
                    const content = Math.sqrt(this.memory[i].reduce((a, b) => a + b*b, 0));
                    cell.style.background = `rgb(${Math.floor(255 * w)}, ${Math.floor(80 * content)}, ${Math.floor(40 * w)})`;
                    if (i === this.writeHead) cell.style.boxShadow = '0 0 3px #fff';
                    grid.appendChild(cell);
                }
                container.appendChild(grid);
            }
        }
        
        class TransformerBoxer {
            constructor() {
                this.name = 'Transformer';
                this.icon = '‚ö°';
                this.style = 'Aggressive Brawler';
                this.specialName = 'ATTENTION STORM';
                
                this.nHeads = 4;
                this.contextWindow = [];
                this.maxContext = 10;
                this.attentionWeights = Array(4).fill([]);
            }
            
            decide(me, enemy, dist) {
                const state = [me.hp/100, me.stamina/100, enemy.hp/100, dist/300, Math.random()];
                this.contextWindow.push(state);
                if (this.contextWindow.length > this.maxContext) this.contextWindow.shift();
                
                // Compute attention
                for (let h = 0; h < this.nHeads; h++) {
                    this.attentionWeights[h] = this.contextWindow.map((ctx, i) => {
                        return Math.exp(state.reduce((sum, v, j) => sum + v * ctx[j] * Math.sin(h + j), 0));
                    });
                    const sum = this.attentionWeights[h].reduce((a, b) => a + b, 0);
                    this.attentionWeights[h] = this.attentionWeights[h].map(w => w / sum);
                }
                
                let action = { type: 'idle', move: 0, thought: '' };
                
                // Special
                if (me.special >= 100 && dist < 110) {
                    action.type = 'special';
                    action.thought = 'ATTENTION STORM!';
                    return action;
                }
                
                // Transformer is AGGRESSIVE - pure reaction, rushes in
                if (enemy.action && ['jab', 'hook', 'uppercut', 'cross'].includes(enemy.action)) {
                    action.type = Math.random() < 0.4 ? 'weave' : 'block';
                    action.thought = 'Quick reaction!';
                    return action;
                }
                
                if (me.stamina < 20) {
                    action.type = Math.random() < 0.3 ? 'taunt' : 'block';
                    action.move = -1;
                    action.thought = 'Catching breath...';
                    return action;
                }
                
                if (enemy.isStunned && dist < 90) {
                    action.type = 'combo';
                    action.thought = 'ALL HEADS: ATTACK!';
                    return action;
                }
                
                if (dist < 85 && me.stamina > 35) {
                    const r = Math.random();
                    if (r < 0.3) action.type = 'jab';
                    else if (r < 0.5) action.type = 'hook';
                    else if (r < 0.6) action.type = 'cross';
                    else if (r < 0.7) action.type = 'uppercut';
                    else if (r < 0.8) action.type = 'body';
                    else if (r < 0.9) action.type = 'combo';
                    else action.type = 'taunt';
                    action.thought = 'FULL ATTENTION!';
                } else {
                    action.move = 2.2; // Fast approach
                    action.type = Math.random() < 0.2 ? 'jab' : 'idle';
                    action.thought = 'Rushing in!';
                }
                
                return action;
            }
            
            renderBrain(container) {
                container.innerHTML = '';
                const div = document.createElement('div');
                div.style.cssText = 'display:flex;gap:4px;';
                
                for (let h = 0; h < this.nHeads; h++) {
                    const head = document.createElement('div');
                    head.style.cssText = 'flex:1;height:35px;background:#1a1a2e;border-radius:3px;position:relative;overflow:hidden;';
                    const maxW = this.attentionWeights[h]?.length > 0 ? Math.max(...this.attentionWeights[h]) : 0;
                    const bar = document.createElement('div');
                    bar.style.cssText = `position:absolute;bottom:0;left:0;right:0;height:${maxW * 100}%;background:hsl(${200 + h * 40}, 80%, 50%);`;
                    head.appendChild(bar);
                    div.appendChild(head);
                }
                container.appendChild(div);
            }
        }
        
        class LSTMBoxer {
            constructor() {
                this.name = 'LSTM';
                this.icon = 'üîÑ';
                this.style = 'Patient Counter-Puncher';
                this.specialName = 'GATE OVERFLOW';
                
                this.hidden = Array(16).fill(0);
                this.cell = Array(16).fill(0);
                this.forgetGate = Array(16).fill(0.5);
                this.waitingForOpening = true;
            }
            
            step(input) {
                for (let i = 0; i < 16; i++) {
                    let f = 0, inp = 0, o = 0, c = 0;
                    input.forEach((v, j) => {
                        f += v * Math.sin(i * 7 + j * 3);
                        inp += v * Math.cos(i * 11 + j * 5);
                        o += v * Math.sin(i * 13 + j * 7);
                        c += v * Math.cos(i * 17 + j * 11);
                    });
                    
                    this.forgetGate[i] = 1 / (1 + Math.exp(-f));
                    const inputGate = 1 / (1 + Math.exp(-inp));
                    const outputGate = 1 / (1 + Math.exp(-o));
                    
                    this.cell[i] = this.forgetGate[i] * this.cell[i] + inputGate * Math.tanh(c);
                    this.hidden[i] = outputGate * Math.tanh(this.cell[i]);
                }
            }
            
            decide(me, enemy, dist) {
                this.step([me.hp/100, me.stamina/100, enemy.hp/100, enemy.stamina/100, dist/300,
                          enemy.action === 'jab' ? 1 : 0, enemy.action === 'hook' ? 1 : 0, me.special/100]);
                
                let action = { type: 'idle', move: 0, thought: '' };
                const avgForget = this.forgetGate.reduce((a, b) => a + b) / 16;
                
                if (me.special >= 100 && dist < 95) {
                    action.type = 'special';
                    action.thought = 'GATE OVERFLOW!';
                    return action;
                }
                
                // Patient counter-puncher - waits for mistakes
                if (enemy.lastAction && ['jab', 'hook', 'cross'].includes(enemy.lastAction)) {
                    if (dist < 90 && me.stamina > 30) {
                        action.type = enemy.lastAction === 'jab' ? 'cross' : 'uppercut';
                        action.thought = 'Counter!';
                        this.waitingForOpening = false;
                        return action;
                    }
                }
                
                if (enemy.isStunned) {
                    action.type = dist < 80 ? 'combo' : 'jab';
                    action.thought = 'Capitalizing!';
                    return action;
                }
                
                if (enemy.stamina < 25 && dist < 85) {
                    action.type = 'body';
                    action.thought = 'Body shot! Drain stamina!';
                    return action;
                }
                
                if (me.stamina < 30) {
                    action.type = 'clinch';
                    action.move = dist > 70 ? 1 : 0;
                    action.thought = 'Clinching to recover';
                    return action;
                }
                
                // Maintain distance, wait for opening
                if (dist < 70) {
                    action.type = Math.random() < 0.3 ? 'jab' : 'slip_right';
                    action.move = -1;
                    action.thought = 'Creating space...';
                } else if (dist > 120) {
                    action.move = 1.2;
                    action.thought = `Forget: ${(avgForget * 100).toFixed(0)}%`;
                } else {
                    action.type = Math.random() < 0.15 ? 'jab' : Math.random() < 0.1 ? 'taunt' : 'idle';
                    action.thought = 'Waiting for opening...';
                }
                
                return action;
            }
            
            renderBrain(container) {
                container.innerHTML = '';
                const neurons = document.createElement('div');
                neurons.className = 'hidden-neurons';
                
                for (let i = 0; i < 16; i++) {
                    const n = document.createElement('div');
                    n.className = 'neuron';
                    const act = 1 / (1 + Math.exp(-this.hidden[i]));
                    n.style.background = `rgb(${Math.floor(100 + 155 * this.forgetGate[i])}, ${Math.floor(200 * act)}, ${Math.floor(100 * (1 - this.forgetGate[i]))})`;
                    neurons.appendChild(n);
                }
                container.appendChild(neurons);
            }
        }
        
        class MLPBoxer {
            constructor() {
                this.name = 'MLP';
                this.icon = 'üìä';
                this.style = 'Predictable Puncher';
                this.specialName = 'GRADIENT BOMB';
                
                this.activations = Array(16).fill(0);
            }
            
            forward(input) {
                for (let i = 0; i < 16; i++) {
                    let sum = input.reduce((s, v, j) => s + v * Math.sin(i * 17 + j * 31), 0);
                    this.activations[i] = Math.max(0, sum);
                }
            }
            
            decide(me, enemy, dist) {
                this.forward([me.hp/100, me.stamina/100, enemy.hp/100, dist/300, Math.random(), me.special/100]);
                
                let action = { type: 'idle', move: 0, thought: '' };
                const active = this.activations.filter(a => a > 0).length;
                
                if (me.special >= 100 && dist < 100) {
                    action.type = 'special';
                    action.thought = 'GRADIENT BOMB!';
                    return action;
                }
                
                // MLP is simple and predictable - just reacts to immediate state
                if (dist < 75) {
                    const sum = this.activations.reduce((a, b) => a + b, 0);
                    if (sum > 2) action.type = 'hook';
                    else if (sum > 1) action.type = 'jab';
                    else action.type = 'block';
                    action.thought = `${active}/16 ReLU`;
                } else {
                    action.move = 1.5;
                    action.type = Math.random() < 0.15 ? 'jab' : 'idle';
                    action.thought = 'Feedforward approach';
                }
                
                return action;
            }
            
            renderBrain(container) {
                container.innerHTML = '';
                const neurons = document.createElement('div');
                neurons.className = 'hidden-neurons';
                
                for (let i = 0; i < 16; i++) {
                    const n = document.createElement('div');
                    n.className = 'neuron';
                    const act = Math.min(1, this.activations[i] / 2);
                    n.style.background = act > 0 ? `rgb(${Math.floor(255 * act)}, ${Math.floor(170 * act)}, 0)` : '#1a1a1a';
                    neurons.appendChild(n);
                }
                container.appendChild(neurons);
            }
        }
        
        class CNNBoxer {
            constructor() {
                this.name = 'CNN';
                this.icon = 'üëÅÔ∏è';
                this.style = 'Visual Analyst';
                this.specialName = 'KERNEL CRUSHER';
                
                this.featureMaps = Array(16).fill(0);
                this.positionHistory = [];
            }
            
            convolve(positions) {
                // Detect patterns in enemy movement
                const kernels = [[1, -1], [1, 0, -1], [1, 2, 1]];
                let features = [];
                
                kernels.forEach(kernel => {
                    let sum = 0;
                    for (let i = 0; i < Math.min(kernel.length, positions.length); i++) {
                        sum += (positions[positions.length - 1 - i] || 0) * kernel[i];
                    }
                    features.push(Math.max(0, sum));
                });
                
                return features;
            }
            
            decide(me, enemy, dist) {
                this.positionHistory.push(enemy.x || 250);
                if (this.positionHistory.length > 10) this.positionHistory.shift();
                
                const features = this.convolve(this.positionHistory);
                this.featureMaps = [...features, ...Array(13).fill(0).map(() => Math.random() * 0.5)];
                
                let action = { type: 'idle', move: 0, thought: '' };
                
                if (me.special >= 100 && dist < 100) {
                    action.type = 'special';
                    action.thought = 'KERNEL CRUSHER!';
                    return action;
                }
                
                // CNN reads visual patterns - good at predicting movement
                const movingLeft = features[0] > 0.5;
                const movingRight = features[0] < -0.5;
                
                if (enemy.isStunned && dist < 85) {
                    action.type = 'combo';
                    action.thought = 'Pattern: STUNNED!';
                    return action;
                }
                
                if (dist < 80) {
                    if (movingLeft) {
                        action.type = 'hook';
                        action.move = -0.5;
                        action.thought = 'Detected left movement!';
                    } else if (movingRight) {
                        action.type = 'cross';
                        action.move = 0.5;
                        action.thought = 'Detected right movement!';
                    } else {
                        action.type = Math.random() < 0.4 ? 'jab' : 'body';
                        action.thought = 'Scanning patterns...';
                    }
                } else {
                    action.move = 1.5;
                    if (Math.random() < 0.1) action.type = 'taunt';
                    action.thought = 'Analyzing movement...';
                }
                
                return action;
            }
            
            renderBrain(container) {
                container.innerHTML = '';
                const grid = document.createElement('div');
                grid.style.cssText = 'display:grid;grid-template-columns:repeat(4,1fr);gap:2px;';
                
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    cell.style.cssText = `width:14px;height:14px;border-radius:2px;background:rgb(0,${Math.floor(200 * Math.min(1, this.featureMaps[i]))},${Math.floor(100 * Math.min(1, this.featureMaps[i]))});`;
                    grid.appendChild(cell);
                }
                container.appendChild(grid);
            }
        }
        
        class GANBoxer {
            constructor() {
                this.name = 'GAN';
                this.icon = 'üé≠';
                this.style = 'Deceptive Trickster';
                this.specialName = 'MODE COLLAPSE';
                
                this.generatorState = Array(8).fill(0);
                this.discriminatorState = Array(8).fill(0);
                this.fakeoutMode = false;
            }
            
            decide(me, enemy, dist) {
                // Generator creates fake actions, discriminator decides real strategy
                this.generatorState = this.generatorState.map(() => Math.random());
                this.discriminatorState = [me.hp/100, enemy.hp/100, dist/300, me.stamina/100, ...Array(4).fill(0).map(() => Math.random())];
                
                let action = { type: 'idle', move: 0, thought: '' };
                
                if (me.special >= 100 && dist < 100) {
                    action.type = 'special';
                    action.thought = 'MODE COLLAPSE!';
                    return action;
                }
                
                // GAN is deceptive - lots of feints and taunts
                if (Math.random() < 0.15) {
                    action.type = 'taunt';
                    action.thought = 'Generating fake tells...';
                    this.fakeoutMode = true;
                    return action;
                }
                
                if (this.fakeoutMode && dist < 90) {
                    // After taunt, surprise attack!
                    action.type = Math.random() < 0.5 ? 'uppercut' : 'hook';
                    action.thought = 'SURPRISE!';
                    this.fakeoutMode = false;
                    return action;
                }
                
                if (enemy.isStunned) {
                    action.type = 'combo';
                    action.thought = 'Discriminator: ATTACK!';
                    return action;
                }
                
                if (dist < 80) {
                    // Mix up attacks unpredictably
                    const r = Math.random();
                    if (r < 0.2) action.type = 'jab';
                    else if (r < 0.35) action.type = 'hook';
                    else if (r < 0.45) action.type = 'body';
                    else if (r < 0.55) action.type = 'slip_left';
                    else if (r < 0.65) action.type = 'duck';
                    else if (r < 0.75) action.type = 'weave';
                    else action.type = 'clinch';
                    
                    action.thought = 'Generator: mixing up...';
                } else {
                    action.move = 1.3;
                    action.type = Math.random() < 0.2 ? 'taunt' : 'idle';
                    action.thought = 'Adversarial approach';
                }
                
                return action;
            }
            
            renderBrain(container) {
                container.innerHTML = '';
                const div = document.createElement('div');
                div.style.cssText = 'display:flex;gap:4px;';
                
                // Generator side
                const gen = document.createElement('div');
                gen.style.cssText = 'flex:1;display:flex;flex-wrap:wrap;gap:1px;';
                gen.title = 'Generator';
                for (let i = 0; i < 8; i++) {
                    const n = document.createElement('div');
                    n.style.cssText = `width:8px;height:8px;border-radius:50%;background:rgb(${Math.floor(255 * this.generatorState[i])},50,${Math.floor(200 * this.generatorState[i])});`;
                    gen.appendChild(n);
                }
                
                // Discriminator side
                const disc = document.createElement('div');
                disc.style.cssText = 'flex:1;display:flex;flex-wrap:wrap;gap:1px;';
                disc.title = 'Discriminator';
                for (let i = 0; i < 8; i++) {
                    const n = document.createElement('div');
                    n.style.cssText = `width:8px;height:8px;border-radius:50%;background:rgb(50,${Math.floor(200 * this.discriminatorState[i])},${Math.floor(255 * this.discriminatorState[i])});`;
                    disc.appendChild(n);
                }
                
                div.appendChild(gen);
                div.appendChild(disc);
                container.appendChild(div);
            }
        }
        
        // =============================================
        // GAME ENGINE
        // =============================================
        
        const brainTypes = {
            tntm: TNTMBoxer,
            transformer: TransformerBoxer,
            lstm: LSTMBoxer,
            mlp: MLPBoxer,
            cnn: CNNBoxer,
            gan: GANBoxer
        };
        
        const brainTitles = {
            tntm: 'External Memory',
            transformer: 'Attention Heads',
            lstm: 'Hidden/Forget Gates',
            mlp: 'ReLU Activations',
            cnn: 'Feature Maps',
            gan: 'Gen/Disc States'
        };
        
        let boxers = [];
        let running = false;
        let speed = 1;
        let round = 1;
        let roundTime = 0;
        let scores = [0, 0];
        let actionLog = [];
        
        const taunts = {
            tntm: ["I've memorized all your moves!", "Pattern detected: you're gonna LOSE", "My content-addressing is UNMATCHED", "Writing this L to memory!"],
            transformer: ["ATTENTION! You're about to get WRECKED!", "All heads agree: you SUCK!", "No memory needed to beat YOU!", "Self-attend to THIS!"],
            lstm: ["Forget gate says forget your dreams!", "My cell state is CHAMPION state!", "Patiently waiting to destroy you...", "Gated recurrence > your face"],
            mlp: ["Feedforward this FIST!", "Simple but DEADLY!", "ReLU(your face) = 0", "No hidden layers, all visible PAIN!"],
            cnn: ["I see RIGHT through you!", "Convolved your weakness!", "Pooling your tears!", "Feature detected: LOSER"],
            gan: ["Can't tell if this is real... YOUR DEFEAT!", "Generator says you're FAKE!", "Mode collapse? More like YOU collapse!", "Adversarially trained to WIN!"]
        };
        
        const commentary = {
            jab_hit: ["{a} lands a crisp JAB!", "Quick jab from {a}!", "POP! {a} with the jab!"],
            hook_hit: ["HOOK from {a}! {d} felt that!", "{a} with a THUNDEROUS hook!", "BOOM! What a hook!"],
            uppercut_hit: ["UPPERCUT! {a} goes UPSTAIRS!", "{a} with the uppercut from HELL!", "Rising fist CONNECTS!"],
            body_hit: ["BODY SHOT! {d}'s stamina draining!", "{a} digs into the body!", "OOF! Right in the ribs!"],
            cross_hit: ["STRAIGHT CROSS! {a} with power!", "Cross lands FLUSH!", "{a}'s cross finds the target!"],
            combo_hit: ["COMBO! {a} is UNLEASHING!", "1-2-3! {a} with the combination!", "COMBO BREAKER? No, COMBO MAKER!"],
            special_hit: ["{a}'s {s}! DEVASTATING!", "SPECIAL MOVE! {d} is ROCKED!", "{s} CONNECTS! INCREDIBLE!"],
            blocked: ["BLOCKED by {d}!", "{d}'s defense holds!", "Good block by {d}!"],
            dodged: ["{d} DODGES! Beautiful movement!", "SLIPPED! {d} saw that coming!", "WEAVE! {d} is ELUSIVE!"],
            clinch: ["{a} clinches! Ref breaks it up!", "Holding! Both fighters catching breath.", "Clinch in the center of the ring!"],
            taunt: ["{a} TAUNTS: \"{t}\"", "{a} is showing off!", "The disrespect from {a}!"],
            knockdown: ["{d} IS DOWN! {a}'s architecture DOMINATES!", "KNOCKDOWN! Can {d} beat the count?!", "TIMBER! {d} hits the canvas!"],
            ko: ["K.O.! {a} WINS by KNOCKOUT!", "{a}'s neural network is VICTORIOUS!", "TOTAL DESTRUCTION! {a} is the CHAMPION!"]
        };
        
        function log(msg, side) {
            actionLog.unshift({ msg, side });
            if (actionLog.length > 20) actionLog.pop();
            
            const logEl = document.getElementById('action-log');
            logEl.innerHTML = actionLog.slice(0, 8).map(l => 
                `<div class="${l.side || ''}">${l.msg}</div>`
            ).join('');
        }
        
        function addCommentary(type, a, d, extra = {}) {
            const templates = commentary[type];
            if (!templates) return;
            
            let text = templates[Math.floor(Math.random() * templates.length)];
            if (a) text = text.replace(/{a}/g, a.brain.name);
            if (d) text = text.replace(/{d}/g, d.brain.name);
            if (extra.special) text = text.replace(/{s}/g, extra.special);
            if (extra.taunt) text = text.replace(/{t}/g, extra.taunt);
            
            document.getElementById('commentary-text').textContent = text;
        }
        
        function showEffect(x, y, type, text) {
            const el = document.createElement('div');
            el.className = `effect ${type}`;
            el.textContent = text;
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            document.getElementById('ring').appendChild(el);
            setTimeout(() => el.remove(), type === 'taunt-bubble' ? 1500 : 600);
        }
        
        function createBoxer(id, type) {
            const BrainClass = brainTypes[type];
            const brain = new BrainClass();
            return {
                id,
                brain,
                hp: 100, maxHp: 100,
                stamina: 100, maxStamina: 100,
                special: 0,
                x: id === 1 ? 130 : 410,
                action: 'idle',
                lastAction: null,
                actionTimer: 0,
                comboCount: 0,
                hits: 0,
                knockdowns: 0,
                isDown: false,
                downTimer: 0,
                isStunned: false,
                stunTimer: 0,
                moves: { jab: 0, hook: 0, uppercut: 0, body: 0, combo: 0, dodge: 0, clinch: 0, taunt: 0, special: 0 }
            };
        }
        
        function selectFighter(slot, type) {
            document.querySelectorAll(`#select${slot} .fighter-option`).forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.type === type);
            });
            
            boxers[slot - 1] = createBoxer(slot, type);
            const b = boxers[slot - 1];
            
            document.getElementById(`name${slot}`).textContent = b.brain.name;
            document.getElementById(`style${slot}`).textContent = b.brain.style;
            document.getElementById(`icon${slot}`).textContent = b.brain.icon;
            document.getElementById(`brain${slot}-title`).textContent = brainTitles[type];
            document.getElementById(`boxer${slot}`).querySelector('.boxer-head').textContent = b.brain.icon;
            
            updateUI();
            renderBrains();
        }
        
        function processAction(attacker, defender) {
            if (attacker.actionTimer > 0 || attacker.isDown) return;
            
            const dist = Math.abs(attacker.x - defender.x);
            const decision = attacker.brain.decide(attacker, defender, dist);
            
            // Thought bubble
            const thought = document.getElementById(`thought${attacker.id}`);
            thought.textContent = decision.thought;
            thought.classList.toggle('visible', !!decision.thought);
            
            // Movement
            attacker.x = Math.max(40, Math.min(500, attacker.x + (decision.move || 0) * speed * 2 * (attacker.id === 1 ? 1 : -1)));
            
            if (decision.type === 'idle') return;
            
            const move = MOVES[decision.type];
            if (!move) return;
            
            // Check stamina
            if (attacker.stamina < (move.stamina || 0)) return;
            
            attacker.action = decision.type;
            attacker.lastAction = decision.type;
            attacker.actionTimer = (move.speed || 10) / speed;
            attacker.stamina = Math.max(0, attacker.stamina - (move.stamina || 0));
            
            // Track moves
            const moveCategory = decision.type.includes('slip') || decision.type === 'duck' || decision.type === 'weave' ? 'dodge' : decision.type;
            if (attacker.moves[moveCategory] !== undefined) attacker.moves[moveCategory]++;
            
            // Process attack
            if (move.damage && dist < (move.range || 80)) {
                // Check if defender is dodging
                if (defender.action && MOVES[defender.action]?.dodge) {
                    attacker.comboCount = 0;
                    addCommentary('dodged', attacker, defender);
                    log(`${defender.brain.name} dodges ${decision.type}!`, defender.id === 1 ? 'red' : 'blue');
                    return;
                }
                
                // Check if blocked
                if (defender.action === 'block') {
                    const blockDmg = move.damage * 0.2;
                    defender.hp -= blockDmg;
                    defender.blocks = (defender.blocks || 0) + 1;
                    showEffect(defender.x, 100, 'punch-effect', 'üõ°Ô∏è');
                    attacker.comboCount = 0;
                    if (Math.random() < 0.3) addCommentary('blocked', attacker, defender);
                    return;
                }
                
                // HIT!
                let damage = move.damage + Math.random() * 5;
                
                // Combo bonus
                if (attacker.comboCount > 0) damage *= (1 + attacker.comboCount * 0.1);
                
                defender.hp -= damage;
                attacker.hits++;
                attacker.comboCount++;
                attacker.special = Math.min(100, attacker.special + damage * 0.8);
                
                // Stamina drain from body shots
                if (move.drainStamina) defender.stamina = Math.max(0, defender.stamina - move.drainStamina);
                
                const effects = { jab: 'üí•', hook: 'üí´', uppercut: '‚≠ê', body: 'üí®', cross: '‚ú®', combo: 'üî•', special: 'üíÄ' };
                showEffect(defender.x, 80, 'punch-effect', effects[decision.type] || 'üí•');
                showEffect(defender.x + 20, 60, 'damage-text', `-${Math.floor(damage)}`);
                
                if (attacker.comboCount >= 3) {
                    showEffect(250, 150, 'combo-text', `${attacker.comboCount}x COMBO!`);
                }
                
                // Hit animation
                document.getElementById(`boxer${defender.id}`).classList.add('hit');
                setTimeout(() => document.getElementById(`boxer${defender.id}`).classList.remove('hit'), 150);
                
                // Special move effects
                if (decision.type === 'special') {
                    showEffect(defender.x, 70, 'special-effect', 'üíÄ');
                    attacker.special = 0;
                    defender.isStunned = true;
                    defender.stunTimer = 60;
                    addCommentary('special_hit', attacker, defender, { special: attacker.brain.specialName });
                    log(`${attacker.brain.name}'s ${attacker.brain.specialName}!`, attacker.id === 1 ? 'red' : 'blue');
                } else {
                    const hitType = `${decision.type}_hit`;
                    if (commentary[hitType] && Math.random() < 0.4) addCommentary(hitType, attacker, defender);
                    log(`${attacker.brain.name} hits with ${decision.type}!`, attacker.id === 1 ? 'red' : 'blue');
                }
                
                // Knockdown check
                if ((defender.hp < 25 && damage > 15) || (defender.hp < 10 && Math.random() < 0.5)) {
                    defender.isDown = true;
                    defender.downTimer = 120;
                    defender.knockdowns++;
                    attacker.comboCount = 0;
                    addCommentary('knockdown', attacker, defender);
                }
                
            } else if (decision.type === 'clinch') {
                if (dist < 70) {
                    attacker.stamina = Math.min(attacker.maxStamina, attacker.stamina + 15);
                    defender.actionTimer = 20;
                    addCommentary('clinch', attacker, defender);
                    log(`${attacker.brain.name} clinches!`, attacker.id === 1 ? 'red' : 'blue');
                }
            } else if (decision.type === 'taunt') {
                const tauntList = taunts[attacker.brain.name.toLowerCase()] || taunts.mlp;
                const taunt = tauntList[Math.floor(Math.random() * tauntList.length)];
                showEffect(attacker.x, 30, 'taunt-bubble', taunt);
                attacker.special = Math.min(100, attacker.special + 15);
                addCommentary('taunt', attacker, defender, { taunt });
                log(`${attacker.brain.name} taunts!`, attacker.id === 1 ? 'red' : 'blue');
            } else if (!move.damage) {
                attacker.comboCount = 0;
            }
        }
        
        function updateBoxer(b) {
            if (b.actionTimer > 0) b.actionTimer -= speed;
            if (b.actionTimer <= 0 && b.action !== 'idle') {
                b.action = 'idle';
            }
            
            if (b.isDown) {
                b.downTimer -= speed;
                if (b.downTimer <= 0) {
                    b.isDown = false;
                    b.hp = Math.max(b.hp, 15);
                    b.isStunned = true;
                    b.stunTimer = 30;
                }
            }
            
            if (b.isStunned) {
                b.stunTimer -= speed;
                if (b.stunTimer <= 0) b.isStunned = false;
            }
            
            if (b.action === 'idle' && !b.isDown) {
                b.stamina = Math.min(b.maxStamina, b.stamina + 0.25 * speed);
            }
            
            // Decay combo
            if (b.action === 'idle') b.comboCount = Math.max(0, b.comboCount - 0.02 * speed);
        }
        
        function renderBoxers() {
            boxers.forEach((b, i) => {
                const el = document.getElementById(`boxer${i + 1}`);
                el.style.left = `${b.x - 45}px`;
                
                // Clear all action classes
                el.className = `boxer ${i === 0 ? 'red' : 'blue'}`;
                
                if (b.isDown) el.classList.add('knocked-down');
                else if (b.isStunned) el.classList.add('stunned');
                else if (b.action === 'jab') el.classList.add('jabbing');
                else if (b.action === 'hook') el.classList.add('hooking');
                else if (b.action === 'uppercut') el.classList.add('uppercutting');
                else if (b.action === 'body') el.classList.add('body-shotting');
                else if (b.action === 'cross') el.classList.add('cross-punching');
                else if (b.action === 'combo') el.classList.add(Date.now() % 200 < 100 ? 'combo-1' : 'combo-2');
                else if (b.action === 'block') el.classList.add('blocking');
                else if (b.action === 'slip_left') el.classList.add('slipping-left');
                else if (b.action === 'slip_right') el.classList.add('slipping-right');
                else if (b.action === 'duck') el.classList.add('ducking');
                else if (b.action === 'weave') el.classList.add('weaving');
                else if (b.action === 'clinch') el.classList.add('clinching');
                else if (b.action === 'taunt') el.classList.add('taunting');
                else if (b.action === 'special') {
                    el.classList.add(b.actionTimer > 20 ? 'special-charging' : 'special-attacking');
                }
                
                if (i === 1) el.style.transform = 'scaleX(-1)';
            });
        }
        
        function renderBrains() {
            boxers.forEach((b, i) => b.brain.renderBrain(document.getElementById(`brain${i + 1}`)));
        }
        
        function updateUI() {
            boxers.forEach((b, i) => {
                const n = i + 1;
                const hpPct = Math.max(0, b.hp) / b.maxHp * 100;
                
                document.getElementById(`hp${n}`).style.width = `${hpPct}%`;
                document.getElementById(`hp${n}`).classList.toggle('low', hpPct < 30);
                document.getElementById(`hp${n}-text`).textContent = Math.floor(Math.max(0, b.hp));
                
                document.getElementById(`stam${n}`).style.width = `${Math.max(0, b.stamina)}%`;
                document.getElementById(`stam${n}-text`).textContent = Math.floor(Math.max(0, b.stamina));
                
                document.getElementById(`spec${n}`).style.width = `${b.special}%`;
                document.getElementById(`spec${n}-text`).textContent = `${Math.floor(b.special)}%`;
                
                document.getElementById(`hits${n}`).textContent = b.hits;
                document.getElementById(`combo${n}`).textContent = Math.floor(b.comboCount);
                document.getElementById(`kd${n}`).textContent = b.knockdowns;
                
                ['jab', 'hook', 'uppercut', 'body', 'combo', 'dodge', 'clinch', 'taunt', 'special'].forEach(m => {
                    document.getElementById(`m${n}-${m}`).textContent = b.moves[m];
                });
            });
            
            document.getElementById('score1').textContent = scores[0];
            document.getElementById('score2').textContent = scores[1];
            document.getElementById('round-display').textContent = `Round ${round}/12`;
        }
        
        function checkRoundEnd() {
            for (let i = 0; i < 2; i++) {
                if (boxers[i].hp <= 0) {
                    running = false;
                    scores[1 - i]++;
                    document.getElementById('ko-banner').classList.add('visible');
                    addCommentary('ko', boxers[1 - i], boxers[i]);
                    document.getElementById('btn-fight').textContent = 'üîî NEW FIGHT';
                    return true;
                }
            }
            
            roundTime += speed;
            if (roundTime > 800) {
                round++;
                roundTime = 0;
                
                if (round > 12) {
                    running = false;
                    const winner = scores[0] > scores[1] ? boxers[0] : scores[1] > scores[0] ? boxers[1] : null;
                    document.getElementById('commentary-text').textContent = winner ?
                        `DECISION! ${winner.brain.name} wins ${Math.max(scores[0], scores[1])}-${Math.min(scores[0], scores[1])}!` :
                        'DRAW! Both architectures are evenly matched!';
                    document.getElementById('btn-fight').textContent = 'üîî NEW FIGHT';
                    return true;
                }
                
                // Score round
                const dmg0 = boxers[0].hits + boxers[0].knockdowns * 3;
                const dmg1 = boxers[1].hits + boxers[1].knockdowns * 3;
                if (dmg0 > dmg1 + 2) scores[0]++;
                else if (dmg1 > dmg0 + 2) scores[1]++;
                
                // Reset for new round
                boxers.forEach(b => {
                    b.hp = Math.min(b.maxHp, b.hp + 15);
                    b.stamina = b.maxStamina;
                    b.x = b.id === 1 ? 130 : 410;
                    b.isDown = false;
                    b.isStunned = false;
                });
                
                document.getElementById('round-banner').textContent = `ROUND ${round}`;
                document.getElementById('round-banner').classList.add('visible');
                setTimeout(() => document.getElementById('round-banner').classList.remove('visible'), 1800);
            }
            
            return false;
        }
        
        function gameLoop() {
            if (!running) return;
            
            processAction(boxers[0], boxers[1]);
            processAction(boxers[1], boxers[0]);
            
            boxers.forEach(updateBoxer);
            
            renderBoxers();
            renderBrains();
            updateUI();
            
            if (!checkRoundEnd()) requestAnimationFrame(gameLoop);
        }
        
        function toggleFight() {
            if (boxers.some(b => b.hp <= 0) || round > 12) {
                resetFight();
                return;
            }
            
            running = !running;
            document.getElementById('btn-fight').textContent = running ? '‚è∏ PAUSE' : 'üîî CONTINUE';
            
            if (running) {
                if (roundTime === 0 && round === 1) {
                    document.getElementById('round-banner').textContent = 'ROUND 1';
                    document.getElementById('round-banner').classList.add('visible');
                    setTimeout(() => document.getElementById('round-banner').classList.remove('visible'), 1800);
                }
                requestAnimationFrame(gameLoop);
            }
        }
        
        function resetFight() {
            running = false;
            round = 1;
            roundTime = 0;
            scores = [0, 0];
            actionLog = [];
            
            document.getElementById('ko-banner').classList.remove('visible');
            document.getElementById('btn-fight').textContent = 'üîî START FIGHT';
            document.getElementById('action-log').innerHTML = '';
            
            const type1 = document.querySelector('#select1 .selected').dataset.type;
            const type2 = document.querySelector('#select2 .selected').dataset.type;
            
            boxers = [createBoxer(1, type1), createBoxer(2, type2)];
            
            renderBoxers();
            renderBrains();
            updateUI();
            
            document.getElementById('commentary-text').textContent = 
                `${boxers[0].brain.name} (${boxers[0].brain.style}) vs ${boxers[1].brain.name} (${boxers[1].brain.style})! FIGHT!`;
        }
        
        function setSpeed(s) {
            speed = s;
            document.querySelectorAll('.controls button').forEach(btn => {
                if (btn.textContent.includes('x')) btn.classList.toggle('active', btn.textContent === `${s}x`);
            });
        }
        
        // Initialize
        boxers = [createBoxer(1, 'tntm'), createBoxer(2, 'transformer')];
        renderBoxers();
        renderBrains();
        updateUI();
    </script>
</body>
</html>
