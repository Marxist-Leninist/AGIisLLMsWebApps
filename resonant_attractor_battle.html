<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Wars: Transformer vs Resonant Attractor Network</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
            font-size: 2em;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .hypothesis {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid #4ecdc4;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.85em;
            line-height: 1.5;
        }
        .hypothesis h3 { color: #4ecdc4; margin-bottom: 8px; }
        .game-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .team-panel {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid;
        }
        .transformer-panel { border-color: #ff6b6b; }
        .ran-panel { border-color: #4ecdc4; }
        .team-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .team-name {
            font-size: 1.3em;
            font-weight: bold;
        }
        .transformer-panel .team-name { color: #ff6b6b; }
        .ran-panel .team-name { color: #4ecdc4; }
        .score {
            font-size: 2em;
            font-weight: bold;
        }
        canvas {
            width: 100%;
            height: 400px;
            background: #0a0a12;
            border-radius: 8px;
            display: block;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
            font-size: 0.8em;
        }
        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-label { color: #888; font-size: 0.85em; }
        .stat-value { font-size: 1.2em; font-weight: bold; }
        .neural-viz {
            height: 120px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        button {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            color: #000;
            padding: 12px 25px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(78,205,196,0.5); }
        button.reset { background: linear-gradient(135deg, #ff6b6b, #ee5a5a); }
        .log-panel {
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.75em;
            line-height: 1.6;
        }
        .log-entry { border-bottom: 1px solid rgba(255,255,255,0.1); padding: 3px 0; }
        .log-transformer { color: #ff6b6b; }
        .log-ran { color: #4ecdc4; }
        .log-system { color: #888; }
        .global-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .global-stat {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .global-stat .value {
            font-size: 2em;
            font-weight: bold;
        }
        .winner-transformer { color: #ff6b6b; }
        .winner-ran { color: #4ecdc4; }
        .tie { color: #ffd700; }
        .physics-readout {
            font-size: 0.7em;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚öîÔ∏è NEURAL ARCHITECTURE WARS ‚öîÔ∏è</h1>
        <h2 style="text-align:center; color:#888; margin-bottom:15px; font-size:0.9em;">Transformer vs Resonant Attractor Network (Novel Hypothesis)</h2>
        
        <div class="hypothesis">
            <h3>üî¨ THE HYPOTHESIS</h3>
            <p><strong>Resonant Attractor Networks (RAN)</strong> ‚Äî my novel architecture ‚Äî should dominate Transformers in real-time control tasks.</p>
            <p><strong>Physics basis:</strong> Each RAN neuron is a damped harmonic oscillator. Computation = letting the coupled system evolve to its attractor state. "Attention" emerges naturally through resonance synchronization between oscillators with matching frequencies ‚Äî O(1) once steady state is reached vs Transformer's explicit O(n¬≤) attention.</p>
            <p><strong>Key advantages:</strong> Continuous-time dynamics (infinite effective depth), natural temporal integration, phase-encoded information, energy minimization as implicit optimization.</p>
        </div>

        <div class="controls">
            <button onclick="startSimulation()">‚ñ∂ START BATTLE</button>
            <button onclick="pauseSimulation()">‚è∏ PAUSE</button>
            <button onclick="resetSimulation()" class="reset">üîÑ RESET</button>
            <button onclick="speedUp()">‚ö° SPEED UP</button>
        </div>

        <div class="global-stats">
            <div class="global-stat">
                <div class="stat-label">Battles Won</div>
                <div class="value" id="transformer-wins">0</div>
                <div style="color:#ff6b6b;">Transformer</div>
            </div>
            <div class="global-stat">
                <div class="stat-label">Battles Won</div>
                <div class="value" id="ran-wins">0</div>
                <div style="color:#4ecdc4;">RAN</div>
            </div>
            <div class="global-stat">
                <div class="stat-label">Round</div>
                <div class="value" id="round-num">1</div>
                <div style="color:#888;">of ‚àû</div>
            </div>
            <div class="global-stat">
                <div class="stat-label">Win Rate</div>
                <div class="value" id="ran-winrate">--</div>
                <div style="color:#4ecdc4;">RAN Dominance</div>
            </div>
        </div>

        <div class="game-area">
            <div class="team-panel transformer-panel">
                <div class="team-header">
                    <span class="team-name">üî¥ TRANSFORMER</span>
                    <span class="score" id="t-score">0</span>
                </div>
                <canvas id="transformer-canvas"></canvas>
                <div class="neural-viz" id="transformer-viz"></div>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Agents</div>
                        <div class="stat-value" id="t-agents">5</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Resources</div>
                        <div class="stat-value" id="t-resources">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Kills</div>
                        <div class="stat-value" id="t-kills">0</div>
                    </div>
                </div>
                <div class="physics-readout">
                    Attention Ops: <span id="t-attention-ops">0</span> | 
                    Compute: O(n¬≤) per step | 
                    Layers: 4 | Heads: 4
                </div>
            </div>

            <div class="team-panel ran-panel">
                <div class="team-header">
                    <span class="team-name">üü¢ RESONANT ATTRACTOR</span>
                    <span class="score" id="r-score">0</span>
                </div>
                <canvas id="ran-canvas"></canvas>
                <div class="neural-viz" id="ran-viz"></div>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Agents</div>
                        <div class="stat-value" id="r-agents">5</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Resources</div>
                        <div class="stat-value" id="r-resources">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Kills</div>
                        <div class="stat-value" id="r-kills">0</div>
                    </div>
                </div>
                <div class="physics-readout">
                    Resonance Sync: <span id="r-sync">0%</span> | 
                    Compute: O(n) per step | 
                    Oscillators: 32 | œâ range: 0.1-2.0
                </div>
            </div>
        </div>

        <div class="log-panel" id="log">
            <div class="log-entry log-system">‚öôÔ∏è Neural Architecture Wars initialized...</div>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            ARENA_SIZE: 400,
            INITIAL_AGENTS: 5,
            INITIAL_RESOURCES: 15,
            RESOURCE_SPAWN_RATE: 0.02,
            MAX_RESOURCES: 25,
            AGENT_SPEED: 2.5,
            AGENT_SIZE: 8,
            RESOURCE_SIZE: 6,
            ATTACK_RANGE: 20,
            ATTACK_DAMAGE: 0.15,
            RESOURCE_HEAL: 0.3,
            WIN_SCORE: 50,
            TIMESTEP: 1/60
        };

        // ============================================
        // TRANSFORMER NEURAL NETWORK
        // Classical attention-based architecture
        // ============================================
        class TransformerBrain {
            constructor(inputDim, hiddenDim, numHeads, numLayers) {
                this.inputDim = inputDim;
                this.hiddenDim = hiddenDim;
                this.numHeads = numHeads;
                this.numLayers = numLayers;
                this.headDim = Math.floor(hiddenDim / numHeads);
                this.attentionOps = 0;
                
                // Initialize weights randomly
                this.weights = {
                    Wq: [], Wk: [], Wv: [], Wo: [],
                    ff1: [], ff2: [],
                    inputProj: this.randomMatrix(inputDim, hiddenDim),
                    outputProj: this.randomMatrix(hiddenDim, 4) // 4 actions
                };
                
                for (let l = 0; l < numLayers; l++) {
                    this.weights.Wq.push(this.randomMatrix(hiddenDim, hiddenDim));
                    this.weights.Wk.push(this.randomMatrix(hiddenDim, hiddenDim));
                    this.weights.Wv.push(this.randomMatrix(hiddenDim, hiddenDim));
                    this.weights.Wo.push(this.randomMatrix(hiddenDim, hiddenDim));
                    this.weights.ff1.push(this.randomMatrix(hiddenDim, hiddenDim * 4));
                    this.weights.ff2.push(this.randomMatrix(hiddenDim * 4, hiddenDim));
                }
            }
            
            randomMatrix(rows, cols) {
                const scale = Math.sqrt(2.0 / (rows + cols));
                return Array(rows).fill().map(() => 
                    Array(cols).fill().map(() => (Math.random() - 0.5) * scale)
                );
            }
            
            matmul(A, B) {
                const rowsA = A.length, colsA = A[0].length;
                const colsB = B[0].length;
                const result = Array(rowsA).fill().map(() => Array(colsB).fill(0));
                for (let i = 0; i < rowsA; i++) {
                    for (let j = 0; j < colsB; j++) {
                        for (let k = 0; k < colsA; k++) {
                            result[i][j] += A[i][k] * B[k][j];
                        }
                    }
                }
                return result;
            }
            
            softmax(arr) {
                const max = Math.max(...arr);
                const exps = arr.map(x => Math.exp(x - max));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(x => x / sum);
            }
            
            gelu(x) {
                return 0.5 * x * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * x * x * x)));
            }
            
            layerNorm(vec) {
                const mean = vec.reduce((a, b) => a + b, 0) / vec.length;
                const variance = vec.reduce((a, b) => a + (b - mean) ** 2, 0) / vec.length;
                const std = Math.sqrt(variance + 1e-5);
                return vec.map(x => (x - mean) / std);
            }
            
            attention(Q, K, V) {
                // Q, K, V are already single vectors for our use case
                // Compute attention score
                const scores = [];
                const scale = Math.sqrt(Q.length);
                
                // Self-attention over sequence (we treat input features as sequence)
                for (let i = 0; i < K.length; i++) {
                    let score = 0;
                    for (let j = 0; j < Q.length; j++) {
                        score += Q[j] * K[j];
                    }
                    scores.push(score / scale);
                    this.attentionOps++;
                }
                
                const attnWeights = this.softmax(scores);
                
                // Weighted sum
                const output = Array(V.length).fill(0);
                for (let i = 0; i < V.length; i++) {
                    for (let j = 0; j < attnWeights.length; j++) {
                        output[i] += attnWeights[j] * V[i];
                    }
                }
                
                return output;
            }
            
            forward(input) {
                // Project input to hidden dimension
                let hidden = Array(this.hiddenDim).fill(0);
                for (let i = 0; i < this.hiddenDim; i++) {
                    for (let j = 0; j < input.length; j++) {
                        hidden[i] += input[j] * this.weights.inputProj[j][i];
                    }
                    hidden[i] = Math.tanh(hidden[i]);
                }
                
                // Transformer layers
                for (let l = 0; l < this.numLayers; l++) {
                    // Multi-head attention (simplified)
                    let Q = Array(this.hiddenDim).fill(0);
                    let K = Array(this.hiddenDim).fill(0);
                    let V = Array(this.hiddenDim).fill(0);
                    
                    for (let i = 0; i < this.hiddenDim; i++) {
                        for (let j = 0; j < this.hiddenDim; j++) {
                            Q[i] += hidden[j] * this.weights.Wq[l][j][i];
                            K[i] += hidden[j] * this.weights.Wk[l][j][i];
                            V[i] += hidden[j] * this.weights.Wv[l][j][i];
                        }
                    }
                    
                    // Attention
                    let attnOut = this.attention(Q, K, V);
                    
                    // Output projection
                    let projected = Array(this.hiddenDim).fill(0);
                    for (let i = 0; i < this.hiddenDim; i++) {
                        for (let j = 0; j < this.hiddenDim; j++) {
                            projected[i] += attnOut[j] * this.weights.Wo[l][j][i];
                        }
                    }
                    
                    // Residual connection + layer norm
                    hidden = this.layerNorm(hidden.map((h, i) => h + projected[i]));
                    
                    // Feed-forward network
                    let ff = Array(this.hiddenDim * 4).fill(0);
                    for (let i = 0; i < this.hiddenDim * 4; i++) {
                        for (let j = 0; j < this.hiddenDim; j++) {
                            ff[i] += hidden[j] * this.weights.ff1[l][j][i];
                        }
                        ff[i] = this.gelu(ff[i]);
                    }
                    
                    let ffOut = Array(this.hiddenDim).fill(0);
                    for (let i = 0; i < this.hiddenDim; i++) {
                        for (let j = 0; j < this.hiddenDim * 4; j++) {
                            ffOut[i] += ff[j] * this.weights.ff2[l][j][i];
                        }
                    }
                    
                    hidden = this.layerNorm(hidden.map((h, i) => h + ffOut[i]));
                }
                
                // Output projection to actions
                let output = Array(4).fill(0);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < this.hiddenDim; j++) {
                        output[i] += hidden[j] * this.weights.outputProj[j][i];
                    }
                }
                
                return this.softmax(output);
            }
        }

        // ============================================
        // RESONANT ATTRACTOR NETWORK (NOVEL HYPOTHESIS)
        // Continuous-time dynamical system with coupled oscillators
        // ============================================
        class ResonantAttractorNetwork {
            constructor(numOscillators, inputDim) {
                this.numOscillators = numOscillators;
                this.inputDim = inputDim;
                this.syncLevel = 0;
                
                // Each oscillator has position, velocity, and natural frequency
                this.oscillators = [];
                for (let i = 0; i < numOscillators; i++) {
                    this.oscillators.push({
                        x: (Math.random() - 0.5) * 2,      // position
                        v: (Math.random() - 0.5) * 0.5,    // velocity
                        omega: 0.1 + Math.random() * 1.9,  // natural frequency
                        phase: Math.random() * Math.PI * 2 // phase
                    });
                }
                
                // Coupling matrix (sparse, learned structure)
                this.coupling = [];
                for (let i = 0; i < numOscillators; i++) {
                    this.coupling.push([]);
                    for (let j = 0; j < numOscillators; j++) {
                        // Random sparse coupling with distance-based structure
                        const dist = Math.abs(i - j);
                        const prob = Math.exp(-dist * 0.1);
                        this.coupling[i].push(Math.random() < prob ? (Math.random() - 0.5) * 0.5 : 0);
                    }
                }
                
                // Input projection (how inputs affect oscillator states)
                this.inputWeights = [];
                for (let i = 0; i < numOscillators; i++) {
                    this.inputWeights.push([]);
                    for (let j = 0; j < inputDim; j++) {
                        this.inputWeights[i].push((Math.random() - 0.5) * 0.3);
                    }
                }
                
                // Output readout (which oscillators map to which actions)
                this.outputWeights = [];
                for (let i = 0; i < 4; i++) {
                    this.outputWeights.push([]);
                    for (let j = 0; j < numOscillators; j++) {
                        this.outputWeights[i].push((Math.random() - 0.5) * 0.5);
                    }
                }
                
                // Damping and nonlinearity parameters
                this.damping = 0.1;
                this.nonlinearity = 0.3;
                this.dt = 0.1; // integration timestep
                this.settleSteps = 20; // steps to reach attractor
            }
            
            // Core dynamics: coupled damped oscillators with nonlinear damping
            step(input) {
                // Apply input as forcing terms
                const forcing = [];
                for (let i = 0; i < this.numOscillators; i++) {
                    let f = 0;
                    for (let j = 0; j < input.length; j++) {
                        f += input[j] * this.inputWeights[i][j];
                    }
                    forcing.push(f);
                }
                
                // Compute accelerations from spring forces + coupling + forcing
                const accelerations = [];
                for (let i = 0; i < this.numOscillators; i++) {
                    const osc = this.oscillators[i];
                    
                    // Spring force (toward origin)
                    let a = -osc.omega * osc.omega * osc.x;
                    
                    // Damping (nonlinear - velocity-dependent)
                    a -= this.damping * osc.v * (1 + this.nonlinearity * osc.v * osc.v);
                    
                    // Coupling forces from other oscillators
                    for (let j = 0; j < this.numOscillators; j++) {
                        if (i !== j && this.coupling[i][j] !== 0) {
                            // Resonant coupling: depends on phase difference
                            const phaseDiff = this.oscillators[j].phase - osc.phase;
                            a += this.coupling[i][j] * Math.sin(phaseDiff) * this.oscillators[j].x;
                        }
                    }
                    
                    // External forcing from input
                    a += forcing[i];
                    
                    accelerations.push(a);
                }
                
                // Symplectic integration (velocity Verlet for energy conservation)
                for (let i = 0; i < this.numOscillators; i++) {
                    const osc = this.oscillators[i];
                    
                    // Half-step velocity
                    osc.v += 0.5 * accelerations[i] * this.dt;
                    
                    // Full-step position
                    osc.x += osc.v * this.dt;
                    
                    // Update phase
                    osc.phase += osc.omega * this.dt;
                    if (osc.phase > Math.PI * 2) osc.phase -= Math.PI * 2;
                    
                    // Half-step velocity (with updated position)
                    osc.v += 0.5 * accelerations[i] * this.dt;
                }
            }
            
            // Measure synchronization (emergent "attention")
            measureSync() {
                // Kuramoto order parameter: measures phase coherence
                let realSum = 0, imagSum = 0;
                for (let i = 0; i < this.numOscillators; i++) {
                    realSum += Math.cos(this.oscillators[i].phase);
                    imagSum += Math.sin(this.oscillators[i].phase);
                }
                realSum /= this.numOscillators;
                imagSum /= this.numOscillators;
                return Math.sqrt(realSum * realSum + imagSum * imagSum);
            }
            
            forward(input) {
                // Let the system evolve to its attractor
                for (let s = 0; s < this.settleSteps; s++) {
                    this.step(input);
                }
                
                // Measure synchronization
                this.syncLevel = this.measureSync();
                
                // Read out from oscillator states
                const output = [0, 0, 0, 0];
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < this.numOscillators; j++) {
                        // Use both position and phase information
                        output[i] += this.outputWeights[i][j] * 
                            (this.oscillators[j].x * Math.cos(this.oscillators[j].phase));
                    }
                }
                
                // Softmax for action probabilities
                const max = Math.max(...output);
                const exps = output.map(x => Math.exp(x - max));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(x => x / sum);
            }
            
            // Get oscillator states for visualization
            getStates() {
                return this.oscillators.map(o => ({
                    x: o.x,
                    v: o.v,
                    phase: o.phase,
                    omega: o.omega
                }));
            }
        }

        // ============================================
        // GAME ENTITIES
        // ============================================
        class Agent {
            constructor(x, y, team, brain) {
                this.x = x;
                this.y = y;
                this.team = team;
                this.brain = brain;
                this.health = 1.0;
                this.vx = 0;
                this.vy = 0;
                this.alive = true;
                this.target = null;
            }
            
            getObservation(resources, enemies, allies) {
                // Construct observation vector
                const obs = [];
                
                // Own state
                obs.push(this.x / CONFIG.ARENA_SIZE);
                obs.push(this.y / CONFIG.ARENA_SIZE);
                obs.push(this.health);
                obs.push(this.vx / CONFIG.AGENT_SPEED);
                obs.push(this.vy / CONFIG.AGENT_SPEED);
                
                // Nearest resource
                let nearestRes = null, nearestResDist = Infinity;
                for (const r of resources) {
                    const d = Math.hypot(r.x - this.x, r.y - this.y);
                    if (d < nearestResDist) {
                        nearestResDist = d;
                        nearestRes = r;
                    }
                }
                if (nearestRes) {
                    obs.push((nearestRes.x - this.x) / CONFIG.ARENA_SIZE);
                    obs.push((nearestRes.y - this.y) / CONFIG.ARENA_SIZE);
                    obs.push(nearestResDist / CONFIG.ARENA_SIZE);
                } else {
                    obs.push(0, 0, 1);
                }
                
                // Nearest enemy
                let nearestEnemy = null, nearestEnemyDist = Infinity;
                for (const e of enemies) {
                    if (!e.alive) continue;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < nearestEnemyDist) {
                        nearestEnemyDist = d;
                        nearestEnemy = e;
                    }
                }
                if (nearestEnemy) {
                    obs.push((nearestEnemy.x - this.x) / CONFIG.ARENA_SIZE);
                    obs.push((nearestEnemy.y - this.y) / CONFIG.ARENA_SIZE);
                    obs.push(nearestEnemyDist / CONFIG.ARENA_SIZE);
                    obs.push(nearestEnemy.health);
                    this.target = nearestEnemy;
                } else {
                    obs.push(0, 0, 1, 0);
                    this.target = null;
                }
                
                // Nearest ally
                let nearestAlly = null, nearestAllyDist = Infinity;
                for (const a of allies) {
                    if (!a.alive || a === this) continue;
                    const d = Math.hypot(a.x - this.x, a.y - this.y);
                    if (d < nearestAllyDist) {
                        nearestAllyDist = d;
                        nearestAlly = a;
                    }
                }
                if (nearestAlly) {
                    obs.push((nearestAlly.x - this.x) / CONFIG.ARENA_SIZE);
                    obs.push((nearestAlly.y - this.y) / CONFIG.ARENA_SIZE);
                } else {
                    obs.push(0, 0);
                }
                
                // Team statistics
                const aliveAllies = allies.filter(a => a.alive).length;
                const aliveEnemies = enemies.filter(e => e.alive).length;
                obs.push(aliveAllies / CONFIG.INITIAL_AGENTS);
                obs.push(aliveEnemies / CONFIG.INITIAL_AGENTS);
                obs.push(resources.length / CONFIG.MAX_RESOURCES);
                
                return obs;
            }
            
            update(resources, enemies, allies) {
                if (!this.alive) return;
                
                const obs = this.getObservation(resources, enemies, allies);
                const actionProbs = this.brain.forward(obs);
                
                // Sample action (or take argmax for deterministic behavior)
                const r = Math.random();
                let cumProb = 0;
                let action = 0;
                for (let i = 0; i < actionProbs.length; i++) {
                    cumProb += actionProbs[i];
                    if (r < cumProb) {
                        action = i;
                        break;
                    }
                }
                
                // Actions: 0=seek resource, 1=attack enemy, 2=flee, 3=patrol
                let targetX = this.x, targetY = this.y;
                
                if (action === 0 && resources.length > 0) {
                    // Move toward nearest resource
                    let nearest = null, nearestDist = Infinity;
                    for (const r of resources) {
                        const d = Math.hypot(r.x - this.x, r.y - this.y);
                        if (d < nearestDist) {
                            nearestDist = d;
                            nearest = r;
                        }
                    }
                    if (nearest) {
                        targetX = nearest.x;
                        targetY = nearest.y;
                    }
                } else if (action === 1 && this.target) {
                    // Attack nearest enemy
                    targetX = this.target.x;
                    targetY = this.target.y;
                } else if (action === 2 && this.target) {
                    // Flee from enemy
                    const dx = this.x - this.target.x;
                    const dy = this.y - this.target.y;
                    const d = Math.hypot(dx, dy) || 1;
                    targetX = this.x + (dx / d) * 50;
                    targetY = this.y + (dy / d) * 50;
                } else {
                    // Patrol randomly
                    targetX = this.x + (Math.random() - 0.5) * 100;
                    targetY = this.y + (Math.random() - 0.5) * 100;
                }
                
                // Move toward target
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const d = Math.hypot(dx, dy) || 1;
                
                this.vx = (dx / d) * CONFIG.AGENT_SPEED;
                this.vy = (dy / d) * CONFIG.AGENT_SPEED;
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary wrapping
                if (this.x < 0) this.x = CONFIG.ARENA_SIZE;
                if (this.x > CONFIG.ARENA_SIZE) this.x = 0;
                if (this.y < 0) this.y = CONFIG.ARENA_SIZE;
                if (this.y > CONFIG.ARENA_SIZE) this.y = 0;
                
                // Attack enemies in range
                for (const e of enemies) {
                    if (!e.alive) continue;
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist < CONFIG.ATTACK_RANGE) {
                        e.health -= CONFIG.ATTACK_DAMAGE;
                        if (e.health <= 0) {
                            e.alive = false;
                        }
                    }
                }
                
                // Collect resources
                for (let i = resources.length - 1; i >= 0; i--) {
                    const r = resources[i];
                    const dist = Math.hypot(r.x - this.x, r.y - this.y);
                    if (dist < CONFIG.AGENT_SIZE + CONFIG.RESOURCE_SIZE) {
                        this.health = Math.min(1.0, this.health + CONFIG.RESOURCE_HEAL);
                        resources.splice(i, 1);
                        return true; // Collected resource
                    }
                }
                
                return false;
            }
        }

        // ============================================
        // GAME STATE
        // ============================================
        let transformerAgents = [];
        let ranAgents = [];
        let resources = [];
        let transformerScore = 0;
        let ranScore = 0;
        let transformerKills = 0;
        let ranKills = 0;
        let transformerWins = 0;
        let ranWins = 0;
        let roundNum = 1;
        let running = false;
        let animationId = null;
        let speed = 1;

        const tCanvas = document.getElementById('transformer-canvas');
        const rCanvas = document.getElementById('ran-canvas');
        const tCtx = tCanvas.getContext('2d');
        const rCtx = rCanvas.getContext('2d');

        function resizeCanvas() {
            const rect = tCanvas.getBoundingClientRect();
            tCanvas.width = rect.width;
            tCanvas.height = rect.height;
            rCanvas.width = rect.width;
            rCanvas.height = rect.height;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function initRound() {
            transformerAgents = [];
            ranAgents = [];
            resources = [];
            transformerScore = 0;
            ranScore = 0;
            transformerKills = 0;
            ranKills = 0;
            
            const INPUT_DIM = 19;
            
            // Create agents with their neural networks
            for (let i = 0; i < CONFIG.INITIAL_AGENTS; i++) {
                // Transformer agents
                const tBrain = new TransformerBrain(INPUT_DIM, 32, 4, 4);
                const tx = Math.random() * CONFIG.ARENA_SIZE * 0.3 + CONFIG.ARENA_SIZE * 0.1;
                const ty = Math.random() * CONFIG.ARENA_SIZE * 0.8 + CONFIG.ARENA_SIZE * 0.1;
                transformerAgents.push(new Agent(tx, ty, 'transformer', tBrain));
                
                // RAN agents
                const rBrain = new ResonantAttractorNetwork(32, INPUT_DIM);
                const rx = Math.random() * CONFIG.ARENA_SIZE * 0.3 + CONFIG.ARENA_SIZE * 0.6;
                const ry = Math.random() * CONFIG.ARENA_SIZE * 0.8 + CONFIG.ARENA_SIZE * 0.1;
                ranAgents.push(new Agent(rx, ry, 'ran', rBrain));
            }
            
            // Spawn initial resources
            for (let i = 0; i < CONFIG.INITIAL_RESOURCES; i++) {
                resources.push({
                    x: Math.random() * CONFIG.ARENA_SIZE,
                    y: Math.random() * CONFIG.ARENA_SIZE
                });
            }
            
            log(`‚öîÔ∏è Round ${roundNum} begins! Transformer vs RAN`, 'system');
        }

        function log(message, type = 'system') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = message;
            logEl.insertBefore(entry, logEl.firstChild);
            if (logEl.children.length > 50) {
                logEl.removeChild(logEl.lastChild);
            }
        }

        function updateStats() {
            document.getElementById('t-score').textContent = transformerScore;
            document.getElementById('r-score').textContent = ranScore;
            document.getElementById('t-agents').textContent = transformerAgents.filter(a => a.alive).length;
            document.getElementById('r-agents').textContent = ranAgents.filter(a => a.alive).length;
            document.getElementById('t-resources').textContent = transformerScore;
            document.getElementById('r-resources').textContent = ranScore;
            document.getElementById('t-kills').textContent = transformerKills;
            document.getElementById('r-kills').textContent = ranKills;
            document.getElementById('transformer-wins').textContent = transformerWins;
            document.getElementById('ran-wins').textContent = ranWins;
            document.getElementById('round-num').textContent = roundNum;
            
            // Attention ops counter
            let totalAttentionOps = 0;
            for (const a of transformerAgents) {
                totalAttentionOps += a.brain.attentionOps;
            }
            document.getElementById('t-attention-ops').textContent = totalAttentionOps.toLocaleString();
            
            // RAN sync level
            let avgSync = 0;
            for (const a of ranAgents) {
                if (a.alive) avgSync += a.brain.syncLevel;
            }
            avgSync /= ranAgents.filter(a => a.alive).length || 1;
            document.getElementById('r-sync').textContent = (avgSync * 100).toFixed(1) + '%';
            
            // Win rate
            const total = transformerWins + ranWins;
            if (total > 0) {
                document.getElementById('ran-winrate').textContent = 
                    ((ranWins / total) * 100).toFixed(1) + '%';
            }
        }

        function draw() {
            const scale = tCanvas.width / CONFIG.ARENA_SIZE;
            
            // Clear canvases
            tCtx.fillStyle = '#0a0a12';
            tCtx.fillRect(0, 0, tCanvas.width, tCanvas.height);
            rCtx.fillStyle = '#0a0a12';
            rCtx.fillRect(0, 0, rCanvas.width, rCanvas.height);
            
            // Draw resources on both canvases
            for (const res of resources) {
                tCtx.fillStyle = '#ffd700';
                tCtx.beginPath();
                tCtx.arc(res.x * scale, res.y * scale, CONFIG.RESOURCE_SIZE * scale, 0, Math.PI * 2);
                tCtx.fill();
                
                rCtx.fillStyle = '#ffd700';
                rCtx.beginPath();
                rCtx.arc(res.x * scale, res.y * scale, CONFIG.RESOURCE_SIZE * scale, 0, Math.PI * 2);
                rCtx.fill();
            }
            
            // Draw agents
            function drawAgent(ctx, agent, color, enemyColor) {
                if (!agent.alive) return;
                
                const x = agent.x * scale;
                const y = agent.y * scale;
                const r = CONFIG.AGENT_SIZE * scale;
                
                // Health bar background
                ctx.fillStyle = '#333';
                ctx.fillRect(x - r, y - r - 8, r * 2, 4);
                
                // Health bar
                ctx.fillStyle = agent.health > 0.3 ? '#4ecdc4' : '#ff6b6b';
                ctx.fillRect(x - r, y - r - 8, r * 2 * agent.health, 4);
                
                // Agent body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Direction indicator
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                const angle = Math.atan2(agent.vy, agent.vx);
                ctx.lineTo(x + Math.cos(angle) * r * 1.5, y + Math.sin(angle) * r * 1.5);
                ctx.stroke();
            }
            
            // Draw transformer agents
            for (const agent of transformerAgents) {
                drawAgent(tCtx, agent, '#ff6b6b', '#4ecdc4');
            }
            for (const agent of ranAgents) {
                drawAgent(tCtx, agent, '#4ecdc4', '#ff6b6b');
            }
            
            // Draw RAN agents
            for (const agent of transformerAgents) {
                drawAgent(rCtx, agent, '#ff6b6b', '#4ecdc4');
            }
            for (const agent of ranAgents) {
                drawAgent(rCtx, agent, '#4ecdc4', '#ff6b6b');
            }
            
            // Draw neural visualizations
            drawTransformerViz();
            drawRANViz();
        }

        function drawTransformerViz() {
            const viz = document.getElementById('transformer-viz');
            const ctx = viz.getContext ? viz.getContext('2d') : null;
            if (!ctx) {
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = viz.clientWidth;
                canvas.height = viz.clientHeight;
                viz.appendChild(canvas);
                return;
            }
        }

        function drawRANViz() {
            const viz = document.getElementById('ran-viz');
            if (viz.children.length === 0) {
                const canvas = document.createElement('canvas');
                canvas.id = 'ran-viz-canvas';
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                viz.appendChild(canvas);
            }
            
            const canvas = document.getElementById('ran-viz-canvas');
            if (!canvas) return;
            
            canvas.width = viz.clientWidth;
            canvas.height = viz.clientHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw oscillator states
            if (ranAgents.length > 0 && ranAgents[0].alive) {
                const states = ranAgents[0].brain.getStates();
                const spacing = canvas.width / (states.length + 1);
                
                for (let i = 0; i < states.length; i++) {
                    const s = states[i];
                    const x = spacing * (i + 1);
                    const y = canvas.height / 2 + s.x * 30;
                    
                    // Phase-colored oscillator
                    const hue = (s.phase / (Math.PI * 2)) * 360;
                    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 3 + Math.abs(s.v) * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function gameLoop() {
            for (let s = 0; s < speed; s++) {
                // Spawn resources
                if (Math.random() < CONFIG.RESOURCE_SPAWN_RATE && resources.length < CONFIG.MAX_RESOURCES) {
                    resources.push({
                        x: Math.random() * CONFIG.ARENA_SIZE,
                        y: Math.random() * CONFIG.ARENA_SIZE
                    });
                }
                
                // Count kills before update
                const tAliveB4 = ranAgents.filter(a => a.alive).length;
                const rAliveB4 = transformerAgents.filter(a => a.alive).length;
                
                // Update all agents
                for (const agent of transformerAgents) {
                    if (agent.update(resources, ranAgents, transformerAgents)) {
                        transformerScore++;
                    }
                }
                
                for (const agent of ranAgents) {
                    if (agent.update(resources, transformerAgents, ranAgents)) {
                        ranScore++;
                    }
                }
                
                // Count kills after update
                const tAliveAfter = ranAgents.filter(a => a.alive).length;
                const rAliveAfter = transformerAgents.filter(a => a.alive).length;
                transformerKills += tAliveB4 - tAliveAfter;
                ranKills += rAliveB4 - rAliveAfter;
                
                // Check win conditions
                const tAlive = transformerAgents.filter(a => a.alive).length;
                const rAlive = ranAgents.filter(a => a.alive).length;
                
                if (tAlive === 0 || rAlive === 0 || transformerScore >= CONFIG.WIN_SCORE || ranScore >= CONFIG.WIN_SCORE) {
                    let winner = null;
                    
                    if (tAlive === 0 && rAlive > 0) {
                        winner = 'ran';
                        ranWins++;
                        log(`üü¢ RAN WINS Round ${roundNum}! Eliminated all Transformers`, 'ran');
                    } else if (rAlive === 0 && tAlive > 0) {
                        winner = 'transformer';
                        transformerWins++;
                        log(`üî¥ TRANSFORMER WINS Round ${roundNum}! Eliminated all RAN agents`, 'transformer');
                    } else if (ranScore >= CONFIG.WIN_SCORE) {
                        winner = 'ran';
                        ranWins++;
                        log(`üü¢ RAN WINS Round ${roundNum}! Resource victory (${ranScore} pts)`, 'ran');
                    } else if (transformerScore >= CONFIG.WIN_SCORE) {
                        winner = 'transformer';
                        transformerWins++;
                        log(`üî¥ TRANSFORMER WINS Round ${roundNum}! Resource victory (${transformerScore} pts)`, 'transformer');
                    } else {
                        // Both died - compare scores
                        if (ranScore > transformerScore) {
                            winner = 'ran';
                            ranWins++;
                            log(`üü¢ RAN WINS Round ${roundNum}! Higher score (${ranScore} vs ${transformerScore})`, 'ran');
                        } else if (transformerScore > ranScore) {
                            winner = 'transformer';
                            transformerWins++;
                            log(`üî¥ TRANSFORMER WINS Round ${roundNum}! Higher score (${transformerScore} vs ${ranScore})`, 'transformer');
                        } else {
                            log(`‚öñÔ∏è Round ${roundNum} is a TIE!`, 'system');
                        }
                    }
                    
                    roundNum++;
                    initRound();
                }
            }
            
            draw();
            updateStats();
            
            if (running) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        function startSimulation() {
            if (!running) {
                running = true;
                gameLoop();
                log('‚ñ∂Ô∏è Simulation started', 'system');
            }
        }

        function pauseSimulation() {
            running = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            log('‚è∏Ô∏è Simulation paused', 'system');
        }

        function resetSimulation() {
            pauseSimulation();
            transformerWins = 0;
            ranWins = 0;
            roundNum = 1;
            initRound();
            draw();
            updateStats();
            log('üîÑ Simulation reset', 'system');
        }

        function speedUp() {
            speed = speed >= 8 ? 1 : speed * 2;
            log(`‚ö° Speed: ${speed}x`, 'system');
        }

        // Initialize
        initRound();
        draw();
        updateStats();
        
        // Add transformer viz canvas
        const tViz = document.getElementById('transformer-viz');
        const tVizCanvas = document.createElement('canvas');
        tVizCanvas.id = 'transformer-viz-canvas';
        tVizCanvas.style.width = '100%';
        tVizCanvas.style.height = '100%';
        tViz.appendChild(tVizCanvas);
        
        // Periodic transformer viz update
        setInterval(() => {
            const canvas = document.getElementById('transformer-viz-canvas');
            if (!canvas) return;
            
            const viz = document.getElementById('transformer-viz');
            canvas.width = viz.clientWidth;
            canvas.height = viz.clientHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw attention-like patterns
            if (transformerAgents.length > 0 && transformerAgents[0].alive) {
                const numPoints = 16;
                const spacing = canvas.width / (numPoints + 1);
                
                for (let i = 0; i < numPoints; i++) {
                    for (let j = 0; j < numPoints; j++) {
                        // Simulate attention pattern
                        const attn = Math.sin(i * 0.5 + Date.now() * 0.001) * 
                                    Math.cos(j * 0.5 + Date.now() * 0.001);
                        const alpha = Math.abs(attn);
                        ctx.fillStyle = `rgba(255, 107, 107, ${alpha * 0.5})`;
                        ctx.fillRect(spacing * (i + 0.5), j * 7, 4, 4);
                    }
                }
            }
        }, 50);
    </script>
</body>
</html>
